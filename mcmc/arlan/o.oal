AutoInitializeUniqueIDs@string@@te_class@inst_ref<Extended Class>@@instance@string@@@
//============================================================================
// $RCSfile: frag_util.arc,v $
//
// Description:
// This archetype file provides general purpose functions used during 
// action language translation. They are not specific to any particular
// fragment generator entry points.
//============================================================================
//
//============================================================================
// Initialize the attributes of type unique_id that are identifiers
// and therefore need to be automatically set up at create time.
//============================================================================
te_class = param.te_class;
instance = param.instance;
//
::oal( s:"T_clear();" );
select any te_file from instances of TE_FILE;
select any te_instance from instances of TE_INSTANCE;
select any te_prefix from instances of TE_PREFIX;
select any te_string from instances of TE_STRING;
select any te_sys from instances of TE_SYS;
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.'succeeds'];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  select one o_attr related by te_attr->O_ATTR[R2033];
  if ( te_attr.translate )
    r = ::GetAttributeCodeGenType( o_attr:o_attr );
    te_dt = r;
    not_empty_o_oida = false;
    if ( not_empty te_dt )
      if ( 5 == te_dt.Core_Typ )
        select any o_oida related by o_attr->O_OIDA[R105];
        if ( not_empty o_oida )
          not_empty_o_oida = true;
        end if;
      end if;
      T::include(file:"c/t.class.attribute.init.c");
    end if;
  end if;
  //
  // Advance to the next object attribute, if any.
  select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
end while;
return T::body();
@@@
ExpandNonOptimizedSpecialWhereComparison@string@@o_obj@inst_ref<Model Class>@@special@boolean@@selected_var_name@string@@@
//
//============================================================================
o_obj = param.o_obj;
special = param.special;
selected_var_name = param.selected_var_name;
//
compare_stmt = "";
if ( special )
  select any te_instance from instances of TE_INSTANCE;
  select any te_string from instances of TE_STRING;
  compare_stmt = "";
  cmp_element = "";
  select one te_class related by o_obj->TE_CLASS[R2019];
  // Be sure we have the first attribute in the class.
  select any first_te_attr related by te_class->TE_ATTR[R2061];
  while ( not_empty first_te_attr )
    select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.'succeeds'];
    if ( empty prev_te_attr )
      break;
    end if;
    first_te_attr = prev_te_attr;
  end while;
  te_attr = first_te_attr;
  while ( not_empty te_attr )
    //.if ( 4 == te_attr.Core_Typ )
    if ( 4 == 4 )
      cmp_element = "!${te_instance.module}${te_string.strcmp}(${selected_var_name}->${te_attr.GeneratedName}, ${te_attr.ParamBuffer})";
    else
      cmp_element = "${selected_var_name}->${te_attr.GeneratedName} == ${te_attr.ParamBuffer}";
    end if;
    compare_stmt = compare_stmt + cmp_element;
    // Advance to the next object attribute, if any.
    select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
    if ( not_empty te_attr )
      compare_stmt = compare_stmt + " && ";
    end if;
  end while;
end if;
return compare_stmt;
@@@
CreateSpecialWhereComparisonArguments@string@@te_class@inst_ref<Extended Class>@@o_id@inst_ref<Class Identifier>@@@
//
//============================================================================
te_class = param.te_class;
o_id = param.o_id;
//
select many o_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105];
num_ident_attr = cardinality o_attrs;
//
param_list = "";
oida_count = 0;
//
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.'succeeds'];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  if ( te_attr.Included )
    oida_count = oida_count + 1;
    param_list = param_list + te_attr.ParamBuffer;
    if ( oida_count < num_ident_attr )
      param_list = param_list + ", ";
    end if;
  end if;
  select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
end while;
//
return param_list;
@@@
oal@void@@s@string@@@
//
s = param.s;
@@@
GetBaseTypeForUDT@inst_ref<Data Type>@@s_udt@inst_ref<User Data Type>@@@
//============================================================================
// Recursively locate the datatype at the base of the UDT type definition 
// chain. Traverses up through UDTs based on UDTs until we find the underlying
// S_DT instance (which may actually be EDT, SDT, IRDT or CDT).
//============================================================================
s_udt = param.s_udt;
select one s_dt related by s_udt->S_DT[R18];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
return s_dt;
@@@
GetAttributeCodeGenType@inst_ref<Extended Data Type>@@o_attr@inst_ref<Attribute>@@@
//
//============================================================================
//   Get the S_DT and S_CDT object references for a given attribute
//   (O_ATTR) instance.
//============================================================================
o_attr = param.o_attr;
//
select one s_dt related by o_attr->S_DT[R114];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
select one te_dt related by s_dt->TE_DT[R2021];
select one s_cdt related by s_dt->S_CDT[R17];
//
if ( empty s_cdt )
  select one s_edt related by s_dt->S_EDT[R17];
  if ( empty s_edt )
    select one s_sdt related by s_dt->S_SDT[R17];
    if ( empty s_sdt )
      select one s_irdt related by s_dt->S_IRDT[R17];
      if ( empty s_irdt )
        T::print(s:"Error in attribute ${o_attr.Name}");
        T::print(s:"with data type ${s_dt.Name}");
        T::exit(i:100);
      end if;
    end if;
  else
    // Enum, use integer type.
    // CDS Some day we should pass along the enumeration type.
    select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
  end if;
end if;
//
if ( not_empty s_cdt )
  if ( 7 == s_cdt.Core_Typ )
    // s_cdt.Core_Typ is "same_as<Base_Attribute>"
    select one base_o_attr related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106];
    if ( empty base_o_attr )
      select one o_obj related by o_attr->O_OBJ[R102];
      T::print(s:"\nCould not find O_BATTR for object ${o_obj.Name} (${o_obj.Key_Lett}) attribute ${o_attr.Name} !");
      T::print(s:"\nDid you combine a referential and then rename the combined attribute?");
      T::exit(i:101);
    end if;
    // Note: the following is a recursive call to this function
    r = ::GetAttributeCodeGenType( o_attr:base_o_attr );
    te_dt = r;
  end if;
end if;
return te_dt;
@@@
MapUserSpecifiedDataTypePrecision@boolean@@te_dt@inst_ref<Extended Data Type>@@mapping@string@@@
//
//============================================================================
// Map a user defined data types precision into its corresponding instance
// of Data Type (S_DT).
// Note:  Might prefer POSIX type support here, but doubt we can count
// on most embedded targets thinking this way.  Thus brute force the types.
//============================================================================
te_dt = param.te_dt;
mapping = param.mapping;
error = false;
type = mapping;
if ( ( type == "uchar_t" ) or ( ( type == "u_char" ) or ( type == "unsignedchar" ) ) )
  te_dt.ExtName = "unsigned char";
elif ( ( type == "char_t" ) or ( type == "char" ) )
  te_dt.ExtName = "char";
elif ( type == "signedchar" )
  te_dt.ExtName = "signed char";
elif ( ( type == "ushort_t" ) or ( ( type == "u_short" ) or ( type == "unsignedshort" ) ) )
  te_dt.ExtName = "unsigned short";
elif ( ( type == "short_t" ) or ( type == "short" ) )
  te_dt.ExtName = "short";
elif ( type == "signedshort" )
  te_dt.ExtName = "signed short";
elif ( ( type == "uint_t" ) or ( ( type == "u_int" ) or ( type == "unsignedint" ) ) )
  te_dt.ExtName = "unsigned int";
elif ( type == "s1_t" )
  te_dt.ExtName = "s1_t";
elif ( type == "u1_t" )
  te_dt.ExtName = "u1_t";
elif ( type == "s2_t" )
  te_dt.ExtName = "s2_t";
elif ( type == "u2_t" )
  te_dt.ExtName = "u2_t";
elif ( type == "s4_t" )
  te_dt.ExtName = "s4_t";
elif ( type == "u4_t" )
  te_dt.ExtName = "u4_t";
elif ( type == "i_t" )
  te_dt.ExtName = "i_t";
elif ( ( type == "int_t" ) or ( type == "int" ) )
  te_dt.ExtName = "int";
elif ( type == "signedint" )
  te_dt.ExtName = "signed int";
elif ( ( type == "ulong_t" ) or ( ( type == "u_long" ) or ( type == "unsignedlong" ) ) )
  te_dt.ExtName = "unsigned long";
elif ( ( type == "long_t" ) or ( type == "long" ) )
  te_dt.ExtName = "long";
elif ( type == "signedlong" )
  te_dt.ExtName = "signed long";
elif ( ( type == "u_longlong_t" ) or ( ( type == "u_longlong_t" ) or ( type == "unsignedlonglong" ) ) )
  te_dt.ExtName = "unsigned long long";
elif ( ( type == "longlong_t" ) or ( ( type == "longlong" ) or ( type == "signedlonglong" ) ) )
  te_dt.ExtName = "long long";
  //
elif ( type == "float" )
  te_dt.ExtName = "float";
elif ( type == "r4_t" )
  te_dt.ExtName = "r4_t";
elif ( type == "double" )
  te_dt.ExtName = "double";
elif ( type == "r8_t" )
  te_dt.ExtName = "r8_t";
  //
elif ( type == "size_t" )
  te_dt.ExtName = "size_t";
elif ( type == "ssize_t" )
  te_dt.ExtName = "ssize_t";
elif ( type == "time_t" )
  te_dt.ExtName = "time_t";
elif ( type == "clock_t" )
  te_dt.ExtName = "clock_t";
elif ( type == "volatile_clock_t" )
  te_dt.ExtName = "volatile unsigned long";
  //
else
  error = true;
end if;
return error;
@@@
UserSuppliedDataTypeIncludes@string@@@
//
// Return the structure type for persistent links.
select any te_file from instances of TE_FILE;
sys_types_file_name = ( te_file.types + "." ) + te_file.hdr_file_ext;
select many special_te_dts from instances of TE_DT where ( ( selected.Include_File != "" ) and ( selected.Include_File != sys_types_file_name ) );
s = "";
for each special_te_dt in special_te_dts
  s = ( s + "#include """ ) + ( special_te_dt.Include_File + """\n" );
  ::oal( s:"s = Escher_strcpy( s, Escher_stradd( Escher_stradd( s, #include  ), Escher_stradd( special_te_dt->Include_File, \n ) ) ); // Ccode" );
end for;
return s;
@@@
sys_analyze@void@@te_sys@inst_ref<Extended System>@@@
//============================================================================
// This query file provides the "first pass" of a multi-pass translation
// model compiler.  The first pass analyzes the action semantics embodied
// in the analysis domain, and applies optimization algorithms to the
// action language statements encountered.  The results of these algorithmic
// operations are then leveraged by subsequent passes of the structural
// queries and templates to realize time/space/performance trade offs in
// the generated application code.
//============================================================================
//
//
te_sys = param.te_sys;
T::print(s:"Analyzing model and making optimizations....");
// Identify state models having at least one state, event and transition.
::SM_SM_mark_valid();
// Count up how many times each event is created/generated.
::event_smt_used();
// Find classes that are created in some way and identify invalid creates.
::class_smt_created();
// Detect invalid deletions.
::class_smt_deleted();
// Track down optimizable where clauses.
::selection_whereclause_identify_special();
// Identify the associations that need link and/or unlink methods.
::association_mark_link_unlink_needed();
// Identify associations that are navigated (in either or both directions).
::association_R_OIR_mark_navigated();
// Find which event queues are necessary.
::event_queue_analyze_needed();
::attr_analyze_accesses();
//.invoke attr_analyze_codegen( te_sys )
::TE_TXN_used();
@@@
te_c_CollectLimits@void@@te_c@inst_ref<Extended Component>@@@
//============================================================================
// These queries collect static analysis information and propagate it
// forward to the system build step by outputting a set of INSERT
// statements that will populate the system build gen database.
//============================================================================
//
//
//============================================================================
// Store statistics into TE_C.
//============================================================================
te_c = param.te_c;
//
select any te_file from instances of TE_FILE;
//
// Analyze maximums for extents.
// The extents should be analyzed only *after* extent size coloring!
select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
object_class_extents = 0;
relationship_extents = 0;
largest_object_extent = 0;
//
for each te_class in te_classs
  select one o_obj related by te_class->O_OBJ[R2019];
  object_class_extents = object_class_extents + te_class.MaxExtentSize;
  if ( te_class.MaxExtentSize > largest_object_extent )
    largest_object_extent = te_class.MaxExtentSize;
  end if;
  // Calculate maximum extents required for objects on "MANY" side of a relationship.
  select many r_rgos related by o_obj->R_OIR[R201]->R_RGO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rgo in r_rgos
    select one form related by r_rgo->R_FORM[R205];
    if ( not_empty form )
      if ( form.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one assr related by r_rgo->R_ASSR[R205];
    if ( not_empty assr )
      if ( assr.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
  select many r_rtos related by o_obj->R_OIR[R201]->R_RTO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rto in r_rtos
    select one aone related by r_rto->R_AONE[R204];
    if ( not_empty aone )
      if ( aone.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one aoth related by r_rto->R_AOTH[R204];
    if ( not_empty aoth )
      if ( aoth.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
end for;
//
// analyze timers events selects
r = ::timer_analyze_starts();
total_timer_starts = r;
//
// Count up the event specification statements which is the supertype
// of generated and deferred events.  This will give us a starting point
// on allocating event queue resources.
// CDS - We are (re)counting the events for each component, but this code is not component-specific.
// CDS - The event counts should be "harvested" while processing the action language.
max_events = 0;
max_self_events = 0;
max_nonself_events = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many event_specification_statements related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->E_ESS[R603];
  all_events_count = cardinality event_specification_statements;
  select many act_sgns related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->ACT_SGN[R603];
  all_events_count = all_events_count + ( cardinality act_sgns );
  if ( all_events_count > max_events )
    max_events = all_events_count;
  end if;
  // Count up the self events in this body.
  count = 0;
  for each e_ess in event_specification_statements
    select one v_var related by e_ess->E_GES[R701]->E_GSME[R703]->E_GEN[R705]->V_VAR[R712] where ( "self" == T::l(s:selected.Name) );
    if ( not_empty v_var )
      count = count + 1;
    else
      select any v_var related by event_specification_statements->E_CES[R701]->E_CSME[R702]->E_CEI[R704]->V_VAR[R711] where ( "self" == T::l(s:selected.Name) );
      if ( not_empty v_var )
        count = count + 1;
      end if;
    end if;
  end for;
  if ( count > max_self_events )
    max_self_events = count;
  end if;
  count = all_events_count - count;
  if ( count > max_nonself_events )
    max_nonself_events = count;
  end if;
  select one te_aba related by act_act->ACT_FNB[R698]->S_SYNC[R695]->TE_SYNC[R2023]->TE_ABA[R2010];
  if ( not_empty te_aba )
    te_aba.NonSelfEventCount = count;
  end if;
end for;
//
r = ::containoid_select_many_count();
max_select_many = r;
//
// functions
select many te_syncs related by te_c->TE_SYNC[R2084] where ( ( selected.IsSafeForInterrupts ) and ( selected.XlateSemantics ) );
total_interleaved_bridges = cardinality te_syncs;
//
// Count up the priority events.
select many te_evts from instances of TE_EVT where ( selected.Priority != 0 );
total_priority_events = cardinality te_evts;
//
// Count up the classes using preexisting instances defined in data (PEIs).
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.PEIsDefinedInData ) );
pei_class_count = cardinality te_classs;
//
// Count up the persistent classes.
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.Persistent ) );
persist_class_count = cardinality te_classs;
//
te_c.MaxObjExtent = object_class_extents;
te_c.MaxRelExtent = relationship_extents;
te_c.MaxSelectExtent = max_select_many * largest_object_extent;
te_c.MaxSelfEvents = max_self_events;
te_c.MaxNonSelfEvents = max_nonself_events;
te_c.MaxPriorityEvents = total_priority_events;
te_c.MaxTimers = total_timer_starts;
te_c.InterleavedBridges = total_interleaved_bridges;
te_c.PEIClassCount = pei_class_count;
te_c.PersistentClassCount = persist_class_count;
//
@@@
selection_whereclause_identify_special@void@@@
//============================================================================
// The query/transformations in this file analyze the action language
// of the customer model and gather statistics for use in optimized
// code generation.
//============================================================================
//
//
//
// Identify (special) where clauses that can be optimized.
//
// Select the class from which extent we are selecting.
//  Mark its identifying attributes.
// Select the blind select statements having where clauses.
// Select the values that represent the where clauses that
// are binary expressions where the operator is == or AND.
// BUG:  R676 and R677 should be unconditional on the O_OBJ side.
// Select the V_SLRs and their attributes.
// Compare the two sets.
//
select many act_fiws from instances of ACT_FIW;
for each act_fiw in act_fiws
  select one v_bin related by act_fiw->V_VAL[R610]->V_BIN[R801] where ( ( selected.Operator == "and" ) or ( selected.Operator == "==" ) );
  if ( not_empty v_bin )
    select one o_obj related by act_fiw->O_OBJ[R676];
    // Select the TE_WHEREs, because we can check to see if we have
    // already marked a special where.
    select many te_wheres related by o_obj->O_ID[R104]->TE_WHERE[R2032] where ( not selected.WhereKey );
    if ( not_empty te_wheres )
      // Clear out the included flag on all attributes of this class.
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      // Call a routine that will recursively drill down and mark any
      // attributes compared in the where clause.
      ::where_clause_mark_selected_attributes( v_bin:v_bin );
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033] where ( selected.Included );
      if ( not_empty te_attrs )
        for each te_where in te_wheres
          select many identifying_te_attrs related by te_where->O_ID[R2032]->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
          if ( te_attrs == identifying_te_attrs )
            T::print(s:"marking SPECIAL where on ${o_obj.Key_Lett}:${o_obj.Name}");
            te_where.WhereKey = true;
          end if;
        end for;
      end if;
    end if;
  end if;
end for;
@@@
where_clause_mark_selected_attributes@void@@v_bin@inst_ref<Binary Operation>@@@
//
//
// Recursively drill down into the where clause expression marking
// selected attributes along the way.
//
v_bin = param.v_bin;
if ( v_bin.Operator == "and" )
  select one left_v_val related by v_bin->V_VAL[R802];
  select one right_v_val related by v_bin->V_VAL[R803];
  select one v_bin related by left_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
  select one v_bin related by right_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
elif ( v_bin.Operator == "==" )
  select one te_attr related by v_bin->V_VAL[R802]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
  select one te_attr related by v_bin->V_VAL[R803]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
else
  // allow return
end if;
@@@
SM_SM_mark_valid@void@@@
//
//
// Find valid state machines and mark them thusly.
// Such state machines have at least one each of state, event and transition.
//
// Select only the state machines that have been configured for generation.
select many te_sms from instances of TE_SM;
for each te_sm in te_sms
  select one sm_sm related by te_sm->SM_SM[R2043];
  select any sm_state related by sm_sm->SM_STATE[R501];
  if ( not_empty sm_state )
    select any sm_txn related by sm_sm->SM_TXN[R505];
    if ( not_empty sm_txn )
      select any sm_evt related by sm_sm->SM_EVT[R502];
      if ( not_empty sm_evt )
        te_sm.complete = true;
      end if;
    end if;
  end if;
end for;
@@@
TE_TXN_used@void@@@
//
//
// Update the size of SEM cells when transition actions are present.
//
select any te_sm from instances of TE_SM where ( selected.txn_action_count > 0 );
if ( not_empty te_sm )
  select any te_typemap from instances of TE_TYPEMAP;
  te_typemap.SEM_cell_type = "u2_t";
end if;
@@@
event_smt_used@void@@@
//
//
// Find and mark/count events that are used in action language.
// Even though we store the information in a count, this query
// only counts each event once.
//
select many e_gsmes from instances of E_GSME;
select many te_evts related by e_gsmes->SM_EVT[R707]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
select many e_csmes from instances of E_CSME;
select many te_evts related by e_csmes->SM_EVT[R706]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
// Mark all of the signals (inter-component class-based events) as used.
select many sm_sgevts from instances of SM_SGEVT;
select many te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
@@@
class_smt_created@void@@@
//
//
// Mark classes that are created synchronously (nonself) or
// asynchronously (self).
//
select many act_crs from instances of ACT_CR;
select many te_classs related by act_crs->O_OBJ[R671]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
select many act_cnvs from instances of ACT_CNV;
select many te_classs related by act_cnvs->O_OBJ[R672]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
// Now find any creator events to classes.
select many e_gecs from instances of E_GEC;
select many te_classs related by e_gecs->E_GSME[R705]->SM_EVT[R707]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.SelfCreated = true;
end for;
@@@
class_smt_deleted@void@@@
//
//
// Check for classes that are deleted synchronously and should not be.
//
select many act_dels from instances of ACT_DEL;
select many te_classs related by act_dels->V_VAR[R634]->V_INT[R814]->O_OBJ[R818]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
@@@
class_smt_crdel_check@void@@te_classs@inst_ref_set<Extended Class>@@@
//
te_classs = param.te_classs;
for each te_class in te_classs
  if ( te_class.IsReadOnly )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete read-only object ${o_obj.Name} (${o_obj.Key_Lett})");
  end if;
  if ( te_class.IsFixedPopulation )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete object ${o_obj.Name} (${o_obj.Key_Lett}) within static instance population.");
  end if;
end for;
@@@
event_queue_analyze_needed@void@@@
//
// Count up all the places that events are either generated directly (E_GEN)
// or where they are created for deferred generation (E_CEI).
// Also count up the self versus nonself events.
//
self_queue_needed = false;
nonself_queue_needed = false;
select many e_gens from instances of E_GEN;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name == "self" );
if ( not_empty v_var )
  self_queue_needed = true;
end if;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name != "self" );
if ( not_empty v_var )
  nonself_queue_needed = true;
end if;
if ( not ( self_queue_needed and nonself_queue_needed ) )
  select many e_ceis from instances of E_CEI;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name == "self" );
  if ( not_empty v_var )
    self_queue_needed = true;
  end if;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name != "self" );
  if ( not_empty v_var )
    nonself_queue_needed = true;
  end if;
end if;
if ( self_queue_needed )
  T::print(s:"Self event queue needed.");
end if;
if ( nonself_queue_needed )
  T::print(s:"Instance event queue needed.");
end if;
@@@
attr_analyze_accesses@void@@@
//
//
// Analyze and mark the attributes of the customer model to flag which
// attributes are read and/or written.  We will use this information
// later to optimize out member data access code that is not needed.
// Also, mark attributes participating as identifiers as used.
// Mark written, read and Used attributes to TE_ATTR.
//
attributes_read_count = 0;
attributes_written_count = 0;
//
// Select all the attribute values references.
// Cycle through them marking their associated attributes as being read.
// Then, see if they are written by determining whether they participate
// as an lval in an assignment.
// Note, there can be several V_AVLs for each O_ATTR.
//
select many te_attrs from instances of TE_ATTR;
for each te_attr in te_attrs
  select many v_avls related by te_attr->O_ATTR[R2033]->V_AVL[R806];
  if ( not_empty v_avls )
    if ( not te_attr.read )
      attributes_read_count = attributes_read_count + 1;
    end if;
    te_attr.read = true;
    te_attr.Used = true;
  end if;
  // attributes written
  select any act_ai related by v_avls->V_VAL[R801]->ACT_AI[R689];
  if ( not_empty act_ai )
    if ( not te_attr.written )
      attributes_written_count = attributes_written_count + 1;
      select one te_class related by te_attr->TE_CLASS[R2061];
      if ( te_class.IsReadOnly )
        T::print(s:"ERROR:  Attempt to write to read-only object ${te_class.Name} (${te_class.Key_Lett}).");
      end if;
    end if;
    te_attr.written = true;
  end if;
end for;
// Identifying attributes are copied across in RELATE statements
// even if they are never read or written.
select many o_oidas from instances of O_OIDA;
select many te_attrs related by o_oidas->O_ATTR[R105]->TE_ATTR[R2033];
for each te_attr in te_attrs
  te_attr.Used = true;
end for;
msg = T::s(i:attributes_read_count) + " attributes read";
T::print(s:"${msg}");
msg = T::s(i:attributes_written_count) + " attributes written";
T::print(s:"${msg}");
@@@
attr_analyze_codegen@void@@te_sys@inst_ref<Extended System>@@@
//
//
// Mark attributes that are not used, needed and should be optimized out.
//
te_sys = param.te_sys;
optimized_out_count = 0;
select many te_cs from instances of TE_C where ( not selected.OptDisabled );
select many te_attrs related by te_cs->TE_CLASS[R2064]->TE_ATTR[R2061];
for each te_attr in te_attrs
  select one o_attr related by te_attr->O_ATTR[R2033];
  // Do not translate current_state attributes.
  select one s_cdt related by o_attr->S_DT[R114]->S_CDT[R17] where ( selected.Core_Typ == 6 );
  if ( not_empty s_cdt )
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  end if;
  if ( not te_attr.Used )
    // not accessed?
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  else
    // referential attribute?
    select one o_rattr related by o_attr->O_RATTR[R106];
    if ( not_empty o_rattr )
      // Is referential not also an identifying attribute?
      select any o_oida related by o_attr->O_OIDA[R105] where ( selected.Attr_ID == o_rattr.Attr_ID );
      if ( ( empty o_oida ) and ( not te_attr.Used ) )
        if ( not te_sys.InstanceLoading )
          te_attr.translate = false;
          optimized_out_count = optimized_out_count + 1;
        end if;
      end if;
    end if;
  end if;
end for;
msg = T::s(i:optimized_out_count) + " attributes optimized out";
T::print(s:"${msg}");
@@@
association_R_OIR_mark_navigated@void@@@
//
//
// Here we mark which classes are navigated across associations in each
// direction, from the formalizer or from the participant.  The results
// are stored in instances linked to instances of R_OIR (TE_OIR).
//
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  select any r_oir related by act_lnk->R_REL[R681]->R_OIR[R201] where ( selected.Obj_ID == act_lnk.Obj_ID );
  select one te_oir related by r_oir->TE_OIR[R2035];
  if ( not_empty te_oir )
    te_oir.NavigatedTo = true;
  end if;
end for;
@@@
association_mark_link_unlink_needed@void@@@
//
//
// Select all of the association instances and mark the ones that
// actually get linked with the relate/unrelate OAL statements.
//
// Mark all navigation (across a particular association).
// Mark all assocations that get navigated.
//
select many te_rels from instances of TE_REL;
select many r_rels related by te_rels->R_REL[R2034];
for each r_rel in r_rels
  link_needed = false;
  unlink_needed = false;
  navigated = false;
  // Check if navigated.
  select any act_lnk related by r_rel->ACT_LNK[R681];
  if ( not_empty act_lnk )
    navigated = true;
  end if;
  // Check if related.
  select any act_rel related by r_rel->ACT_REL[R653];
  if ( not_empty act_rel )
    link_needed = true;
  else
    select any act_ru related by r_rel->ACT_RU[R654];
    if ( not_empty act_ru )
      link_needed = true;
    end if;
  end if;
  // Check if unrelated.
  select any act_unr related by r_rel->ACT_UNR[R655];
  if ( not_empty act_unr )
    unlink_needed = true;
  else
    select any act_uru related by r_rel->ACT_URU[R656];
    if ( not_empty act_uru )
      unlink_needed = true;
    end if;
  end if;
  // Apply results to TE_REL.
  if ( ( link_needed or unlink_needed ) or navigated )
    select one te_rel related by r_rel->TE_REL[R2034];
    if ( navigated )
      te_rel.Navigated = true;
    end if;
    if ( link_needed )
      te_rel.LinkNeeded = true;
    end if;
    if ( unlink_needed )
      te_rel.UnlinkNeeded = true;
    end if;
  end if;
end for;
@@@
containoid_select_many_count@integer@@@
//============================================================================
// Utility functions specifically for OAL analysis.
//============================================================================
//
//
//
// Find the maximum number of "select many" statements expressed in
// one action body.  We will use this number to estimate the container
// pool.
// CDS - This gets called for each component but uses all actions in 
// the system.  And it gets called too many times.
//
result = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many act_smts related by act_act->ACT_BLK[R601]->ACT_SMT[R602];
  select many act_sels related by act_smts->ACT_SEL[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fios related by act_smts->ACT_FIO[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fiws related by act_smts->ACT_FIW[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  count = cardinality act_sels;
  c1 = cardinality act_fios;
  count = count + c1;
  c1 = cardinality act_fiws;
  count = count + c1;
  if ( count > result )
    result = count;
  end if;
end for;
return result;
@@@
timer_analyze_starts@integer@@@
//
//
// Count up the number of places where a timer is started (or started
// in recurring mode).
//
result = 0;
select any te_target from instances of TE_TARGET;
select many s_ees from instances of S_EE where ( selected.Key_Lett == "TIM" );
if ( "C++" == te_target.language )
  if ( not_empty s_ees )
    result = 1;
  end if;
end if;
for each s_ee in s_ees
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start_recurring" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
end for;
return result;
@@@
CreateSpecialWhereClauseInstances@void@@te_sys@inst_ref<Extended System>@@@
//
//============================================================================
// Class: 2000.  Special Where Clause
// CREATE TABLE TE_SWC (
// 	Obj_Kl		STRING,
// 	Where_Spec	STRING,
// 	Key	        STRING,
// 	Ret_Val	        BOOLEAN,
//	Built_In	BOOLEAN,
//	Oid_ID	        INTEGER );
//
// Notes:
// (1) The selected attributes of the where clause _Key_ are specified in the
//     same order as they appear on the OIM. This convention allows other
//     archetypes a _rule_ for dealing with the positional parameter
//     information provided during fragment parsing of a special where clause.
//============================================================================
te_sys = param.te_sys;
//
// Special Where Clause patterns that may be optimized by the model compiler.
//
unique_num = 0;
select many te_classes from instances of TE_CLASS where ( not selected.ExcludeFromGen );
for each te_class in te_classes
  select many o_ids related by te_class->O_OBJ[R2019]->O_ID[R104];
  for each o_id in o_ids
    select one te_where related by o_id->TE_WHERE[R2032];
    // Get all special wheres when loading instances even if they are
    // not seen in the OAL.  We need them for batch_relate.
    if ( te_sys.InstanceLoading )
      select any r_rto related by o_id->R_RTO[R109];
      if ( not_empty r_rto )
        te_where.WhereKey = true;
      end if;
    end if;
    if ( te_where.WhereKey )
      key_number = o_id.Oid_ID + 1;
      where_spec = "";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      //
      select many te_attrs related by te_class->TE_ATTR[R2061];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      //
      select many te_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
      num_ident_attr = cardinality te_attrs;
      for each te_attr in te_attrs
        te_attr.Included = true;
      end for;
      //
      // *** Provide a key without parenthesis.
      // Be sure we have the first attribute in the class.
      select any first_te_attr related by te_class->TE_ATTR[R2061];
      while ( not_empty first_te_attr )
        select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.'succeeds'];
        if ( empty prev_te_attr )
          break;
        end if;
        first_te_attr = prev_te_attr;
      end while;
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.${o_attr.Name} == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      // *** Provide a key parenthesized at the outer construct.
      where_spec = "(";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.${o_attr.Name} == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          else
            where_spec = where_spec + ")";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      if ( num_ident_attr > 1 )
        // *** Provide a key parenthesized at outer and inner constructs.
        where_spec = "(";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.${o_attr.Name} == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            else
              where_spec = where_spec + ")";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        // *** Provide a key parenthesized at just inner constructs.
        where_spec = "";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.${o_attr.Name} == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.'precedes'];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        //
      end if;
    end if;
  end for;
end for;
@@@
te_parm_RenderParameters@void@@te_parms@inst_ref_set<Extended Parameter>@@te_aba@inst_ref<Action Block Anchor>@@@
//============================================================================
// Here we deal with parameters.  The declaration, definition and invocation
// renderings are built.
//============================================================================
//
//
te_parms = param.te_parms;
te_aba = param.te_aba;
// Consider that we may have additional parameters (like for passing "self").
defn = "";
decl = "";
if ( empty te_parms )
  decl = " void";
end if;
invo = "";
stru = "";
parameter_trace = "";
string_format = "";
assn = "";
assnbase = "";
param_delimiter = " ";
format_delimiter = "";
Order = 0;
// Be sure we have the first parameter.
select any te_parm from instances of TE_PARM where ( false );
for each te_parm in te_parms
  break;
end for;
while ( not_empty te_parm )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.'succeeds'];
  if ( empty prev_te_parm )
    break;
  else
    te_parm = prev_te_parm;
  end if;
end while;
while ( not_empty te_parm )
  te_parm.Order = Order;
  Order = Order + 1;
  select one te_dt related by te_parm->TE_DT[R2049];
  te_dt.Included = true;
  defn = defn + param_delimiter;
  decl = decl + param_delimiter;
  param_qual = "";
  if ( 0 != te_parm.By_Ref )
    param_qual = param_qual + " *";
  else
    // CDS const correctness goes here
    // Arrays in C are always by ref, so add const to scalars only.
    if ( ( "" == te_parm.array_spec ) and ( ( 1 <= te_dt.Core_Typ ) and ( te_dt.Core_Typ <= 3 ) ) )
      defn = defn + "const ";
      decl = decl + "const ";
    end if;
  end if;
  defn = ( ( defn + te_dt.ExtName ) + ( param_qual + " " ) ) + ( te_parm.GeneratedName + te_parm.array_spec );
  decl = ( ( decl + te_dt.ExtName ) + ( param_qual + te_parm.array_spec ) );
  invo = ( invo + param_delimiter ) + te_parm.GeneratedName;
  stru = ( ( stru + te_dt.ExtName ) + ( param_qual + " " ) ) + ( ( te_parm.GeneratedName + te_parm.array_spec ) + ";\n" );
  if ( ( "" != te_dt.string_format ) and ( "" == te_parm.array_spec ) )
    // Do not trace structures or arrays.
    dereference = "";
    if ( 0 != te_parm.By_Ref )
      dereference = "*";
    end if;
    parameter_trace = ( parameter_trace + ", " ) + ( dereference + te_parm.GeneratedName );
    string_format = ( string_format + format_delimiter ) + te_dt.string_format;
  else
    string_format = ( string_format + format_delimiter ) + "[]";
  end if;
  r = ::t_oal_smt_event_parameters( evt_msg_var:"", parameter:te_parm.Name, value:te_parm.GeneratedName, value_type:te_dt.Core_Typ, ws:"  " );
  assn = assn + r;
  if ( ( "A00portindex" != te_parm.Name ) and ( "A0xtumlsret" != te_parm.Name ) )
    assnbase = assnbase + r;
  end if;
  param_delimiter = ", ";
  format_delimiter = ",";
  select one te_parm related by te_parm->TE_PARM[R2041.'precedes'];
end while;
if ( "" != defn )
  defn = defn + " ";
end if;
te_aba.ParameterDefinition = defn;
te_aba.ParameterDeclaration = decl + " ";
te_aba.ParameterInvocation = invo;
te_aba.ParameterStructure = stru;
te_aba.ParameterTrace = parameter_trace;
te_aba.ParameterFormat = string_format;
te_aba.ParameterAssignment = assn;
te_aba.ParameterAssignmentBase = assnbase;
@@@
sparm_sort@void@@s_sparms@inst_ref_set<Function Parameter>@@@
// CDS temporarily order parameters alphabetically for backwards compatibility
s_sparms = param.s_sparms;
for each s_sparm in s_sparms
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.'succeeds'];
  if ( not_empty prev_s_sparm )
    unrelate s_sparm from prev_s_sparm across R54.'succeeds';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_sparm related by s_sparms->S_SPARM[R54.'succeeds'] where ( false );
for each s_sparm in s_sparms
  r = ::sparm_insert( head_s_sparm:head_s_sparm, s_sparm:s_sparm );
  head_s_sparm = r;
end for;
@@@
sparm_insert@inst_ref<Function Parameter>@@head_s_sparm@inst_ref<Function Parameter>@@s_sparm@inst_ref<Function Parameter>@@@
head_s_sparm = param.head_s_sparm;
s_sparm = param.s_sparm;
result = s_sparm;
if ( empty head_s_sparm )
  // Just starting.  Return s_sparm as head.
elif ( s_sparm.Name <= head_s_sparm.Name )
  // insert before
  relate s_sparm to head_s_sparm across R54.'precedes';
else
  // find bigger
  result = head_s_sparm;
  prev_s_sparm = head_s_sparm;
  select one cursor_s_sparm related by head_s_sparm->S_SPARM[R54.'precedes'];
  while ( not_empty cursor_s_sparm )
    if ( s_sparm.Name <= cursor_s_sparm.Name )
      break;
    else
      prev_s_sparm = cursor_s_sparm;
      select one cursor_s_sparm related by cursor_s_sparm->S_SPARM[R54.'precedes'];
    end if;
  end while;
  relate prev_s_sparm to s_sparm across R54.'precedes';
  if ( not_empty cursor_s_sparm )
    relate s_sparm to cursor_s_sparm across R54.'precedes';
  end if;
end if;
return result;
@@@
bparm_sort@void@@s_bparms@inst_ref_set<Bridge Parameter>@@@
//
//
s_bparms = param.s_bparms;
for each s_bparm in s_bparms
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.'succeeds'];
  if ( not_empty prev_s_bparm )
    unrelate s_bparm from prev_s_bparm across R55.'succeeds';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_bparm related by s_bparms->S_BPARM[R55.'succeeds'] where ( false );
for each s_bparm in s_bparms
  r = ::bparm_insert( head_s_bparm:head_s_bparm, s_bparm:s_bparm );
  head_s_bparm = r;
end for;
@@@
bparm_insert@inst_ref<Bridge Parameter>@@head_s_bparm@inst_ref<Bridge Parameter>@@s_bparm@inst_ref<Bridge Parameter>@@@
head_s_bparm = param.head_s_bparm;
s_bparm = param.s_bparm;
result = s_bparm;
if ( empty head_s_bparm )
  // Just starting.  Return s_bparm as head.
elif ( s_bparm.Name <= head_s_bparm.Name )
  // insert before
  relate s_bparm to head_s_bparm across R55.'precedes';
else
  // find bigger
  result = head_s_bparm;
  prev_s_bparm = head_s_bparm;
  select one cursor_s_bparm related by head_s_bparm->S_BPARM[R55.'precedes'];
  while ( not_empty cursor_s_bparm )
    if ( s_bparm.Name <= cursor_s_bparm.Name )
      break;
    else
      prev_s_bparm = cursor_s_bparm;
      select one cursor_s_bparm related by cursor_s_bparm->S_BPARM[R55.'precedes'];
    end if;
  end while;
  relate prev_s_bparm to s_bparm across R55.'precedes';
  if ( not_empty cursor_s_bparm )
    relate s_bparm to cursor_s_bparm across R55.'precedes';
  end if;
end if;
return result;
@@@
tparm_sort@void@@o_tparms@inst_ref_set<Operation Parameter>@@@
//
//
o_tparms = param.o_tparms;
for each o_tparm in o_tparms
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.'succeeds'];
  if ( not_empty prev_o_tparm )
    unrelate o_tparm from prev_o_tparm across R124.'succeeds';
  end if;
end for;
// Declare an empty instance reference.
select any head_o_tparm related by o_tparms->O_TPARM[R124.'succeeds'] where ( false );
for each o_tparm in o_tparms
  r = ::tparm_insert( head_o_tparm:head_o_tparm, o_tparm:o_tparm );
  head_o_tparm = r;
end for;
@@@
tparm_insert@inst_ref<Operation Parameter>@@head_o_tparm@inst_ref<Operation Parameter>@@o_tparm@inst_ref<Operation Parameter>@@@
head_o_tparm = param.head_o_tparm;
o_tparm = param.o_tparm;
result = o_tparm;
if ( empty head_o_tparm )
  // Just starting.  Return o_tparm as head.
elif ( o_tparm.Name <= head_o_tparm.Name )
  // insert before
  relate o_tparm to head_o_tparm across R124.'precedes';
else
  // find bigger
  result = head_o_tparm;
  prev_o_tparm = head_o_tparm;
  select one cursor_o_tparm related by head_o_tparm->O_TPARM[R124.'precedes'];
  while ( not_empty cursor_o_tparm )
    if ( o_tparm.Name <= cursor_o_tparm.Name )
      break;
    else
      prev_o_tparm = cursor_o_tparm;
      select one cursor_o_tparm related by cursor_o_tparm->O_TPARM[R124.'precedes'];
    end if;
  end while;
  relate prev_o_tparm to o_tparm across R124.'precedes';
  if ( not_empty cursor_o_tparm )
    relate o_tparm to cursor_o_tparm across R124.'precedes';
  end if;
end if;
return result;
@@@
evtdi_sort@void@@sm_evtdis@inst_ref_set<State Machine Event Data Item>@@@
//
//
sm_evtdis = param.sm_evtdis;
for each sm_evtdi in sm_evtdis
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.'succeeds'];
  if ( not_empty prev_sm_evtdi )
    unrelate sm_evtdi from prev_sm_evtdi across R533.'succeeds';
  end if;
end for;
// Declare an empty instance reference.
select any head_sm_evtdi related by sm_evtdis->SM_EVTDI[R533.'succeeds'] where ( false );
for each sm_evtdi in sm_evtdis
  r = ::evtdi_insert( head_sm_evtdi:head_sm_evtdi, sm_evtdi:sm_evtdi );
  head_sm_evtdi = r;
end for;
@@@
evtdi_insert@inst_ref<State Machine Event Data Item>@@head_sm_evtdi@inst_ref<State Machine Event Data Item>@@sm_evtdi@inst_ref<State Machine Event Data Item>@@@
head_sm_evtdi = param.head_sm_evtdi;
sm_evtdi = param.sm_evtdi;
result = sm_evtdi;
if ( empty head_sm_evtdi )
  // Just starting.  Return sm_evtdi as head.
elif ( sm_evtdi.Name <= head_sm_evtdi.Name )
  // insert before
  relate sm_evtdi to head_sm_evtdi across R533.'precedes';
else
  // find bigger
  result = head_sm_evtdi;
  prev_sm_evtdi = head_sm_evtdi;
  select one cursor_sm_evtdi related by head_sm_evtdi->SM_EVTDI[R533.'precedes'];
  while ( not_empty cursor_sm_evtdi )
    if ( sm_evtdi.Name <= cursor_sm_evtdi.Name )
      break;
    else
      prev_sm_evtdi = cursor_sm_evtdi;
      select one cursor_sm_evtdi related by cursor_sm_evtdi->SM_EVTDI[R533.'precedes'];
    end if;
  end while;
  relate prev_sm_evtdi to sm_evtdi across R533.'precedes';
  if ( not_empty cursor_sm_evtdi )
    relate sm_evtdi to cursor_sm_evtdi across R533.'precedes';
  end if;
end if;
return result;
@@@
pp_sort@void@@c_pps@inst_ref_set<Property Parameter>@@@
//
//
c_pps = param.c_pps;
for each c_pp in c_pps
  select one prev_c_pp related by c_pp->C_PP[R4021.'succeeds'];
  if ( not_empty prev_c_pp )
    unrelate c_pp from prev_c_pp across R4021.'succeeds';
  end if;
end for;
// Declare an empty instance reference.
select any head_c_pp related by c_pps->C_PP[R4021.'succeeds'] where ( false );
for each c_pp in c_pps
  r = ::pp_insert( head_c_pp:head_c_pp, c_pp:c_pp );
  head_c_pp = r;
end for;
@@@
pp_insert@inst_ref<Property Parameter>@@head_c_pp@inst_ref<Property Parameter>@@c_pp@inst_ref<Property Parameter>@@@
head_c_pp = param.head_c_pp;
c_pp = param.c_pp;
result = c_pp;
if ( empty head_c_pp )
  // Just starting.  Return c_pp as head.
elif ( c_pp.Name <= head_c_pp.Name )
  // insert before
  relate c_pp to head_c_pp across R4021.'precedes';
else
  // find bigger
  result = head_c_pp;
  prev_c_pp = head_c_pp;
  select one cursor_c_pp related by head_c_pp->C_PP[R4021.'precedes'];
  while ( not_empty cursor_c_pp )
    if ( c_pp.Name <= cursor_c_pp.Name )
      break;
    else
      prev_c_pp = cursor_c_pp;
      select one cursor_c_pp related by cursor_c_pp->C_PP[R4021.'precedes'];
    end if;
  end while;
  relate prev_c_pp to c_pp across R4021.'precedes';
  if ( not_empty cursor_c_pp )
    relate c_pp to cursor_c_pp across R4021.'precedes';
  end if;
end if;
return result;
@@@
parm_sort@void@@@
//
// CDS temporary for sorting model data parameters
if ( true )
  select many s_syncs from instances of S_SYNC;
  for each s_sync in s_syncs
    select many s_sparms related by s_sync->S_SPARM[R24];
    ::sparm_sort( s_sparms:s_sparms );
  end for;
  select many s_brgs from instances of S_BRG;
  for each s_brg in s_brgs
    select many s_bparms related by s_brg->S_BPARM[R21];
    ::bparm_sort( s_bparms:s_bparms );
  end for;
  select many o_tfrs from instances of O_TFR;
  for each o_tfr in o_tfrs
    select many o_tparms related by o_tfr->O_TPARM[R117];
    ::tparm_sort( o_tparms:o_tparms );
  end for;
  select many sm_evts from instances of SM_EVT;
  for each sm_evt in sm_evts
    select many sm_evtdis related by sm_evt->SM_EVTDI[R532];
    ::evtdi_sort( sm_evtdis:sm_evtdis );
  end for;
  select many c_eps from instances of C_EP;
  for each c_ep in c_eps
    select many c_pps related by c_ep->C_PP[R4006];
    ::pp_sort( c_pps:c_pps );
  end for;
end if;
@@@
rel_pseudoformalize@void@@@
//============================================================================
// This query/transformation archetype file contains the functionality
// that will allow the model compiler to generate code for unformalized 
// associations (associations that have not been formalized).
//============================================================================
//
// Find the associations that are not formalized.  They are characterized
// by the existence of 2 instances of R_PART linked to one R_SIMP.
// Migrate the R_PART/R_RTO pair to R_FORM/R_RGO.
// It does not matter which participant we choose unless this is a many
// association.  Grab the many side of a 1-M or any random R_PART and
// migrate it and its parent R_RTO to R_FORM and R_RGO respectively.
select many r_simps from instances of R_SIMP;
for each r_simp in r_simps
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any r_part related by r_simp->R_PART[R207] where ( selected.Mult == 1 );
    if ( empty r_part )
      select any r_part related by r_simp->R_PART[R207];
    end if;
    select one r_rto related by r_part->R_RTO[R204];
    select one r_oir related by r_rto->R_OIR[R203];
    //
    create object instance r_rgo of R_RGO;
    create object instance r_form of R_FORM;
    //
    // Copy the R_PART to the new R_FORM.
    r_form.Mult = r_part.Mult;
    r_form.Cond = r_part.Cond;
    r_form.Txt_Phrs = r_part.Txt_Phrs;
    //
    unrelate r_part from r_rto across R204;
    unrelate r_part from r_simp across R207;
    delete object instance r_part;
    //
    unrelate r_rto from r_oir across R203;
    delete object instance r_rto;
    //
    relate r_rgo to r_oir across R203;
    relate r_form to r_rgo across R205;
    relate r_form to r_simp across R208;
  end if;
end for;
@@@
sys_populate@void@@@
//============================================================================
// This query/transformation archetype file queries the customer model
// and populates the model compiler extensions to the meta-model.
// Instances of the extended classes are created, related and initialized.
//
// Create architectural system-level artifacts first.
// Create leaf-node artifacts (like TE_DT, TE_VAL and TE_PAR) which may need
// to be updated as information is gathered.
// Create component-level artifacts.
// Briefly create and link components, data types.  Select them afterwards.
// Create and link middled-level classes.
// Drill down into component and create object, attributes and the rest.
//============================================================================
//
//
// Create the system interfaces (sys, dom, ee).
//
// Select singletons into scope.
select any te_file from instances of TE_FILE;
select any te_eq from instances of TE_EQ;
select any te_extent from instances of TE_EXTENT;
select any te_instance from instances of TE_INSTANCE;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_string from instances of TE_STRING;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
select any te_tim from instances of TE_TIM;
select any te_typemap from instances of TE_TYPEMAP;
select many empty_ep_pkgs from instances of EP_PKG where ( false );
select any empty_te_c from instances of TE_C where ( false );
select any empty_te_dim from instances of TE_DIM where ( false );
select many empty_s_dims from instances of S_DIM where ( false );
select any empty_o_obj from instances of O_OBJ where ( false );
select any empty_te_attr from instances of TE_ATTR where ( false );
select any empty_te_mact from instances of TE_MACT where ( false );
select many empty_te_dts from instances of TE_DT where ( false );
select many empty_te_parms from instances of TE_PARM where ( false );
// CDS - Note that in a multiple-system build, we will get lucky, and the
// s_sys from the local project will be selected first.
select any s_sys from instances of S_SYS;
if ( empty s_sys )
  create object instance s_sys of S_SYS;
  s_sys.Name = "sys";
end if;
// Create the system translation extension and relate it.
select any te_sys from instances of TE_SYS;
if ( empty te_sys )
  create object instance te_sys of TE_SYS;
  te_sys.SystemID = 1;
end if;
relate s_sys to te_sys across R2018;
te_sys.Name = T::r(s:s_sys.Name);
if ( "" == te_sys.Name )
  te_sys.Name = "sys";
end if;
te_sys.MaxStringLen = 32;
te_sys.PersistInstanceCacheDepth = 128;
te_sys.PersistLinkCacheDepth = 128;
te_sys.AUTOSAR = false;
te_sys.AllPortsPoly = false;
te_sys.StructuredMessaging = false;
te_sys.NetworkSockets = false;
//
// Update te_sys with system marks
select any tm_systag from instances of TM_SYSTAG;
if ( not_empty tm_systag )
  te_sys.MaxStringLen = tm_systag.MaxStringLen;
  te_sys.MaxRelExtent = tm_systag.MaxRelExtent;
  te_sys.MaxSelectExtent = tm_systag.MaxSelectExtent;
  te_sys.MaxSelfEvents = tm_systag.MaxSelfEvents;
  te_sys.MaxNonSelfEvents = tm_systag.MaxNonSelfEvents;
  te_sys.MaxTimers = tm_systag.MaxTimers;
  te_sys.MaxInterleavedBridges = tm_systag.MaxInterleavedBridges;
  te_sys.MaxInterleavedBridgeDataSize = tm_systag.MaxInterleavedBridgeDataSize;
  te_sys.CollectionsFlavor = tm_systag.CollectionsFlavor;
  te_sys.PersistInstanceCacheDepth = tm_systag.PersistInstanceCacheDepth;
  te_sys.PersistLinkCacheDepth = tm_systag.PersistLinkCacheDepth;
  te_sys.UnitsToDynamicallyAllocate = tm_systag.UnitsToDynamicallyAllocate;
  te_sys.VFB = tm_systag.VFB;
  te_sys.InstanceLoading = tm_systag.InstanceLoading;
  te_sys.SystemCPortsType = tm_systag.SystemCPortsType;
  te_sys.AllPortsPoly = tm_systag.AllPortsPoly;
  te_sys.StructuredMessaging = tm_systag.StructuredMessaging;
  te_sys.NetworkSockets = tm_systag.NetworkSockets;
else
  te_sys.SystemCPortsType = "sc_interface";
end if;
//
// Update the tasking threads based on marking.
select any tm_thread from instances of TM_THREAD;
if ( not_empty tm_thread )
  te_thread.extra_initialization = tm_thread.extra_initialization;
  te_thread.number_of_threads = tm_thread.number_of_threads;
  te_thread.enabled = tm_thread.enabled;
  te_thread.serialize = tm_thread.serialize;
  te_thread.flavor = tm_thread.flavor;
  if ( "AUTOSAR" == te_thread.flavor )
    te_sys.AUTOSAR = true;
  end if;
end if;
//
select any te_disp from instances of TE_DISP;
if ( empty te_disp )
  create object instance te_disp of TE_DISP;
  te_disp.Dispatcher_ID = 1;
  relate te_disp to te_sys across R2003;
end if;
te_disp.Descrip = "dispatcher";
te_disp.Name = "main";
select any te_queue from instances of TE_QUEUE;
select any nonself_te_queue from instances of TE_QUEUE;
if ( empty te_queue )
  create object instance te_queue of TE_QUEUE;
  te_queue.Queue_ID = 1;
  relate te_queue to te_disp across R2004;
  create object instance nonself_te_queue of TE_QUEUE;
  nonself_te_queue.Queue_ID = 2;
  relate nonself_te_queue to te_disp across R2004;
end if;
// Self Queue
te_queue.Descrip = "Self Queue";
te_queue.RenderCode = false;
te_queue.MaxDepth = 0;
te_queue.Type = 1;
// NonSelf Queue
nonself_te_queue.Descrip = "NonSelf Queue";
nonself_te_queue.RenderCode = false;
nonself_te_queue.MaxDepth = 0;
nonself_te_queue.Type = 2;
//
// Create the (domain) class info array instance.
// CDS - This may end up being part of a component rather than a system.
create object instance te_cia of TE_CIA;
te_cia.class_info_name = "domain_class_info";
te_cia.class_info_type = te_extent.type;
te_cia.active_count = "active_count";
te_cia.class_count = "domain_class_count";
te_cia.count_type = te_typemap.object_number_name;
//
//
// Create the Extended Component instance(s) and link them up.
select many c_cs from instances of C_C;
for each c_c in c_cs
  create object instance te_c of TE_C;
  relate te_c to c_c across R2054;
  relate te_c to te_sys across R2065;
  te_c.Name = T::r(s:c_c.Name);
  te_c.Descrip = c_c.Descrip;
  te_c.included_in_build = true;
        select any tm_c from instances of TM_C where ( selected.Name == c_c.Name );
  if ( not_empty tm_c )
    if ( ( tm_c.isRealized ) or ( c_c.isRealized ) )
      // Component is realized, so skip translation of internals.
      te_c.isRealized = true;
    end if;
  end if;
  te_c.internal_behavior = false;
  te_c.module_file = te_c.Name;
  te_c.port_file = te_c.Name;
  te_c.classes_file = te_c.Name + "_classes";
  te_c.CodeComments = true;
  // Create and relate the domain class info to carry details about
  // class extents for this component.
  create object instance te_dci of TE_DCI;
  relate te_dci to te_c across R2090;
  te_dci.class_numbers = te_c.Name + "_CLASS_NUMBERS";
  te_dci.persist_union = te_c.Name + "_CLASS_U";
  te_dci.task_list = te_c.Name + "_task_numbers";
  te_dci.task_numbers = te_c.Name + "_TASK_NUMBERS";
  te_dci.max = te_c.Name + "_MAX_CLASS_NUMBERS";
  te_dci.max_models = te_c.Name + "_STATE_MODELS";
  te_dci.init = te_c.Name + "_CLASS_INFO_INIT";
  te_dci.array_name = te_c.Name + "_class_info";
  // Create the Component Instance instances.
  select many cl_ics related by c_c->CL_IC[R4201];
  for each cl_ic in cl_ics
    create object instance te_ci of TE_CI;
    te_ci.Name = te_c.Name;
    if ( "" == cl_ic.ClassifierName )
      te_ci.ClassifierName = "i" + te_c.Name;
    else
      te_ci.ClassifierName = T::r(s:cl_ic.ClassifierName);
    end if;
    relate te_ci to te_c across R2008;
    relate te_ci to cl_ic across R2009;
  end for;
  // Create the Extended Ports.
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
    if ( not_empty c_i )
      create object instance te_po of TE_PO;
      relate te_po to c_po across R2044;
      relate te_po to te_c across R2005;
      relate te_po to c_i across R2007;
      te_po.InterfaceName = T::r(s:c_i.Name);
      select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
      if ( not_empty c_r )
        te_po.Provision = false;
      else
        te_po.Provision = true;
      end if;
      te_po.polymorphic = false;
      te_po.sibling = 0;
      te_po.Name = c_po.Name;
      te_po.GeneratedName = T::r(s:te_po.Name);
      // Create the Interface Instance instances.
      select many c_irs related by c_po->C_IR[R4016];
      for each c_ir in c_irs
        create object instance te_iir of TE_IIR;
                        relate te_iir to c_ir across R2046;
        relate te_iir to te_po across R2080;
        te_iir.component_name = c_c.Name;
        te_iir.port_name = te_po.Name;
        te_iir.interface_name = te_po.InterfaceName;
        te_iir.polymorphic = false;
        select many cl_iirs related by c_ir->CL_IIR[R4701];
        for each cl_iir in cl_iirs
          create object instance te_iir of TE_IIR;
                              relate te_iir to cl_iir across R2013;
          relate te_iir to te_po across R2080;
          te_iir.port_name = te_po.Name;
          te_iir.interface_name = te_po.InterfaceName;
          te_iir.polymorphic = false;
        end for;
      end for;
    end if;
  end for;
  // Identify polymorhic ports.
  // Polymorphic ports exist more than once in the same orientation on a component.
  port_counter = 0;
  select many te_pos related by te_c->TE_PO[R2005];
  for each te_po in te_pos
    te_po.Order = port_counter;
    port_counter = port_counter + 1;
    select many poly_te_pos related by te_po->TE_C[R2005]->TE_PO[R2005] where ( ( ( selected.c_iId == te_po.c_iId ) and ( selected.Provision == te_po.Provision ) ) and ( selected.ID != te_po.ID ) );
    if ( not_empty poly_te_pos )
      // If we have seen this port already, it will be marked as polymorphic.
      // So, no need to iterate marking as not the first sibling.
      if ( not te_po.polymorphic )
        sibling_counter = 1;
        for each poly_te_po in poly_te_pos
          poly_te_po.polymorphic = true;
          poly_te_po.sibling = sibling_counter;
          sibling_counter = sibling_counter + 1;
        end for;
      end if;
      te_po.polymorphic = true;
      // Now mark the related interface reference instances as polymorphic.
      select many te_iirs related by te_po->TE_IIR[R2080];
      for each te_iir in te_iirs
        te_iir.polymorphic = true;
      end for;
    end if;
  end for;
end for;
// Here we force all the ports and interface references to be polymorphic.  
// We do this step via a second loop here so that we could set up the 
// sibling values earlier before all the ports potentially get forced to polymorphic.
// This loop also configures the satisfaction shortcut we create between local and
// foreign interface references.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_iirs related by te_po->TE_IIR[R2080];
  for each te_iir in te_iirs
    // Select across the satisfaction to get the related TE_IIR.
    if ( te_po.Provision )
      // provision side first
      // CDS There may be more than one here.
      select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        // We are dealing with TE_IIRs that may be on non-imported interface references (connected to C_Cs).
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.'provides or is delegated';
      end if;
    else
      // requirement side first
      select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.'requires or delegates';
      end if;
    end if;
  end for;
end for;
//
// By default, select all components to be translated.  However, if
// a package has been marked, translate only the components contained
// in the package (or referenced from it).
ep_pkgs = empty_ep_pkgs;
package_to_build = "";
select any tm_build from instances of TM_BUILD;
markedsystems = 0;
if ( not_empty tm_build )
  select many ep_pkgs from instances of EP_PKG where ( selected.Name == tm_build.package_to_build );
  markedsystems = cardinality ep_pkgs;
  if ( empty ep_pkgs )
    T::print(s:"ERROR:  Marked configuration package ${tm_build.package_to_build} was not found in model.  Exiting.");
    T::exit(i:11);
  end if;
  package_to_build = tm_build.package_to_build;
end if;
if ( markedsystems > 1 )
  T::print(s:"WARNING:  More than one package is marked as a system build... choose only one.");
end if;
if ( "" != package_to_build )
  T::print(s:"Marked configuration package ${package_to_build} found.");
  select many te_cs from instances of TE_C;
  // Clear the build flag for all components and then mark only those
  // requested by the marking.
  for each te_c in te_cs
    te_c.included_in_build = false;
  end for;
  select many te_cs related by ep_pkgs->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  // Uncomment the line below to use package name instead of project for the top-level files.
  //.assign te_sys.Name = "$r{package_to_build}"
else
  // Here we use the default name for the system derived from the project name.
end if;
te_file.types = ( te_sys.Name + "_" ) + te_file.types;
te_file.sys_main = ( te_sys.Name + "_" ) + te_file.sys_main;
//
// Select "Imported" Packages and link them to their imports to the
// appropriate component.
// Imported packages are empty packages imbedded within components
// that have the name of the target package as their description.
// Get the components that are part of the project.
select many te_cs from instances of TE_C where ( selected.included_in_build );
select many c_cs related by te_cs->C_C[R2054];
for each c_c in c_cs
  // Get the packages contained in this component.
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    // Get the packages that are empty (having no elements inside).
    select any pe_pe related by ep_pkg->PE_PE[R8000];
    if ( empty pe_pe )
      // We found an empty package, now check to see if it is marked as imported.
      if ( "" != ep_pkg.Descrip )
        select any imported_ep_pkg from instances of EP_PKG where ( selected.Name == ep_pkg.Descrip );
        if ( not_empty imported_ep_pkg )
          // We found a package that has a name as specified in the embedded package Descrip.
          // Disconnect the embedded package.  Relate the imported package.
          select one s_sys related by imported_ep_pkg->S_SYS[R1401];
          if ( not_empty s_sys )
            unrelate imported_ep_pkg from s_sys across R1401;
          end if;
          select one pe_pe related by ep_pkg->PE_PE[R8001];
          unrelate pe_pe from ep_pkg across R8001;
          relate pe_pe to imported_ep_pkg across R8001;
        end if;
      end if;
    end if;
  end for;
end for;
//
// Create and link the Extended model compiler instances.
// Do not fully initialize, yet.  Create and link and mark.
// These artifacts contain important naming that must propagate.
//
// Create the Generated Data Type instances and link them in.
select many s_dts from instances of S_DT;
for each s_dt in s_dts
  create object instance te_dt of TE_DT;
  relate te_dt to s_dt across R2021;
  te_dt.Name = s_dt.Name;
  te_dt.Core_Typ = -1;
  te_dt.string_format = "";
    // Link the ownership if contained in a component.
  te_c = empty_te_c;
  select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
    te_c = r;
  end if;
  if ( empty te_c )
    // Default the owner to be the system.
    te_dt.Owning_Dom_Name = te_sys.Name;
  else
    te_dt.Owning_Dom_Name = te_c.Name;
    relate te_dt to te_c across R2086;
  end if;
end for;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
//
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  te_c = empty_te_c;
  select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Generated Class instance and link it to the real one.
      r1 = ::FactoryTE_CLASS( o_obj:o_obj, te_c:te_c );
      te_class = r1;
      if ( "C++" == te_target.language )
        te_class.scope = te_class.GeneratedName + "::";
      end if;
    end if;
  end if;
end for;
//
select many s_syncs from instances of S_SYNC;
for each s_sync in s_syncs
  te_c = empty_te_c;
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended Function instance and link it to the real one.
      create object instance te_sync of TE_SYNC;
      relate s_sync to te_sync across R2023;
      relate te_sync to te_c across R2084;
      te_sync.Name = s_sync.Name;
      te_sync.GeneratedName = ( te_c.Name + "_" ) + te_sync.Name;
    end if;
  end if;
end for;
//
select many s_ees from instances of S_EE;
for each s_ee in s_ees
  select one ep_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( empty te_c )
    // Here we have an EE in a package outside of a component.
    create object instance te_ee of TE_EE;
    relate te_ee to s_ee across R2020;
    // Be sure we are not related to any te_c across R2085
      else
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended EE instance and link it to the real one.
      create object instance te_ee of TE_EE;
      relate te_ee to s_ee across R2020;
      relate te_ee to te_c across R2085;
    end if;
  end if;
end for;
//
//
// Create the low-level leaf items.
//
// Initialize information for a core data type:  the ANSI C typedef
// that the data type is known by in the generated code in both a
// normal object declaration and an event declaration and the initial
// value of the data element.
select many s_cdts from instances of S_CDT;
for each s_cdt in s_cdts
  select one te_dt related by s_cdt->S_DT[R17]->TE_DT[R2021];
  te_dt.Core_Typ = s_cdt.Core_Typ;
  te_dt.Include_File = te_file.types + ( "." + te_file.hdr_file_ext );
  if ( 0 == te_dt.Core_Typ )
    // void
    te_dt.ExtName = "void";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "";
  elif ( 1 == te_dt.Core_Typ )
    // boolean
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLBoolean";
    else
      te_dt.ExtName = "bool";
    end if;
    te_dt.Initial_Value = "false";
    te_dt.string_format = "%d";
  elif ( 2 == te_dt.Core_Typ )
    // integer
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLInteger";
    else
      te_dt.ExtName = "i_t";
    end if;
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  elif ( 3 == te_dt.Core_Typ )
    // real
    // float or double:  Default to smaller type for embedded.
    // This can be expanded with the TagDatatypePrecision marking.
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLReal";
    else
      te_dt.ExtName = "r_t";
    end if;
    te_dt.Initial_Value = "0.0";
    te_dt.string_format = "%f";
  elif ( 4 == te_dt.Core_Typ )
    // string
    te_dt.ExtName = "c_t";
    if ( te_sys.InstanceLoading )
      te_dt.ExtName = "c_t *";
    end if;
    te_dt.Initial_Value = "CTOR";
    te_dt.string_format = "%s";
  elif ( 5 == te_dt.Core_Typ )
    // unique_id
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
    //
  elif ( 6 == te_dt.Core_Typ )
    // current_state
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 7 == te_dt.Core_Typ )
    // same as base<Attribute>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( ( 8 == te_dt.Core_Typ ) or ( 20 == te_dt.Core_Typ ) )
    // inst_ref<Object>
    te_dt.ExtName = "void *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( ( 9 == te_dt.Core_Typ ) or ( 21 == te_dt.Core_Typ ) )
    // inst_ref_set<Object>
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 10 == te_dt.Core_Typ )
    // inst<Event>
    te_dt.ExtName = te_eq.base_event_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 11 == te_dt.Core_Typ )
    // inst<Mapping>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 12 == te_dt.Core_Typ )
    // inst_ref<Mapping>
    te_dt.ExtName = "i_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  else
    // undefined
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%x";
  end if;
end for;
//
// Initialize information for user data types.
select many s_udts from instances of S_UDT;
for each s_udt in s_udts
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  base_s_dt = r;
  select one core_te_dt related by base_s_dt->TE_DT[R2021];
  // Given a user data type (S_UDT) and a core data type (S_CDT), set
  // the C typedef that the user data type is known by in the generated
  // code.  Also set the initial value of the attribute.
  // Note:  An initial value of "CTOR" means to run the constructor.
  select one s_dt related by s_udt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  te_dt.Is_Enum = false;
  te_dt.Core_Typ = core_te_dt.Core_Typ;
  te_dt.Include_File = core_te_dt.Include_File;
  te_dt.ExtName = core_te_dt.ExtName;
  te_dt.string_format = core_te_dt.string_format;
  if ( "" != s_dt.DefaultValue )
    te_dt.Initial_Value = s_dt.DefaultValue;
  else
    te_dt.Initial_Value = core_te_dt.Initial_Value;
  end if;
  //
  // CTOR is a special string used to invoke the constructor of a data
  // attribute on the initialization list of the object constructor.
  if ( s_dt.Name == "date" )
    te_dt.ExtName = te_prefix.type + "Date_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "timestamp" )
    te_dt.ExtName = te_prefix.type + "TimeStamp_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "inst_ref<Timer>" )
    if ( te_tim.keyed_timer_support )
      te_dt.ExtName = te_prefix.type + "Timer_t";
    else
      te_dt.ExtName = te_prefix.type + "Timer_t *";
    end if;
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "inst_ref<StateMachine>" )
    te_dt.ExtName = "<${te_prefix.type}Object Type *>";
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "arbitrary_id" )
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
  end if;
end for;
//
// Initialize information for enumeration data types.
select many s_edts from instances of S_EDT;
for each s_edt in s_edts
  select one s_dt related by s_edt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  // NOTE: We should allow the size of an enum to be colored.
  // For now use small type.
  if ( te_sys.AUTOSAR )
    te_dt.ExtName = "en_" + te_dt.Name;
  elif ( "C" == te_target.language )
    te_dt.ExtName = ( te_sys.Name + "_" ) + ( te_dt.Name + "_t" );
  else
    te_dt.ExtName = te_dt.Name + "_t";
  end if;
  // CDS We should some day pass along the EDT.
  te_dt.Core_Typ = 2;
  te_dt.Is_Enum = true;
  te_dt.Initial_Value = ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "__UNINITIALIZED__e" );
  te_dt.Value = "-1";
  te_dt.string_format = "%d";
  if ( te_dt.Owning_Dom_Name == "sys" )
    te_dt.Include_File = ( te_file.types + "." ) + te_file.hdr_file_ext;
  end if;
  //
  // Create the Generated Enumerators and link them to the real ones.
  select many s_enums related by s_edt->S_ENUM[R27];
  for each s_enum in s_enums
    create object instance te_enum of TE_ENUM;
    relate s_enum to te_enum across R2027;
    te_enum.Name = s_enum.Name;
    te_enum.GeneratedName = ( ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "_" ) ) + ( T::r(s:te_enum.Name) + "_e" );
    value = T::parsekeyword(s:s_enum.Descrip,key:"value");
    if ( "" == value )
      value = T::parsekeyword(s:s_enum.Descrip,key:"Value");
      if ( "" == value )
        value = T::parsekeyword(s:s_enum.Descrip,key:"VALUE");
      end if;
    end if;
    te_enum.Value = value;
  end for;
end for;
//
// Initialize structured data types.
select many s_sdts from instances of S_SDT;
for each s_sdt in s_sdts
  select one te_dt related by s_sdt->S_DT[R17]->TE_DT[R2021];
  te_dt.ExtName = ( te_dt.Owning_Dom_Name + "_sdt_" ) + te_dt.Name;
  te_dt.string_format = "";
  select many s_mbrs related by s_sdt->S_MBR[R44];
  for each s_mbr in s_mbrs
    create object instance te_mbr of TE_MBR;
    relate s_mbr to te_mbr across R2047;
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    relate te_mbr to mbr_te_dt across R2068;
  end for;
  for each s_mbr in s_mbrs
    select one te_mbr related by s_mbr->TE_MBR[R2047];
    select one previous_te_mbr related by s_mbr->S_MBR[R46.'succeeds']->TE_MBR[R2047];
    if ( not_empty previous_te_mbr )
      relate te_mbr to previous_te_mbr across R2067.'succeeds';
    else
          end if;
    te_mbr.Name = s_mbr.Name;
    te_mbr.GeneratedName = T::r(s:s_mbr.Name);
    select many s_dims related by s_mbr->S_DIM[R53];
    array_spec = "";
    te_mbr.dimensions = cardinality s_dims;
    te_dim = empty_te_dim;
    dim_index = 0;
    while ( dim_index < te_mbr.dimensions )
      select any s_dim related by s_mbr->S_DIM[R53] where ( selected.dimensionCount == dim_index );
      r1 = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r1;
      if ( dim_index == 0 )
        relate te_dim to te_mbr across R2059;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
      dim_index = dim_index + 1;
    end while;
    te_mbr.array_spec = array_spec;
    // In the C model compiler, treat strings as arrays.
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    if ( ( 4 == mbr_te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
      // string
      te_mbr.dimensions = te_mbr.dimensions + 1;
      te_mbr.array_spec = ( te_mbr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  end for;
end for;
//
// Initialize instance reference data types.
select many s_irdts from instances of S_IRDT;
for each s_irdt in s_irdts
  select one te_dt related by s_irdt->S_DT[R17]->TE_DT[R2021];
  select one te_class related by s_irdt->O_OBJ[R123]->TE_CLASS[R2019];
  if ( s_irdt.isSet )
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Core_Typ = 21;
  else
    te_dt.Core_Typ = 20;
    if ( not_empty te_class )
      te_dt.ExtName = te_class.GeneratedName + " *";
    end if;
  end if;
end for;
//
// Update the precision of the integer and real types based on marking.
select many tm_precisions from instances of TM_PRECISION;
for each tm_precision in tm_precisions
  te_dts = empty_te_dts;
  if ( ( "*" == tm_precision.Domain ) or ( "" == tm_precision.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_precision.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_precision.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_precision.DT_name );
  end if;
  for each te_dt in te_dts
    // Only allow precision specification of core types integer
    // and real and user defined types (UDTs) that are enums
    // (including S_EDT).
    // S_CDT.Core_Typ == 2 is integer, S_CDT.Core_Typ == 3 is real
    select one s_dt related by te_dt->S_DT[R2021];
    select one s_edt related by s_dt->S_EDT[R17];
    select one s_cdt related by s_dt->S_CDT[R17];
    if ( empty s_cdt )
      select one s_udt related by s_dt->S_UDT[R17];
      if ( not_empty s_udt )
        r = ::GetBaseTypeForUDT( s_udt:s_udt );
        base_s_dt = r;
        select one s_cdt related by base_s_dt->S_CDT[R17];
      end if;
      if ( empty s_cdt )
        select one s_irdt related by s_dt->S_IRDT[R17];
        if ( empty s_irdt )
          if ( empty s_edt )
            T::print(s:"Warning:  Could not find a core data type (S_CDT) for input type.");
            T::exit(i:101);
          end if;
          // Enumeration Data Type (S_EDT) - give it a core type of integer.
          select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
        else
          if ( s_irdt.isSet )
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 9 );
          else
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 8 );
          end if;
        end if;
      end if;
    end if;
    if ( ( s_cdt.Core_Typ == 2 ) or ( s_cdt.Core_Typ == 3 ) )
      r = ::MapUserSpecifiedDataTypePrecision( te_dt:te_dt, mapping:tm_precision.xName );
      status_error = r;
      if ( status_error )
        te_dt.ExtName = tm_precision.xName;
      end if;
      if ( ( "" != tm_precision.initial_value ) and ( empty s_edt ) )
        te_dt.Initial_Value = tm_precision.initial_value;
      end if;
    end if;
  end for;
end for;
//
// Map data types to pointers based on marking.
select many tm_pointers from instances of TM_POINTER;
for each tm_pointer in tm_pointers
  te_dts = empty_te_dts;
  if ( ( "*" == tm_pointer.Domain ) or ( "" == tm_pointer.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_pointer.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_pointer.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_pointer.DT_name );
  end if;
  for each te_dt in te_dts
    te_dt.ExtName = tm_pointer.pointer_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.Include_File = tm_pointer.include_file;
    te_dt.Is_Enum = false;
    if ( 4 == te_dt.Core_Typ )
      // Change core type so that dimensions are not added to the pointer.
      te_dt.Core_Typ = -4;
    end if;
  end for;
end for;
//
// Mark enumerator discrete values (from marking).
select many tm_enumvals from instances of TM_ENUMVAL;
for each tm_enumval in tm_enumvals
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enumval.Domain ) or ( "" == tm_enumval.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enumval.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enumval.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_enumval.enumeration );
  end if;
  for each te_dt in te_dts
    select any te_enum related by te_dt->S_DT[R2021]->S_EDT[R17]->S_ENUM[R27]->TE_ENUM[R2027] where ( selected.Name == tm_enumval.enumerator );
    if ( not_empty te_enum )
      te_enum.Value = tm_enumval.value;
    end if;
  end for;
end for;
//
// Mark enumerator default uninitialized values (from marking).
select many tm_enuminits from instances of TM_ENUMINIT;
for each tm_enuminit in tm_enuminits
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enuminit.Domain ) or ( "" == tm_enuminit.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enuminit.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enuminit.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_enuminit.enumeration );
  end if;
  for each te_dt in te_dts
    te_dt.Value = tm_enuminit.value;
  end for;
end for;
//
// Create a string parameter that can be duplicated and used for returning string data.
select any string_te_dt from instances of TE_DT where ( selected.Name == "string" );
r3 = ::FactoryTE_PARM( s_dims:empty_s_dims, te_dt:string_te_dt, prefix:"", name:"A0xtumlsret", by_ref:0 );
te_parm = r3;
//
// Create the values and connect them to the V_VAL.
select many v_vals from instances of V_VAL;
for each v_val in v_vals
  create object instance te_val of TE_VAL;
  relate v_val to te_val across R2040;
  te_val.array_spec = "";
  te_val.dimensions = 0;
end for;
//
// Create the extended actual parameters and connect them to V_PAR.
select many v_pars from instances of V_PAR;
for each v_par in v_pars
  create object instance te_par of TE_PAR;
  te_par.Name = v_par.Name;
  te_par.By_Ref = 0;
  relate te_par to v_par across R2063;
end for;
//
// Create the Generated Parameters needed for all types of parameters.
// During this process, te_pars created above will be updated with
// By_Ref information.
// The TE_PARM instances must exist before creating the action bodies
// (for functions, operation, messages, etc).
select many s_bparms from instances of S_BPARM;
for each s_bparm in s_bparms
  select many s_dims related by s_bparm->S_DIM[R49];
  select one te_dt related by s_bparm->S_DT[R22]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_bparm.Name, by_ref:s_bparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = s_bparm.Descrip;
  relate s_bparm to te_parm across R2028;
  select many te_pars related by s_bparm->S_BRG[R21]->ACT_BRG[R674]->V_PAR[R628]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_bparm->S_BRG[R21]->V_BRV[R828]->V_PAR[R810]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_bparm in s_bparms
  select one te_parm related by s_bparm->TE_PARM[R2028];
  select one next_te_parm related by s_bparm->S_BPARM[R55.'precedes']->TE_PARM[R2028];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.'precedes';
  end if;
end for;
select many o_tparms from instances of O_TPARM;
for each o_tparm in o_tparms
  select many s_dims related by o_tparm->S_DIM[R121];
  select one te_dt related by o_tparm->S_DT[R118]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:o_tparm.Name, by_ref:o_tparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = o_tparm.Descrip;
  relate o_tparm to te_parm across R2029;
  select many te_pars related by o_tparm->O_TFR[R117]->ACT_TFM[R673]->V_PAR[R627]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by o_tparm->O_TFR[R117]->V_TRV[R829]->V_PAR[R811]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each o_tparm in o_tparms
  select one te_parm related by o_tparm->TE_PARM[R2029];
  select one next_te_parm related by o_tparm->O_TPARM[R124.'precedes']->TE_PARM[R2029];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.'precedes';
  end if;
end for;
select many s_sparms from instances of S_SPARM;
for each s_sparm in s_sparms
  select many s_dims related by s_sparm->S_DIM[R52];
  select one te_dt related by s_sparm->S_DT[R26]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_sparm.Name, by_ref:s_sparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = s_sparm.Descrip;
  relate s_sparm to te_parm across R2030;
  select many te_pars related by s_sparm->S_SYNC[R24]->ACT_FNC[R675]->V_PAR[R669]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_sparm->S_SYNC[R24]->V_FNV[R827]->V_PAR[R817]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_sparm in s_sparms
  select one te_parm related by s_sparm->TE_PARM[R2030];
  select one next_te_parm related by s_sparm->S_SPARM[R54.'precedes']->TE_PARM[R2030];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.'precedes';
  end if;
end for;
select many sm_evtdis from instances of SM_EVTDI;
for each sm_evtdi in sm_evtdis
  select many s_dims related by sm_evtdi->S_DIM[R531];
  select one te_dt related by sm_evtdi->S_DT[R524]->TE_DT[R2021];
  // Event data items are not passable By_Ref at this time.
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:sm_evtdi.Name, by_ref:0 );
  te_parm = r;
  te_parm.Descrip = sm_evtdi.Descrip;
  relate te_parm to sm_evtdi across R2031;
end for;
// Link the event parameters into order.
for each sm_evtdi in sm_evtdis
  select one te_parm related by sm_evtdi->TE_PARM[R2031];
  select one next_te_parm related by sm_evtdi->SM_EVTDI[R533.'precedes']->TE_PARM[R2031];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.'precedes';
  end if;
end for;
select many c_pps from instances of C_PP;
for each c_pp in c_pps
  select many s_dims related by c_pp->S_DIM[R4017];
  select one te_dt related by c_pp->S_DT[R4007]->TE_DT[R2021];
  c_pp_name = c_pp.Name;
  if ( "C++" == te_target.language )
    select one c_as related by c_pp->C_EP[R4006]->C_AS[R4004];
    if ( not_empty c_as )
      c_pp_name = ( c_as.Name + "_" ) + c_pp_name;
    else
      select one c_io related by c_pp->C_EP[R4006]->C_IO[R4004];
      c_pp_name = ( c_io.Name + "_" ) + c_pp_name;
    end if;
  end if;
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:c_pp_name, by_ref:c_pp.By_Ref );
  te_parm = r;
  te_parm.Descrip = c_pp.Descrip;
  relate c_pp to te_parm across R2048;
  select many spr_reps related by c_pp->C_EP[R4006]->SPR_REP[R4500];
  if ( not_empty spr_reps )
    select many te_pars related by spr_reps->SPR_RS[R4502]->ACT_SGN[R660]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->SPR_RO[R4502]->ACT_IOP[R657]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->V_MSV[R845]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
  select many spr_peps related by c_pp->C_EP[R4006]->SPR_PEP[R4501];
  if ( not_empty spr_peps )
    select many te_pars related by spr_peps->SPR_PS[R4503]->ACT_SGN[R663]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->SPR_PO[R4503]->ACT_IOP[R680]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->V_MSV[R841]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
end for;
// Link the event parameters into order.
for each c_pp in c_pps
  select one te_parm related by c_pp->TE_PARM[R2048];
  select one next_te_parm related by c_pp->C_PP[R4021.'precedes']->TE_PARM[R2048];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.'precedes';
  end if;
end for;
//
//
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
//
// Create the port message actions.  There are four types.  Use
// a common extension class for all of them.
// Populate the extension with all of the names it will need from
// the component, interface, port and message.
select many spr_ros from instances of SPR_RO;
for each spr_ro in spr_ros
  select one spr_rep related by spr_ro->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_rep->C_EP[R4500]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_ro.Name, subtypeKL:"SPR_RO" );
  te_mact = r;
  te_mact.Descrip = c_io.Descrip;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_ro across R2052;
end for;
select many spr_rss from instances of SPR_RS;
for each spr_rs in spr_rss
  select one spr_rep related by spr_rs->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_rep->C_EP[R4500]->C_AS[R4004];
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_rs.Name, subtypeKL:"SPR_RS" );
  te_mact = r;
  te_mact.Descrip = c_as.Descrip;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_rs across R2053;
end for;
select many spr_pos from instances of SPR_PO;
for each spr_po in spr_pos
  select one spr_pep related by spr_po->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_pep->C_EP[R4501]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_po.Name, subtypeKL:"SPR_PO" );
  te_mact = r;
  te_mact.Descrip = c_io.Descrip;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_po across R2050;
end for;
select many spr_pss from instances of SPR_PS;
for each spr_ps in spr_pss
  select one spr_pep related by spr_ps->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_pep->C_EP[R4501]->C_AS[R4004];
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_ps.Name, subtypeKL:"SPR_PS" );
  te_mact = r;
  te_mact.Descrip = c_as.Descrip;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_ps across R2051;
end for;
// All the te_pos and te_macts are created now.  Order the te_macts alphabetically inside the ports.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_macts related by te_po->TE_MACT[R2006];
  r = ::mact_sort( te_macts:te_macts );
  te_mact = r;
  if ( not_empty te_mact )
    relate te_po to te_mact across R2099.'has first';
  end if;
end for;
//
//
// Create the generated links (associations) and connect them.
// CDS - consider moving this in under the TE_C loop.
// also consider selecting these from include r_oirs.
select many r_rels from instances of R_REL;
for each r_rel in r_rels
  create object instance te_rel of TE_REL;
  te_rel.Numb = r_rel.Numb;
  if ( te_sys.InstanceLoading )
    te_rel.LinkNeeded = true;
  else
    te_rel.LinkNeeded = false;
  end if;
  te_rel.UnlinkNeeded = false;
  te_rel.Navigated = false;
  te_rel.Order = 0;
  te_rel.storage_needed = false;
  relate r_rel to te_rel across R2034;
end for;
//
// Create the navigations and connect them to the R_OIRs.
select many r_oirs from instances of R_OIR;
for each r_oir in r_oirs
  create object instance te_oir of TE_OIR;
  select one o_obj related by r_oir->O_OBJ[R201];
  select one r_rel related by r_oir->R_REL[R201];
  te_oir.data_member = ( o_obj.Key_Lett + "_R" ) + T::s(i:r_rel.Numb);
  te_oir.assoc_type = "";
  te_oir.Mult = 0;
  te_oir.rel_phrase = "";
  te_oir.object_id = "";
  te_oir.NavigatedTo = false;
  relate r_oir to te_oir across R2035;
end for;
select many r_parts related by r_rels->R_SIMP[R206]->R_PART[R207];
for each r_part in r_parts
  select one te_oir related by r_part->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "part";
  te_oir.rel_phrase = T::underscore(s:r_part.Txt_Phrs);
  te_oir.Mult = r_part.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_forms from instances of R_FORM;
for each r_form in r_forms
  select one te_oir related by r_form->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "form";
  te_oir.rel_phrase = T::underscore(s:r_form.Txt_Phrs);
  te_oir.Mult = r_form.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aones from instances of R_AONE;
for each r_aone in r_aones
  select one te_oir related by r_aone->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aone";
  te_oir.rel_phrase = T::underscore(s:r_aone.Txt_Phrs);
  te_oir.Mult = r_aone.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aoths from instances of R_AOTH;
for each r_aoth in r_aoths
  select one te_oir related by r_aoth->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aoth";
  te_oir.rel_phrase = T::underscore(s:r_aoth.Txt_Phrs);
  te_oir.Mult = r_aoth.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_assrs from instances of R_ASSR;
for each r_assr in r_assrs
  select one te_oir related by r_assr->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "assr";
  te_oir.Mult = r_assr.Mult;
end for;
select many r_subs from instances of R_SUB;
for each r_sub in r_subs
  select one te_oir related by r_sub->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  select one r_rel related by r_sub->R_SUBSUP[R213]->R_REL[R206];
  te_oir.assoc_type = "subsuper";
  te_oir.object_id = ( "R" + T::s(i:r_rel.Numb) ) + "_object_id";
  te_oir.data_member = ( "R" + T::s(i:r_rel.Numb) ) + "_subtype";
end for;
select many r_supers from instances of R_SUPER;
for each r_super in r_supers
  select one te_oir related by r_super->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "subsuper";
end for;
//
// Create the blocks and connect them to the ACT_BLKs.
select many act_blks from instances of ACT_BLK;
for each act_blk in act_blks
  create object instance te_blk of TE_BLK;
  relate act_blk to te_blk across R2016;
    te_blk.declaration = "";
  te_blk.deallocation = "";
  te_blk.depth = 1;
  first_smt = true;
  // Create the statements and connect them to the ACT_SMTs.
  select many act_smts related by act_blk->ACT_SMT[R602];
  for each act_smt in act_smts
    create object instance te_smt of TE_SMT;
    relate act_smt to te_smt across R2038;
    // Connect the statement to its parent block.
    relate te_smt to te_blk across R2078;
    if ( first_smt )
      // CDS WARNING!! This assumes the gen_erate will give us the first statement first!
      relate te_blk to te_smt across R2014;
      first_smt = false;
    end if;
    te_smt.OAL = "";
    te_smt.buffer = "";
    te_smt.buffer2 = "";
    te_smt.trace = "";
          end for;
  // Link the te_smts into order like the act_smts.
  for each act_smt in act_smts
    select one te_smt related by act_smt->TE_SMT[R2038];
    select one next_act_smt related by act_smt->ACT_SMT[R661.'precedes'];
    if ( not_empty next_act_smt )
      select one next_te_smt related by next_act_smt->TE_SMT[R2038];
      relate te_smt to next_te_smt across R2012.'precedes';
    end if;
  end for;
end for;
//
// Connect up statements and blocks in the extended subsystem.
// We want statements to know:
// 1) containing block
// 2) sub-block
// [for, while, if, elif and else statements have sub-blocks.]
select many act_fors from instances of ACT_FOR;
for each act_for in act_fors
  select one te_smt related by act_for->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_for->ACT_BLK[R605]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_FOR";
end for;
select many act_whls from instances of ACT_WHL;
for each act_whl in act_whls
  select one te_smt related by act_whl->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_whl->ACT_BLK[R608]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_WHL";
end for;
select many act_ifs from instances of ACT_IF;
for each act_if in act_ifs
  select one te_smt related by act_if->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_if->ACT_BLK[R607]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_IF";
end for;
select many act_els from instances of ACT_EL;
for each act_el in act_els
  select one te_smt related by act_el->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_el->ACT_BLK[R658]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_EL";
end for;
select many act_es from instances of ACT_E;
for each act_e in act_es
  select one te_smt related by act_e->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_e->ACT_BLK[R606]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_E";
end for;
// Calculate the block depth to be used for indentation.
select many te_blks from instances of TE_BLK;
for each te_blk in te_blks
  select one parent_te_blk related by te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  while ( not_empty parent_te_blk )
    te_blk.depth = te_blk.depth + 1;
    select one parent_te_blk related by parent_te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  end while;
  r = ::blk_indentwhitespace( indentation:te_blk.depth );
  te_blk.indentation = r;
end for;
//
// Create the generated chain links and connect them to the ACT_LNKs.
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  ::FactoryTE_LNK( act_lnk:act_lnk );
end for;
// Link the chain links together in extensions as in meta-model proper.
select many te_lnks from instances of TE_LNK;
for each te_lnk in te_lnks
  select one act_lnk related by te_lnk->ACT_LNK[R2042];
  select one next_act_lnk related by act_lnk->ACT_LNK[R604.'precedes'];
  if ( not_empty next_act_lnk )
    select one next_te_lnk related by next_act_lnk->TE_LNK[R2042];
    relate te_lnk to next_te_lnk across R2075.'precedes';
    // We populate this here.  Populate firsts during statement linkage.
    next_te_lnk.left = te_lnk.linkage;
    // We may have traversed directly from aoth to aone (or vice versa)
    // across an associative association.  If so, insert the associative
    // link between the two ends to enable the traversal.
    r = ::detect_and_insert_associator_TE_LNK( te_lnk:te_lnk, next_te_lnk:next_te_lnk, act_lnk:act_lnk, next_act_lnk:next_act_lnk, start_o_obj:empty_o_obj );
    discard = r;
  else
    // We can detect the end of the chain here.
    // We will detect the beginning during statement linkage.
    if ( not_empty te_lnk )
      te_lnk.last = true;
    end if;
  end if;
end for;
//
// Create the variables and connect them to the V_VAR.
select many v_vars from instances of V_VAR;
for each v_var in v_vars
  create object instance te_var of TE_VAR;
  relate v_var to te_var across R2039;
  if ( "self" == T::l(s:v_var.Name) )
    te_var.OAL = "self";
    te_var.buffer = te_instance.self;
  else
    te_var.OAL = v_var.Name;
    te_var.buffer = T::underscore(s:v_var.Name);
    if ( "C++" == te_target.language )
      // This prepends characters to transients in case the modeler used a C keyword.
      te_var.buffer = "v_" + te_var.buffer;
    end if;
  end if;
  array_spec = "";
  select many s_dims related by v_var->S_DIM[R849];
  te_var.dimensions = cardinality s_dims;
  te_dim = empty_te_dim;
  dim_index = 0;
  while ( dim_index < te_var.dimensions )
    select any s_dim related by v_var->S_DIM[R849] where ( selected.dimensionCount == dim_index );
    r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
    te_dim = r;
    if ( dim_index == 0 )
      relate te_dim to te_var across R2057;
    end if;
    array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    dim_index = dim_index + 1;
  end while;
  te_var.array_spec = array_spec;
  select one te_dt related by v_var->S_DT[R848]->TE_DT[R2021];
  if ( not_empty te_dt )
    // In the C model compiler, treat strings as arrays.
    if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
      // string
      te_var.dimensions = te_var.dimensions + 1;
      te_var.array_spec = ( te_var.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  else
    msg = ( "\nERROR:  Did not find a datatype associated with variable " + v_var.Name ) + ".\n";
    msg = msg + "Check usages of variable for parse errors in the action language.\n";
    msg = msg + "[Parse All Activities and look for errors in the Problems view.]\n";
    T::print(s:"${msg}");
  end if;
end for;
//
//
//
// Continue initializing the components created and linked above.
// Recurse down into the component-level artifacts.
select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Initialize the te_sync instances.
  select many te_syncs related by te_c->TE_SYNC[R2084];
  r = ::sync_sort( te_syncs:te_syncs );
  te_sync = r;
  if ( not_empty te_sync )
    relate te_c to te_sync across R2097;
  end if;
  for each te_sync in te_syncs
    select one s_sync related by te_sync->S_SYNC[R2023];
    te_sync.IsInitFunction = false;
    te_sync.IsSafeForInterrupts = false;
    te_sync.XlateSemantics = true;
    te_sync.deferred_method = te_sync.GeneratedName + "_deferred";
    select any tm_sync from instances of TM_SYNC where ( ( selected.RegisteredDomain == te_c.Name ) and ( selected.Name == te_sync.Name ) );
    if ( not_empty tm_sync )
      te_sync.IsSafeForInterrupts = tm_sync.IsSafeForInterrupts;
      select one rval_dt related by s_sync->S_DT[R25];
      if ( rval_dt.Name != "void" )
        T::print(s:"ERROR:  Function ${te_sync.Name} in ${te_c.Name}");
        T::print(s:"is trying to return data.  Functions marked as safe for");
        T::print(s:"interrupt invocation cannot return data.  They must be");
        T::print(s:"of return type void.");
        T::print(s:"Change the return type of the function or do not mark");
        T::print(s:"it as SafeForInterrupts.");
        T::exit(i:100);
      end if;
    end if;
    if ( te_sync.IsSafeForInterrupts )
      te_sync.intraface_method = te_sync.GeneratedName + "_sync";
    else
      te_sync.intraface_method = te_sync.GeneratedName;
    end if;
    select one te_dt related by s_sync->S_DT[R25]->TE_DT[R2021];
    select many te_parms related by s_sync->S_SPARM[R24]->TE_PARM[R2030];
    r1 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_c.Name, name:te_sync.GeneratedName, subtypeKL:"S_SYNC", te_dt:te_dt );
    te_aba = r1;
    relate te_sync to te_aba across R2010;
    select one te_blk related by s_sync->ACT_FNB[R695]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    if ( not_empty te_blk )
      relate te_blk to te_aba across R2011;
    end if;
  end for;
  //
  // Create the Generated External Entity instances and link them in.
  select many te_ees related by te_c->TE_EE[R2085];
  for each te_ee in te_ees
    ::TE_EE_init( te_ee:te_ee, te_c:te_c );
  end for;
  r1 = ::ee_sort( te_ees:te_ees );
  te_ee = r1;
  if ( not_empty te_ee )
    relate te_c to te_ee across R2098;
  end if;
  //
  select many te_macts related by te_c->TE_MACT[R2002];
  for each te_mact in te_macts
    select one te_aba related by te_mact->TE_ABA[R2010];
    select any te_blk from instances of TE_BLK where ( false );
    if ( "SPR_PO" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_PO[R2050]->ACT_POB[R687]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_RO" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_RO[R2052]->ACT_ROB[R685]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_PS" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_PS[R2051]->ACT_PSB[R686]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_RS" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_RS[R2053]->ACT_RSB[R684]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    end if;
    if ( not_empty te_blk )
      relate te_blk to te_aba across R2011;
    end if;
  end for;
  //
  // Initialize the Generated Class instances.
  select many te_classs related by te_c->TE_CLASS[R2064];
  for each te_class in te_classs
    select one o_obj related by te_class->O_OBJ[R2019];
    // Initialize model compiler extension attributes.
    te_class.SelfCreated = false;
    te_class.NonSelfCreated = false;
    te_class.Included = false;
    te_class.IsFixedPopulation = false;
    te_class.PEIsDefinedInData = false;
    te_class.IsReadOnly = false;
    // Default is 10 instances per class.
    te_class.MaxExtentSize = 10;
    te_class.Persistent = false;
    te_class.ExcludeFromGen = false;
    te_class.IsTrace = true;
    te_class.ContainerIndex = 0;
    te_class.Task = 0;
    te_class.class_file = te_class.GeneratedName + "_class";
    te_class.system_class_number = te_class.GeneratedName + "_CLASS_NUMBER";
    te_class.CBsystem_class_number = te_class.GeneratedName + "_CLASS_NUMBER_CB";
    te_class.dispatcher = "";
    te_class.CBdispatcher = "";
    select one sm_ism related by o_obj->SM_ISM[R518];
    if ( not_empty sm_ism )
      te_class.dispatcher = te_class.GeneratedName + "_Dispatch";
    end if;
    select one sm_asm related by o_obj->SM_ASM[R519];
    if ( not_empty sm_asm )
      te_class.CBdispatcher = te_class.GeneratedName + "_CBDispatch";
    end if;
    te_class.persist_link = te_class.GeneratedName + "_LinkCentral";
    //
    // Create the Generated Attribute instances and link them to the real ones.
    delimiter = "";
    prev_te_attr = empty_te_attr;
    // Find first o_attr.
    select any o_attr related by o_obj->O_ATTR[R102];
    while ( not_empty o_attr )
      select one prev_o_attr related by o_attr->O_ATTR[R103.'succeeds'];
      if ( empty prev_o_attr )
        break;
      end if;
      o_attr = prev_o_attr;
    end while;
    while ( not_empty o_attr )
      create object instance te_attr of TE_ATTR;
      te_attr.Name = o_attr.Name;
      te_attr.GeneratedName = T::r(s:o_attr.Name);
      te_attr.DefaultValue = o_attr.DefaultValue;
      te_attr.Used = false;
      te_attr.read = false;
      te_attr.written = false;
      te_attr.Included = false;
      te_attr.Order = 0;
      te_attr.ParamBuffer = "";
      te_attr.translate = true;
      relate te_attr to o_attr across R2033;
      relate te_attr to te_class across R2061;
            if ( not_empty prev_te_attr )
        relate prev_te_attr to te_attr across R2087.'precedes';
      end if;
      select many s_dims related by o_attr->S_DIM[R120];
      array_spec = "";
      te_attr.dimensions = cardinality s_dims;
      te_dim = empty_te_dim;
      dim_index = 0;
      while ( dim_index < te_attr.dimensions )
        select any s_dim related by o_attr->S_DIM[R120] where ( selected.dimensionCount == dim_index );
        r2 = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
        te_dim = r2;
        if ( dim_index == 0 )
          relate te_dim to te_attr across R2055;
        end if;
        array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
        dim_index = dim_index + 1;
      end while;
      te_attr.array_spec = array_spec;
      select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
      // Potentially substitute data type for base attribute data type.
      if ( 7 == te_dt.Core_Typ )
        // referential attribute
        r2 = ::GetAttributeCodeGenType( o_attr:o_attr );
        te_dt = r2;
      end if;
      te_attr.GeneratedType = te_dt.ExtName;
      o_attr_Descrip_Persistent = T::parsekeyword(s:o_attr.Descrip,key:"Persistent");
      if ( o_attr_Descrip_Persistent != "false" )
        if ( "%p" == te_dt.string_format )
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + "%ld";
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    ((long)self->" ) + ( te_attr.GeneratedName + " & ESCHER_IDDUMP_MASK)" );
        elif ( "%s" == te_dt.string_format )
          // Place an escaped tick mark around the %s in the attribute format string.
          te_class.attribute_format = ( ( te_class.attribute_format + delimiter ) + ( "'" + te_dt.string_format ) ) + "'";
          te_class.attribute_dump = ( ( ( te_class.attribute_dump + ",\n    ( 0 != self->" ) + ( te_attr.GeneratedName + " ) ? self->" ) ) + ( ( te_attr.GeneratedName + " : """ ) + """" ) );
        else
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + te_dt.string_format;
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    self->" ) + te_attr.GeneratedName;
        end if;
      end if;
      // In the C model compiler, treat strings as arrays.
      if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
        // string
        te_attr.dimensions = te_attr.dimensions + 1;
        te_attr.array_spec = ( te_attr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
      end if;
      //
      // Create the Action Block Anchors associated with each action
      // in the user model.  Initialize and link them.
      // Create and link the Generated versions of each of the action homes.
      select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
      if ( not_empty o_dbattr )
        create object instance te_dbattr of TE_DBATTR;
        te_dbattr.Included = false;
        te_dbattr.GeneratedName = ( te_class.GeneratedName + "_MDA_" ) + o_attr.Name;
        relate o_dbattr to te_dbattr across R2026;
        select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
        te_parms = empty_te_parms;
        r2 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:"", name:te_dbattr.GeneratedName, subtypeKL:"O_DBATTR", te_dt:te_dt );
        te_aba = r2;
        relate te_dbattr to te_aba across R2010;
        select one te_blk related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
        if ( not_empty te_blk )
          relate te_blk to te_aba across R2011;
        end if;
      end if;
      delimiter = ",";
      prev_te_attr = te_attr;
      select one o_attr related by o_attr->O_ATTR[R103.'precedes'];
    end while;
    //
    // Create the Generated State Machines and connect them to SM_SM.
    select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:true, sm_sm:sm_sm, te_class:te_class );
    end if;
    select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:false, sm_sm:sm_sm, te_class:te_class );
    end if;
    //
    // Create and relate the generated class operations.
    select many o_tfrs related by o_obj->O_TFR[R115];
    for each o_tfr in o_tfrs
      create object instance te_tfr of TE_TFR;
      te_tfr.Included = false;
      te_tfr.XlateSemantics = true;
      ib = Scope::Instance;
      if ( ib == o_tfr.Instance_Based )
        te_tfr.Instance_Based = 1;
      else
        te_tfr.Instance_Based = 0;
      end if;
      te_tfr.Key_Lett = te_class.Key_Lett;
      te_tfr.Name = o_tfr.Name;
      te_tfr.GeneratedName = ( ( te_c.Name + "_" ) + ( te_tfr.Key_Lett + "_op_" ) ) + te_tfr.Name;
      relate o_tfr to te_tfr across R2024;
      select one te_dt related by o_tfr->S_DT[R116]->TE_DT[R2021];
      select many te_parms related by o_tfr->O_TPARM[R117]->TE_PARM[R2029];
      r2 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_class.GeneratedName, name:te_tfr.GeneratedName, subtypeKL:"O_TFR", te_dt:te_dt );
      te_aba = r2;
      relate te_tfr to te_aba across R2010;
      select one te_blk related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
      if ( not_empty te_blk )
        relate te_blk to te_aba across R2011;
      end if;
    end for;
    //
    // Create the WhereKey instance connected to O_ID.
    select many o_ids related by o_obj->O_ID[R104];
    for each o_id in o_ids
      create object instance te_where of TE_WHERE;
      te_where.WhereKey = false;
      relate te_where to o_id across R2032;
      number = te_where.Oid_ID + 1;
      te_where.select_any_where = ( te_class.GeneratedName + "_AnyWhere" ) + T::s(i:number);
    end for;
  end for;
end for;
//
select many te_ees from instances of TE_EE;
for each te_ee in te_ees
  select one te_c related by te_ee->TE_C[R2085];
  if ( empty te_c )
    ::TE_EE_init( te_ee:te_ee, te_c:empty_te_c );
  end if;
end for;
//
@@@
FactoryTE_CLASS@inst_ref<Extended Class>@@o_obj@inst_ref<Model Class>@@te_c@inst_ref<Extended Component>@@@
//
//
//============================================================================
// New and return instance of TE_CLASS.
//============================================================================
o_obj = param.o_obj;
te_c = param.te_c;
// Create the Generated Class instance and link it to the model one.
create object instance te_class of TE_CLASS;
relate te_class to o_obj across R2019;
relate te_class to te_c across R2064;
// Copy the Numb attribute for sorting purposes.
te_class.Numb = o_obj.Numb;
// Copy other attributes for convenience so we can avoid accessing o_obj.
te_class.Name = o_obj.Name;
te_class.Key_Lett = o_obj.Key_Lett;
te_class.Key_Lett = T::r(s:te_class.Key_Lett);
// Initialize model compiler extension attributes.
te_class.GeneratedName = ( te_c.Name + "_" ) + te_class.Key_Lett;
te_class.CBGeneratedName = te_class.GeneratedName + "_CB";
te_class.scope = "";
te_class.attribute_format = "";
return te_class;
@@@
FactoryTE_DIM@inst_ref<Extended Dimension>@@s_dim@inst_ref<Dimensions>@@predecessor_te_dim@inst_ref<Extended Dimension>@@@
//
//
//============================================================================
// New and return instance of TE_DIM.
//============================================================================
s_dim = param.s_dim;
predecessor_te_dim = param.predecessor_te_dim;
create object instance te_dim of TE_DIM;
te_dim.elementCount = s_dim.elementCount;
if ( 0 == te_dim.elementCount )
  // Here we have a VLA (variable length array).
  // Add support here.
end if;
te_dim.dimensionCount = s_dim.dimensionCount;
if ( not_empty predecessor_te_dim )
  relate te_dim to predecessor_te_dim across R2060.'succeeds';
end if;
return te_dim;
@@@
FactoryTE_SM@inst_ref<Extended State Machine>@@is_ism@boolean@@sm_sm@inst_ref<State Machine>@@te_class@inst_ref<Extended Class>@@@
//
//
//============================================================================
// New and link state machine instances.
// Allocate and link state instances (in numerically sorted order).
//============================================================================
is_ism = param.is_ism;
sm_sm = param.sm_sm;
te_class = param.te_class;
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
select many empty_te_parms from instances of TE_PARM where ( false );
select one te_c related by te_class->TE_C[R2064];
create object instance te_sm of TE_SM;
relate te_sm to te_class across R2072;
relate te_sm to sm_sm across R2043;
te_sm.complete = false;
class_based = "_CB";
if ( is_ism )
  class_based = "";
end if;
te_sm.SEMname = ( te_class.GeneratedName + class_based ) + "_StateEventMatrix";
te_sm.state_names_array = ( "state_name_strings" + class_based );
te_sm.action_array = ( te_class.GeneratedName + class_based ) + "_acts";
te_sm.txn_action_array = ( te_class.GeneratedName + class_based ) + "_xacts";
te_sm.action_type = "StateAction_t";
te_sm.events_union = ( te_class.GeneratedName + class_based ) + "_Events_u";
//
// Create the Generated States and connect them to SM_STATE.
select many sm_states related by sm_sm->SM_STATE[R501];
te_sm.num_states = cardinality sm_states;
for each sm_state in sm_states
  create object instance te_state of TE_STATE;
  te_state.Name = sm_state.Name;
  te_state.Numb = sm_state.Numb;
  relate te_state to sm_state across R2037;
  te_state.enumerator = ( te_class.GeneratedName + class_based ) + ( "_STATE_" + T::s(i:te_state.Numb) );
  //
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_act" + T::s(i:te_state.Numb) );
  //.select many te_parms related by sm_state->SM_SEME[R503]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  select one te_blk related by sm_act->ACT_SAB[R691]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
end for;
//
// Sort the states for later state event matrix generation.
select many te_states related by sm_states->TE_STATE[R2037];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set = te_states;
//
// Clear the Order attribute of all set members.
for each item in item_set
  item.Order = 0;
end for;
// simple pseudo bubble sort
item_set_copy = item_set;
for each item in item_set
  for each item_copy in item_set_copy
    if ( item_copy.Numb > item.Numb )
      item_copy.Order = item_copy.Order + 1;
    end if;
  end for;
end for;
for each te_state in te_states
  te_state.number = te_state.Order + 1;
  if ( 0 == te_state.Order )
    te_sm.initial_state = te_state.enumerator;
  end if;
end for;
//
// Create the actions for the transitions.
counter = 1;
// This is the hairiest traversal we do.  We are finding actions
// that actually have action language.
select many sm_acts related by sm_sm->SM_TXN[R505]->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514]->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602]->ACT_BLK[R602]->ACT_ACT[R666]->ACT_TAB[R698]->SM_ACT[R688];
for each sm_act in sm_acts
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  select one sm_state related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_STATE[R506];
  te_act.GeneratedName = ( ( te_class.GeneratedName + class_based ) + ( "_xact_to_" + T::s(i:sm_state.Numb) ) ) + ( "_" + T::s(i:counter) );
  te_act.number = counter;
  //.select many te_parms related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  select one te_blk related by sm_act->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
  counter = counter + 1;
end for;
te_sm.txn_action_count = counter - 1;
//
// Create the Generated Events and connect them to SM_EVT.
select many sm_evts related by sm_sm->SM_EVT[R502];
te_sm.num_events = cardinality sm_evts;
for each sm_evt in sm_evts
  create object instance te_evt of TE_EVT;
  relate te_evt to te_sm across R2071;
  te_evt.Name = sm_evt.Mning;
  te_evt.Numb = sm_evt.Numb;
  te_evt.Order = 0;
  te_evt.Used = false;
  te_evt.UsedCount = 0;
  te_evt.Priority = 0;
  relate te_evt to sm_evt across R2036;
  suffix = T::s(i:te_evt.Numb);
  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    // Non local event defined by a polymorphic event
    select one super_sm_evt related by sm_nlevt->SM_PEVT[R527]->SM_EVT[R525];
    select one super_obj related by super_sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    suffix = ( "_" + T::r(s:super_obj.Key_Lett) ) + ( "_PE" + T::s(i:super_sm_evt.Numb) );
  end if;
  te_evt.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "event" + suffix );
  te_evt.Enumerator = T::u(s:te_evt.GeneratedName) + "NUM";
end for;
// Select the local events (only in this state machine), the "true" events
// (land here but also seen as polys) and polymorphic events.  Order the
// events starting with local then true then polys.
select many sm_levts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526];
select many local_te_evts related by sm_levts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set1 = local_te_evts;
//
// Clear the Order attribute of all set members.
for each item1 in item_set1
  item1.Order = 0;
end for;
// simple pseudo bubble sort
item_set1_copy = item_set1;
for each item1 in item_set1
  for each item1_copy in item_set1_copy
    if ( item1_copy.Numb > item1.Numb )
      item1_copy.Order = item1_copy.Order + 1;
    end if;
  end for;
end for;
last_event_number = cardinality local_te_evts;
last_event_number = last_event_number - 1;
select many sm_sgevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_SGEVT[R526];
select many signal_te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in signal_te_evts
  // Mark signals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
  // Link each signal te_mact to its associated signal te_evts.
  select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_PS[R528]->TE_MACT[R2051];
  if ( empty te_mact )
    select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_RS[R529]->TE_MACT[R2053];
  end if;
  if ( not_empty te_mact )
    relate te_mact to te_evt across R2082;
  end if;
end for;
select many sm_nlevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
select many true_te_evts related by sm_nlevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in true_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
// Finally, order the polymorphic events.
// We need their Order to be greater than local and true events, since
// polys are not state event matrix events.
select many poly_te_evts related by sm_sm->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in poly_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
@@@
FactoryTE_MACT@inst_ref<Extended Message Action>@@te_parms@inst_ref_set<Extended Parameter>@@te_dt@inst_ref<Extended Data Type>@@te_c@inst_ref<Extended Component>@@te_po@inst_ref<Extended Port>@@message_name@string@@subtypeKL@string@@@
//
//
//============================================================================
// New and link message actions.
//============================================================================
te_parms = param.te_parms;
te_dt = param.te_dt;
te_c = param.te_c;
te_po = param.te_po;
message_name = param.message_name;
subtypeKL = param.subtypeKL;
select any te_file from instances of TE_FILE;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
create object instance te_mact of TE_MACT;
relate te_mact to te_c across R2002;
relate te_mact to te_po across R2006;
// We cannot just look to see if this port is polymorphic, we have to go to the
// associated interface and see if any port tied to that interface is polymorphic.
// TODO - We would like to move this -up- and handle it when the ports are created,
//   perhaps use 2081 for the satisfaction.
select one c_i related by te_po->C_I[R2007];
select any te_po_poly related by c_i->TE_PO[R2007] where ( ( selected.Provision == te_po.Provision ) and selected.polymorphic );
if ( empty te_po_poly )
  te_mact.polymorphic = false;
else
  te_mact.polymorphic = true;
end if;
te_mact.subtypeKL = subtypeKL;
te_mact.Provision = te_po.Provision;
te_mact.MessageName = message_name;
te_mact.InterfaceName = te_po.InterfaceName;
te_mact.PortName = te_po.GeneratedName;
te_mact.ComponentName = te_c.Name;
te_mact.GeneratedName = ( ( te_mact.ComponentName + "_" ) + ( te_mact.PortName + "_" ) ) + message_name;
if ( "C++" == te_target.language )
  te_mact.GeneratedName = ( te_mact.InterfaceName + "_" ) + message_name;
end if;
te_mact.GeneratedName = T::r(s:te_mact.GeneratedName);
te_mact.Name = te_mact.GeneratedName;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
if ( ( "SystemC" == te_thread.flavor ) and ( te_sys.SystemCPortsType == "TLM" ) )
  for each te_parm in te_parms
    // If we are using TLM ports, convert booleans to integers
    select one param_te_dt related by te_parm->TE_DT[R2049];
    if ( 1 == param_te_dt.Core_Typ )
      relate te_parm to converted_bool_te_dt across R2049;
    end if;
  end for;
end if;
if ( ( te_mact.polymorphic ) and ( "SystemC" == te_thread.flavor ) )
  // If polymorphic, then add a parameter that we can use to distinguish 
  // which port the message came in through.
  select many s_dims from instances of S_DIM where ( false );
  select any portindex_te_dt from instances of TE_DT where ( selected.Name == "integer" );
  r1 = ::FactoryTE_PARM( s_dims:s_dims, te_dt:portindex_te_dt, prefix:"", name:"A00portindex", by_ref:0 );
  polymorphic_te_parm = r1;
  polymorphic_te_parm.Descrip = "architectural port selector";
  for each te_parm in te_parms
    if ( 0 == te_parm.Order )
      relate polymorphic_te_parm to te_parm across R2041.'precedes';
    end if;
  end for;
  te_parms = te_parms;
end if;
r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_mact.ComponentName, name:te_mact.GeneratedName, subtypeKL:"TE_MACT", te_dt:te_dt );
te_aba = r;
relate te_mact to te_aba across R2010;
return te_mact;
@@@
TE_EE_init@void@@te_ee@inst_ref<Extended External Entity>@@te_c@inst_ref<Extended Component>@@@
//
//============================================================================
// Initialize instance of TE_EE.
//============================================================================
te_ee = param.te_ee;
te_c = param.te_c;
select any te_file from instances of TE_FILE;
select any te_target from instances of TE_TARGET;
component_scope = "";
if ( not_empty te_c )
  component_scope = te_c.Name + "_";
end if;
select one s_ee related by te_ee->S_EE[R2020];
// Default the registered name to be the key letters.
// Bridge wiring will override this default, but the default may
// allow the code to compile.
te_ee.Name = s_ee.Name;
te_ee.Descrip = s_ee.Descrip;
te_ee.Key_Lett = s_ee.Key_Lett;
te_ee.RegisteredName = component_scope + T::r(s:te_ee.Key_Lett);
te_ee.Included = false;
te_ee.Used = false;
te_ee.file = te_ee.RegisteredName + "_bridge";
// Leave alone if marked.
if ( "" == te_ee.Include_File )
  te_ee.Include_File = te_ee.file + ( "." + te_file.hdr_file_ext );
end if;
if ( "TIM" == s_ee.Key_Lett )
  // Time (TIM) EE
  te_ee.RegisteredName = "TIM";
  te_ee.Include_File = te_file.tim + ( "." + te_file.hdr_file_ext );
end if;
bridge_scope = "";
if ( "C" == te_target.language )
  bridge_scope = te_ee.RegisteredName + "_";
end if;
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  create object instance te_brg of TE_BRG;
  relate te_brg to s_brg across R2025;
  relate te_brg to te_ee across R2089;
  te_brg.EEkeyletters = s_ee.Key_Lett;
  te_brg.EEname = s_ee.Name;
  te_brg.Name = s_brg.Name;
  te_brg.GeneratedName = bridge_scope + s_brg.Name;
  select one te_dt related by s_brg->S_DT[R20]->TE_DT[R2021];
  select many te_parms related by s_brg->S_BPARM[R21]->TE_PARM[R2028];
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_ee.RegisteredName, name:te_brg.GeneratedName, subtypeKL:"S_BRG", te_dt:te_dt );
  te_aba = r;
  relate te_brg to te_aba across R2010;
  select one te_blk related by s_brg->ACT_BRB[R697]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
end for;
@@@
FactoryTE_ABA@inst_ref<Action Block Anchor>@@te_c@inst_ref<Extended Component>@@te_parms@inst_ref_set<Extended Parameter>@@scope@string@@name@string@@subtypeKL@string@@te_dt@inst_ref<Extended Data Type>@@@
//
//============================================================================
// New and return instance of TE_ABA.
//============================================================================
te_c = param.te_c;
te_parms = param.te_parms;
scope = param.scope;
name = param.name;
subtypeKL = param.subtypeKL;
te_dt = param.te_dt;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
create object instance te_aba of TE_ABA;
te_aba.SelfEventCount = 0;
te_aba.NonSelfEventCount = 0;
te_aba.subtypeKL = subtypeKL;
if ( not_empty te_c )
  relate te_aba to te_c across R2088;
end if;
duplicates_needed = false;
select any te_parm from instances of TE_PARM where ( false );
for each te_parm in te_parms
  select one existing_te_aba related by te_parm->TE_ABA[R2062];
  if ( empty existing_te_aba )
    relate te_parm to te_aba across R2062;
  else
    duplicates_needed = true;
  end if;
end for;
first_te_parm = te_parm;
if ( duplicates_needed or ( ( "c_t" == te_dt.ExtName ) or ( "c_t *" == te_dt.ExtName ) ) )
  // Find first te_parm.
  while ( not_empty te_parm )
    select one prev_te_parm related by te_parm->TE_PARM[R2041.'succeeds'];
    if ( empty prev_te_parm )
      first_te_parm = te_parm;
      break;
    else
      te_parm = prev_te_parm;
    end if;
  end while;
end if;
// This duplication is needed because multiple ports can use the same
// interface.  It would be nice to explore a method to avoid duplicating
// the parameter instances.
if ( duplicates_needed )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.'succeeds'] where ( false );
  while ( not_empty te_parm )
    r = ::TE_PARM_duplicate( te_parm:te_parm );
    duplicate_te_parm = r;
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty prev_te_parm )
      relate prev_te_parm to duplicate_te_parm across R2041.'precedes';
    end if;
    prev_te_parm = duplicate_te_parm;
    select one te_parm related by te_parm->TE_PARM[R2041.'precedes'];
  end while;
  select many te_parms related by te_aba->TE_PARM[R2062];
end if;
// Create and insert an architectural parameter for returning a string.
if ( ( "c_t" == te_dt.ExtName ) or ( "c_t *" == te_dt.ExtName ) )
  if ( ( not te_sys.InstanceLoading ) and ( not duplicates_needed ) )
    // mcmc does not return through the by-ref parameter.
    // When duplicating, there is a duplicate by-ref string return parameter.
    select any string_te_parm from instances of TE_PARM where ( selected.Name == "A0xtumlsret" );
    r = ::TE_PARM_duplicate( te_parm:string_te_parm );
    duplicate_te_parm = r;
    duplicate_te_parm.Descrip = "xtuml string return parm";
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty first_te_parm )
      relate duplicate_te_parm to first_te_parm across R2041.'precedes';
    end if;
    select many te_parms related by te_aba->TE_PARM[R2062];
  end if;
end if;
::te_parm_RenderParameters( te_parms:te_parms, te_aba:te_aba );
te_aba.scope = "";
if ( "C++" == te_target.language )
  te_aba.scope = scope + "::";
  if ( not_empty te_c )
    if ( ( "S_BRG" == te_aba.subtypeKL ) or ( "O_TFR" == te_aba.subtypeKL ) )
      if ( empty te_parms )
        te_aba.ParameterDefinition = ( " " + te_c.Name ) + " * thismodule";
        te_aba.ParameterDeclaration = ( " " + te_c.Name ) + " *";
      else
        te_aba.ParameterDefinition = ( ( " " + te_c.Name ) + ( " * thismodule," + te_aba.ParameterDefinition ) );
        te_aba.ParameterDeclaration = ( ( " " + te_c.Name ) + ( " *," + te_aba.ParameterDeclaration ) );
      end if;
    end if;
  end if;
end if;
te_aba.GeneratedName = name;
te_aba.ReturnDataType = te_dt.ExtName;
te_aba.dimensions = 0;
// In the C model compiler, treat strings as arrays.
if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
  // string
  select any te_string from instances of TE_STRING;
  te_aba.dimensions = te_aba.dimensions + 1;
  te_aba.array_spec = ( te_aba.array_spec + "[" ) + ( te_string.max_string_length + "]" );
end if;
// Allow arrays (including strings) to be returned as pointers.
if ( te_aba.dimensions > 0 )
  te_aba.ReturnDataType = te_aba.ReturnDataType + " *";
end if;
return te_aba;
@@@
FactoryTE_PARM@inst_ref<Extended Parameter>@@s_dims@inst_ref_set<Dimensions>@@te_dt@inst_ref<Extended Data Type>@@prefix@string@@name@string@@by_ref@integer@@@
//
//
//============================================================================
// New and link up extended parameter.
//============================================================================
s_dims = param.s_dims;
te_dt = param.te_dt;
prefix = param.prefix;
name = param.name;
by_ref = param.by_ref;
create object instance te_parm of TE_PARM;
te_parm.Order = 0;
te_parm.ParamBuffer = "";
te_parm.OALParamBuffer = "";
te_parm.Name = T::r(s:name);
te_parm.By_Ref = by_ref;
te_parm.GeneratedName = prefix + name;
relate te_parm to te_dt across R2049;
// Set up the array dimensions for the parameter.
te_parm.dimensions = cardinality s_dims;
array_spec = "";
select one te_dim related by te_parm->TE_DIM[R2056] where ( false );
dim_index = 0;
while ( dim_index < te_parm.dimensions )
  for each s_dim in s_dims
    if ( s_dim.dimensionCount == dim_index )
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_parm to te_dim across R2056;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    end if;
  end for;
  dim_index = dim_index + 1;
  te_parm.By_Ref = 0;
end while;
te_parm.array_spec = array_spec;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  select any te_sys from instances of TE_SYS;
  if ( not te_sys.InstanceLoading )
    // string
    select any te_string from instances of TE_STRING;
    te_parm.dimensions = te_parm.dimensions + 1;
    te_parm.array_spec = ( te_parm.array_spec + "[" ) + ( te_string.max_string_length + "]" );
  end if;
  // strings are already by-ref
  te_parm.By_Ref = 0;
end if;
return te_parm;
@@@
TE_PARM_duplicate@inst_ref<Extended Parameter>@@te_parm@inst_ref<Extended Parameter>@@@
//
//============================================================================
// Duplicate (copy) an instance of TE_PARM.
//============================================================================
te_parm = param.te_parm;
create object instance duplicate_te_parm of TE_PARM;
duplicate_te_parm.Order = te_parm.Order;
duplicate_te_parm.ParamBuffer = te_parm.ParamBuffer;
duplicate_te_parm.OALParamBuffer = te_parm.OALParamBuffer;
duplicate_te_parm.Name = te_parm.Name;
duplicate_te_parm.Descrip = te_parm.Descrip;
duplicate_te_parm.By_Ref = te_parm.By_Ref;
duplicate_te_parm.GeneratedName = te_parm.GeneratedName;
select one te_dt related by te_parm->TE_DT[R2049];
relate duplicate_te_parm to te_dt across R2049;
duplicate_te_parm.dimensions = te_parm.dimensions;
select one te_dim related by te_parm->TE_DIM[R2056];
if ( not_empty te_dim )
  relate duplicate_te_parm to te_dim across R2056;
else
  end if;
duplicate_te_parm.array_spec = te_parm.array_spec;
return duplicate_te_parm;
@@@
FactoryTE_LNK@void@@act_lnk@inst_ref<Chain Link>@@@
//
//============================================================================
// New and return instance of TE_LNK.
//============================================================================
act_lnk = param.act_lnk;
select one o_obj related by act_lnk->O_OBJ[R678];
select one te_class related by o_obj->TE_CLASS[R2019];
if ( not_empty te_class )
  create object instance te_lnk of TE_LNK;
  relate te_lnk to act_lnk across R2042;
  te_lnk.rel_phrase = act_lnk.Rel_Phrase;
    select one r_rel related by act_lnk->R_REL[R681];
  te_lnk.rel_number = r_rel.Numb;
  relate te_lnk to te_class across R2076;
  te_lnk.OAL = ( ( "->" + te_class.Key_Lett ) + ( "[R" + T::s(i:te_lnk.rel_number) ) );
  if ( "" != te_lnk.rel_phrase )
    te_lnk.OAL = ( te_lnk.OAL + "." ) + te_lnk.rel_phrase;
  end if;
  te_lnk.OAL = te_lnk.OAL + "]";
  te_lnk.first = false;
  te_lnk.last = false;
  rel_phrase = T::underscore(s:te_lnk.rel_phrase);
  select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( ( selected.Obj_ID == o_obj.Obj_ID ) and ( selected.rel_phrase == rel_phrase ) );
  if ( empty te_oir )
    select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( selected.Obj_ID == o_obj.Obj_ID );
  end if;
  te_lnk.linkage = te_oir.data_member;
  te_lnk.Mult = te_oir.Mult;
  te_lnk.assoc_type = te_oir.assoc_type;
  // Deal with associative reflexives.
  if ( "assr" == te_oir.assoc_type )
    r = ::is_reflexive( r_rel:r_rel );
    reflexive = r;
    if ( reflexive )
      select one r_aone related by r_rel->R_ASSOC[R206]->R_AONE[R209];
      select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
      if ( te_lnk.rel_phrase == r_aone.Txt_Phrs )
        te_lnk.Mult = r_aone.Mult;
      elif ( te_lnk.rel_phrase == r_aoth.Txt_Phrs )
        te_lnk.Mult = r_aoth.Mult;
      else
        T::print(s:"ERROR:  Unrecognized reflexive association:  R$t{r_rel.Numb}.");
        T::exit(i:13);
      end if;
      te_lnk.linkage = ( te_oir.data_member + "_" ) + rel_phrase;
    end if;
  end if;
  te_lnk.iterator = "i" + te_lnk.linkage;
end if;
@@@
associator_TE_LNK@inst_ref<Extended Chain Link>@@left_te_lnk@inst_ref<Extended Chain Link>@@right_te_lnk@inst_ref<Extended Chain Link>@@@
//
//============================================================================
// Create and insert a new TE_LNK between these two (for associator).
//============================================================================
left_te_lnk = param.left_te_lnk;
right_te_lnk = param.right_te_lnk;
create object instance te_lnk of TE_LNK;
te_lnk.rel_phrase = "";
// Insert the new link in between the left and right TE_LNKs.
relate te_lnk to right_te_lnk across R2075.'precedes';
select one r_rel related by right_te_lnk->ACT_LNK[R2042]->R_REL[R681];
te_lnk.rel_number = right_te_lnk.rel_number;
select one te_class related by r_rel->R_ASSOC[R206]->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->TE_CLASS[R2019];
relate te_lnk to te_class across R2076;
// Leave OAL blank, because real OAL is not showing this link.
te_lnk.OAL = "";
select any te_oir related by r_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->TE_OIR[R2035];
te_lnk.linkage = te_oir.data_member;
te_lnk.Mult = te_oir.Mult;
te_lnk.assoc_type = te_oir.assoc_type;
// Reflexive associatives put the relationship phrase onto the AONE/AOTH data members.
if ( "" != right_te_lnk.rel_phrase )
  te_lnk.linkage = ( te_lnk.linkage + "_" ) + T::underscore(s:right_te_lnk.rel_phrase);
end if;
if ( not_empty left_te_lnk )
  relate left_te_lnk to te_lnk across R2075.'precedes';
  te_lnk.left = left_te_lnk.linkage;
  te_lnk.first = false;
else
  te_lnk.left = te_lnk.linkage;
  te_lnk.first = true;
end if;
te_lnk.last = false;
te_lnk.iterator = "i" + te_lnk.linkage;
te_lnk.Mult = right_te_lnk.Mult;
right_te_lnk.Mult = 0;
right_te_lnk.left = te_lnk.linkage;
return te_lnk;
@@@
detect_and_insert_associator_TE_LNK@inst_ref<Extended Chain Link>@@te_lnk@inst_ref<Extended Chain Link>@@next_te_lnk@inst_ref<Extended Chain Link>@@act_lnk@inst_ref<Chain Link>@@next_act_lnk@inst_ref<Chain Link>@@start_o_obj@inst_ref<Model Class>@@@
//
//============================================================================
// Detect and insert an associator TE_LNK if needed and adjust the te_lnk
// attributes according to the flavor of associative traversal.
// Accept a pair of te_lnk instances or a start_o_obj and one next_te_lnk.
//============================================================================
te_lnk = param.te_lnk;
next_te_lnk = param.next_te_lnk;
act_lnk = param.act_lnk;
next_act_lnk = param.next_act_lnk;
start_o_obj = param.start_o_obj;
if ( not_empty te_lnk )
  select one start_o_obj related by act_lnk->O_OBJ[R678];
end if;
if ( "aone" == next_te_lnk.assoc_type )
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> aone
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aone
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "aoth" == next_te_lnk.assoc_type )
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  if ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> aoth
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aoth
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "assr" == next_te_lnk.assoc_type )
  // For an associator, the multiplicity is that of the far side.
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( r_aone.Obj_ID == r_aoth.Obj_ID )
    // reflexive associative going from aone/aoth to assr
    if ( r_aone.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aone.Mult;
    elif ( r_aoth.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aoth.Mult;
    else
      T::print(s:"Invalid associative reflexive traversal from ${start_o_obj.Name}/${start_o_obj.Key_Lett} to ${next_te_lnk.te_classGeneratedName}.");
      T::exit(i:100);
    end if;
  elif ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> assr
    next_te_lnk.Mult = r_aoth.Mult;
  elif ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> assr
    next_te_lnk.Mult = r_aone.Mult;
  else
    T::print(s:"Invalid associative reflexive traversal from ${start_o_obj.Name}/${start_o_obj.Key_Lett} to ${next_te_lnk.te_classGeneratedName}.");
    T::exit(i:100);
  end if;
end if;
return te_lnk;
@@@
TE_C_mark_nested_system@void@@te_cs@inst_ref_set<Extended Component>@@@
//
// Recursive call to drill down and get all of the nested components and
// component references.
te_cs = param.te_cs;
for each te_c in te_cs
  te_c.included_in_build = true;
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
end for;
@@@
TE_C_getContainingComponent@inst_ref<Extended Component>@@ep_pkg@inst_ref<Package>@@@
//
// Recursively search upwards through the package hierarchy to find the
// containing (parent/owning) component.
ep_pkg = param.ep_pkg;
select any te_c from instances of TE_C where ( false );
// Return empty te_c for a top-level package with no containing package or component.
select one s_sys related by ep_pkg->S_SYS[R1401];
if ( empty s_sys )
  select one te_c related by ep_pkg->PE_PE[R8001]->C_C[R8003]->TE_C[R2054];
  if ( empty te_c )
    select one parent_ep_pkg related by ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
    if ( not_empty parent_ep_pkg )
      r = ::TE_C_getContainingComponent( ep_pkg:parent_ep_pkg );
      te_c = r;
    end if;
  end if;
end if;
return te_c;
@@@
EP_PKG_getContainingPackage@inst_ref<Package>@@c_c@inst_ref<Component>@@@
//
// Recursively search upwards through the component hierarcy to find the
// containing (parent/owning) package.
c_c = param.c_c;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
if ( empty ep_pkg )
  select one c_c related by c_c->PE_PE[R8001]->C_C[R8003];
  r = ::EP_PKG_getContainingPackage( c_c:c_c );
  ep_pkg = r;
end if;
return ep_pkg;
@@@
TE_C_sort@inst_ref<Extended Component>@@te_cs@inst_ref_set<Extended Component>@@@
//
// Sort a list of TE_Cs.
te_cs = param.te_cs;
// Declare an empty instance reference.
select any head_te_c related by te_cs->TE_C[R2017.'precedes'] where ( false );
for each te_c in te_cs
  r = ::TE_C_insert( head_te_c:head_te_c, te_c:te_c );
  head_te_c = r;
end for;
return head_te_c;
@@@
TE_C_insert@inst_ref<Extended Component>@@head_te_c@inst_ref<Extended Component>@@te_c@inst_ref<Extended Component>@@@
head_te_c = param.head_te_c;
te_c = param.te_c;
result = te_c;
if ( empty head_te_c )
  // Just starting.  Return te_c as head.
elif ( te_c.Name <= head_te_c.Name )
  // insert before
  relate te_c to head_te_c across R2017.'precedes';
else
  // find bigger
  result = head_te_c;
  prev_te_c = head_te_c;
  select one cursor_te_c related by head_te_c->TE_C[R2017.'precedes'];
  while ( not_empty cursor_te_c )
    if ( te_c.Name <= cursor_te_c.Name )
      break;
    else
      prev_te_c = cursor_te_c;
      select one cursor_te_c related by cursor_te_c->TE_C[R2017.'precedes'];
    end if;
  end while;
  relate prev_te_c to te_c across R2017.'precedes';
  if ( not_empty cursor_te_c )
    relate te_c to cursor_te_c across R2017.'precedes';
  end if;
end if;
return result;
@@@
class_sort@inst_ref<Extended Class>@@te_classs@inst_ref_set<Extended Class>@@@
//
// Sort a list of TE_CLASSes.
te_classs = param.te_classs;
// Declare an empty instance reference.
select any head_te_class related by te_classs->TE_CLASS[R2092.'precedes'] where ( false );
for each te_class in te_classs
  end for;
for each te_class in te_classs
  r = ::class_insert( head_te_class:head_te_class, te_class:te_class );
  head_te_class = r;
end for;
return head_te_class;
@@@
class_insert@inst_ref<Extended Class>@@head_te_class@inst_ref<Extended Class>@@te_class@inst_ref<Extended Class>@@@
head_te_class = param.head_te_class;
te_class = param.te_class;
result = te_class;
if ( empty head_te_class )
  // Just starting.  Return te_class as head.
else
  lkey = T::s(i:te_class.Numb) + te_class.GeneratedName;
  rkey = T::s(i:head_te_class.Numb) + head_te_class.GeneratedName;
  if ( lkey <= rkey )
    // insert before
    relate te_class to head_te_class across R2092.'precedes';
  else
    // find bigger
    result = head_te_class;
    prev_te_class = head_te_class;
    select one cursor_te_class related by head_te_class->TE_CLASS[R2092.'precedes'];
    while ( not_empty cursor_te_class )
      rkey = T::s(i:cursor_te_class.Numb) + cursor_te_class.GeneratedName;
      if ( lkey <= rkey )
        break;
      else
        prev_te_class = cursor_te_class;
        select one cursor_te_class related by cursor_te_class->TE_CLASS[R2092.'precedes'];
      end if;
    end while;
    relate prev_te_class to te_class across R2092.'precedes';
    if ( not_empty cursor_te_class )
      relate te_class to cursor_te_class across R2092.'precedes';
    end if;
  end if;
end if;
return result;
@@@
mact_sort@inst_ref<Extended Message Action>@@te_macts@inst_ref_set<Extended Message Action>@@@
//
// Sort a list of TE_MACTs.
te_macts = param.te_macts;
// Declare an empty instance reference.
select any head_te_mact related by te_macts->TE_MACT[R2083.'precedes'] where ( false );
for each te_mact in te_macts
  end for;
for each te_mact in te_macts
  r = ::mact_insert( head_te_mact:head_te_mact, te_mact:te_mact );
  head_te_mact = r;
end for;
counter = 0;
te_mact = head_te_mact;
while ( not_empty te_mact )
  te_mact.Order = counter;
  counter = counter + 1;
  select one te_mact related by te_mact->TE_MACT[R2083.'precedes'];
end while;
return head_te_mact;
@@@
mact_insert@inst_ref<Extended Message Action>@@head_te_mact@inst_ref<Extended Message Action>@@te_mact@inst_ref<Extended Message Action>@@@
head_te_mact = param.head_te_mact;
te_mact = param.te_mact;
result = te_mact;
if ( empty head_te_mact )
  // Just starting.  Return te_mact as head.
else
  lkey = te_mact.Name;
  rkey = head_te_mact.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_mact to head_te_mact across R2083.'precedes';
  else
    // find bigger
    result = head_te_mact;
    prev_te_mact = head_te_mact;
    select one cursor_te_mact related by head_te_mact->TE_MACT[R2083.'precedes'];
    while ( not_empty cursor_te_mact )
      rkey = cursor_te_mact.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_mact = cursor_te_mact;
        select one cursor_te_mact related by cursor_te_mact->TE_MACT[R2083.'precedes'];
      end if;
    end while;
    relate prev_te_mact to te_mact across R2083.'precedes';
    if ( not_empty cursor_te_mact )
      relate te_mact to cursor_te_mact across R2083.'precedes';
    end if;
  end if;
end if;
return result;
@@@
sync_sort@inst_ref<Extended Function>@@te_syncs@inst_ref_set<Extended Function>@@@
//
// Sort a list of TE_SYNCs.
te_syncs = param.te_syncs;
// Declare an empty instance reference.
select any head_te_sync related by te_syncs->TE_SYNC[R2095.'precedes'] where ( false );
for each te_sync in te_syncs
  end for;
for each te_sync in te_syncs
  r = ::sync_insert( head_te_sync:head_te_sync, te_sync:te_sync );
  head_te_sync = r;
end for;
return head_te_sync;
@@@
sync_insert@inst_ref<Extended Function>@@head_te_sync@inst_ref<Extended Function>@@te_sync@inst_ref<Extended Function>@@@
head_te_sync = param.head_te_sync;
te_sync = param.te_sync;
result = te_sync;
if ( empty head_te_sync )
  // Just starting.  Return te_sync as head.
else
  lkey = te_sync.Name;
  rkey = head_te_sync.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_sync to head_te_sync across R2095.'precedes';
  else
    // find bigger
    result = head_te_sync;
    prev_te_sync = head_te_sync;
    select one cursor_te_sync related by head_te_sync->TE_SYNC[R2095.'precedes'];
    while ( not_empty cursor_te_sync )
      rkey = cursor_te_sync.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_sync = cursor_te_sync;
        select one cursor_te_sync related by cursor_te_sync->TE_SYNC[R2095.'precedes'];
      end if;
    end while;
    relate prev_te_sync to te_sync across R2095.'precedes';
    if ( not_empty cursor_te_sync )
      relate te_sync to cursor_te_sync across R2095.'precedes';
    end if;
  end if;
end if;
return result;
@@@
ee_sort@inst_ref<Extended External Entity>@@te_ees@inst_ref_set<Extended External Entity>@@@
//
// Sort a list of TE_EEs.
te_ees = param.te_ees;
// Declare an empty instance reference.
select any head_te_ee related by te_ees->TE_EE[R2096.'precedes'] where ( false );
for each te_ee in te_ees
  select one next_te_ee related by te_ee->TE_EE[R2096.'precedes'];
  if ( not_empty next_te_ee )
    unrelate te_ee from te_ee across R2096.'precedes';
  end if;
end for;
for each te_ee in te_ees
  r = ::ee_insert( head_te_ee:head_te_ee, te_ee:te_ee );
  head_te_ee = r;
end for;
return head_te_ee;
@@@
ee_insert@inst_ref<Extended External Entity>@@head_te_ee@inst_ref<Extended External Entity>@@te_ee@inst_ref<Extended External Entity>@@@
head_te_ee = param.head_te_ee;
te_ee = param.te_ee;
result = te_ee;
if ( empty head_te_ee )
  // Just starting.  Return te_ee as head.
else
  lkey = te_ee.Name;
  rkey = head_te_ee.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_ee to head_te_ee across R2096.'precedes';
  else
    // find bigger
    result = head_te_ee;
    prev_te_ee = head_te_ee;
    select one cursor_te_ee related by head_te_ee->TE_EE[R2096.'precedes'];
    while ( not_empty cursor_te_ee )
      rkey = cursor_te_ee.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_ee = cursor_te_ee;
        select one cursor_te_ee related by cursor_te_ee->TE_EE[R2096.'precedes'];
      end if;
    end while;
    relate prev_te_ee to te_ee across R2096.'precedes';
    if ( not_empty cursor_te_ee )
      relate te_ee to cursor_te_ee across R2096.'precedes';
    end if;
  end if;
end if;
return result;
@@@
blk_indentwhitespace@string@@indentation@integer@@@
//
// indentation maker
//
indentation = param.indentation;
result = "";
while ( 0 < indentation )
  indentation = indentation - 1;
  result = result + "  ";
end while;
return result;
@@@
gen_parameter_list@inst_ref<Extended Parameter>@@v_pars@inst_ref_set<Actual Parameter>@@prefix_param_delimiter@boolean@@@
//====================================================================
//
// $RCSfile: q.utils.arc,v $
//
//
//====================================================================
//
v_pars = param.v_pars;
prefix_param_delimiter = param.prefix_param_delimiter;
//
code = "";
OAL = "";
select any te_parm from instances of TE_PARM;
if ( not_empty v_pars )
  select any te_string from instances of TE_STRING;
  item_count = 0;
  lowest_order = 999;
  select many te_pars related by v_pars->TE_PAR[R2063];
  for each te_par in te_pars
    select one te_parm related by te_par->TE_PARM[R2091];
    te_par.Order = te_parm.Order;
    if ( te_par.Order < lowest_order )
      lowest_order = te_par.Order;
    end if;
    item_count = item_count + 1;
  end for;
  item_number = lowest_order;
  param_delimiter = "";
  if ( prefix_param_delimiter )
    param_delimiter = ",";
  end if;
  while ( item_number < ( item_count + lowest_order ) )
    select any te_par related by v_pars->TE_PAR[R2063] where ( selected.Order == item_number );
    select one v_par related by te_par->V_PAR[R2063];
    select one v_val related by v_par->V_VAL[R800];
    select one te_val related by v_val->TE_VAL[R2040];
    OAL = ( OAL + param_delimiter ) + te_val.OAL;
    if ( "" == te_val.buffer )
      ::gen_value( v_val:v_val );
    end if;
    code = code + param_delimiter;
    //
    if ( 0 == te_par.By_Ref )
      code = code + te_val.buffer;
    else
      code = ( ( code + "&(" ) + ( te_val.buffer + ")" ) );
    end if;
    param_delimiter = ", ";
    item_number = item_number + 1;
  end while;
end if;
te_parm.ParamBuffer = code;
te_parm.OALParamBuffer = OAL;
return te_parm;
@@@
is_reflexive@boolean@@r_rel@inst_ref<Association>@@@
//
//====================================================================
//
r_rel = param.r_rel;
//
result = false;
select one r_simp related by r_rel->R_SIMP[R206];
if ( not_empty r_simp )
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any first_r_part related by r_simp->R_PART[R207];
    select any second_r_part related by r_simp->R_PART[R207] where ( selected.OIR_ID != first_r_part.OIR_ID );
    if ( first_r_part.Obj_ID == second_r_part.Obj_ID )
      result = true;
    end if;
  else
    select any r_part related by r_simp->R_PART[R207];
    select one r_form related by r_simp->R_FORM[R208];
    if ( not_empty r_form )
      if ( r_part.Obj_ID == r_form.Obj_ID )
        result = true;
      end if;
    end if;
  end if;
else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];
    if ( r_aone.Obj_ID == r_aoth.Obj_ID )
      result = true;
    end if;
  end if;
end if;
return result;
@@@
t_oal_smt_event_parameters@string@@evt_msg_var@string@@parameter@string@@value@string@@value_type@integer@@ws@string@@@
//------------------------------------------------
// Note the use of p_ here.  It is hard-coded and depends upon
// matching the prefix used in initialization population query.
evt_msg_var = param.evt_msg_var;
parameter = param.parameter;
value = param.value;
value_type = param.value_type;
ws = param.ws;
result = "";
select any te_eq from instances of TE_EQ;
if ( "" == evt_msg_var )
  evt_msg_var = te_eq.event_message_variable;
end if;
if ( 4 == value_type )
  // string
  select any te_string from instances of TE_STRING;
  select any te_instance from instances of TE_INSTANCE;
  result = "${ws}  ${te_instance.module}${te_string.strcpy}( ${evt_msg_var}->p_${parameter}, ${value} );";
else
  result = "${ws}  ${evt_msg_var}->p_${parameter} = ${value};";
end if;
return result;
@@@
container_factory@void@@te_container@inst_ref<container>@@@
//
te_container = param.te_container;
te_container.flavor = "";
@@@
copyright_factory@void@@te_copyright@inst_ref<copyright>@@@
//
//
te_copyright = param.te_copyright;
te_copyright.body = "your copyright statement can go here (from te_copyright.body)";
@@@
dlist_factory@void@@te_dlist@inst_ref<dlist>@@@
//
//
te_dlist = param.te_dlist;
select any te_prefix from instances of TE_PREFIX;
te_dlist.remove_node = te_prefix.result + "SetRemoveDlistNode";
@@@
dma_factory@void@@te_dma@inst_ref<dynamic memory allocation>@@@
//
//
te_dma = param.te_dma;
select any te_prefix from instances of TE_PREFIX;
te_dma.file = "sys_memory";
te_dma.allocate = te_prefix.result + "malloc";
te_dma.release = te_prefix.result + "free";
te_dma.debugging_heap = false;
@@@
eq_factory@void@@te_eq@inst_ref<event queue>@@@
//
//
te_eq = param.te_eq;
select any te_prefix from instances of TE_PREFIX;
te_eq.ignored = "EVENT_IS_IGNORED";
te_eq.cant_happen = "EVENT_CANT_HAPPEN";
te_eq.system_events_union = te_prefix.result + "systemxtUMLevents";
te_eq.system_event_pool = te_prefix.result + "xtUML_event_pool";
te_eq.constant_type = te_prefix.result + "xtUMLEventConstant_t";
te_eq.base_event_type = te_prefix.result + "xtUMLEvent_t";
te_eq.base_variable = "mc_event_base";
te_eq.max_events = te_prefix.define_u + "SYS_MAX_XTUML_EVENTS";
te_eq.max_self_events = te_prefix.define_u + "SYS_MAX_SELF_EVENTS";
te_eq.max_nonself_events = te_prefix.define_u + "SYS_MAX_NONSELF_EVENTS";
te_eq.new = te_prefix.result + "NewxtUMLEvent";
te_eq.allocate = te_prefix.result + "AllocatextUMLEvent";
te_eq.delete = te_prefix.result + "DeletextUMLEvent";
te_eq.modify = te_prefix.result + "ModifyxtUMLEvent";
te_eq.self = te_prefix.result + "SendSelfEvent";
te_eq.non_self = te_prefix.result + "SendEvent";
te_eq.search_and_destroy = te_prefix.result + "EventSearchAndDestroy";
te_eq.run_flag = te_prefix.result + "run_flag";
te_eq.event_message_variable = "e";
te_eq.scope = "";
@@@
extent_factory@void@@te_extent@inst_ref<extent>@@@
//
//
te_extent = param.te_extent;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_typemap from instances of TE_TYPEMAP;
select any te_instance from instances of TE_INSTANCE;
te_extent.sets_type = te_set.base_class;
te_extent.type = te_prefix.result + "Extent_t";
te_extent.active = "active";
te_extent.inactive = "inactive";
te_extent.size_type = te_typemap.object_size_name;
te_extent.istate_type = te_typemap.state_number_name;
te_extent.istate_name = "initial_state";
te_extent.container_type = te_set.element_type + "*";
te_extent.container_name = "container";
te_extent.pool_type = te_instance.handle;
te_extent.pool_name = "pool";
te_extent.population_type = te_typemap.instance_index_name;
te_extent.population_name = "population";
te_extent.rstorsize_type = te_typemap.object_size_name;
te_extent.rstorsize_name = "size_no_rel";
te_extent.linkfunc_name = "link_function";
te_extent.size_name = "size";
@@@
file_factory@void@@te_file@inst_ref<file>@@@
//
//
te_file = param.te_file;
select any te_prefix from instances of TE_PREFIX;
te_file.hdr_file_ext = "h";
te_file.src_file_ext = "c";
te_file.sys_main = te_prefix.file + "sys_main";
te_file.factory = te_prefix.file + "sys_xtuml";
te_file.events = te_prefix.file + "sys_events";
te_file.obj_file_ext = "o";
te_file.nvs = te_prefix.file + "sys_nvs";
te_file.sets = te_prefix.file + "sys_sets";
te_file.types = te_prefix.file + "sys_types";
te_file.thread = te_prefix.file + "sys_thread";
te_file.trace = te_prefix.file + "sys_trace";
te_file.tim = te_prefix.file + "TIM_bridge";
te_file.callout = te_prefix.file + "sys_user_co";
te_file.ilb = te_prefix.file + "sys_ilb";
te_file.persist = te_prefix.file + "sys_persist";
te_file.xtumlload = te_prefix.file + "sys_xtumlload";
te_file.interfaces = te_prefix.file + "sysc_interfaces";
te_file.registers = te_prefix.file + "RegDefs";
te_file.domain_color_path = ".";
te_file.domain_source_path = "_ch";
te_file.domain_include_path = "_ch";
te_file.system_source_path = "_ch";
te_file.system_include_path = "_ch";
te_file.system_color_path = ".";
te_file.system_mark = "system.mark";
te_file.datatype_mark = "datatype.mark";
te_file.event_mark = "event.mark";
te_file.class_mark = "class.mark";
te_file.domain_mark = "domain.mark";
te_file.system_functions_mark = "sys_functions.arc";
te_file.bridge_mark = "bridge.mark";
te_file.nvs_bridge = te_prefix.file + "NVS_bridge";
te_file.arc_path = "mc3020/arc";
te_file.root_path = ".";
@@@
instance_factory@void@@te_instance@inst_ref<instance>@@@
//
//
te_instance = param.te_instance;
select any te_prefix from instances of TE_PREFIX;
te_instance.scope = "";
te_instance.create = te_prefix.result + "CreateInstance";
te_instance.create_persistent = te_prefix.result + "CreatePersistent";
te_instance.delete = te_prefix.result + "DeleteInstance";
te_instance.delete_persistent = te_prefix.result + "DeletePersistent";
te_instance.self = "self";
te_instance.global_self = te_prefix.result + "GetSelf";
te_instance.base = te_prefix.result + "InstanceBase_t";
te_instance.handle = te_prefix.result + "iHandle_t";
te_instance.factory_init = te_prefix.result + "ClassFactoryInit";
te_instance.get_dci = te_prefix.result + "GetDCI";
te_instance.get_event_dispatcher = te_prefix.result + "GetEventDispatcher";
te_instance.get_thread_assignment = te_prefix.result + "GetThreadAssignment";
te_instance.base_class = te_prefix.result + "Object_s";
te_instance.max_extent = te_prefix.define_u + "SYS_MAX_OBJECT_EXTENT";
te_instance.max_association_extent = te_prefix.define_u + "SYS_MAX_ASSOCIATION_EXTENT";
te_instance.max_transient_extent = te_prefix.define_u + "SYS_MAX_TRANSIENT_EXTENT";
te_instance.current_state = "current_state";
te_instance.module = "";
@@@
ilb_factory@void@@te_ilb@inst_ref<interleaved bridge>@@@
//
//
te_ilb = param.te_ilb;
select any te_prefix from instances of TE_PREFIX;
te_ilb.file = "sys_ilb";
te_ilb.interleave_bridge = "InterleaveBridge";
te_ilb.define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGES";
te_ilb.data_define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGE_DATA";
te_ilb.interleave_bridge_done = "InterleaveBridgeDone";
te_ilb.get_data = "GetILBData";
te_ilb.dispatch = "DispatchInterleaveBridge";
@@@
persist_factory@void@@te_persist@inst_ref<persistence>@@@
//
//
te_persist = param.te_persist;
select any te_prefix from instances of TE_PREFIX;
select any te_typemap from instances of TE_TYPEMAP;
te_persist.class_union = "";
te_persist.instance_cache_depth = te_prefix.define_u + "PERSIST_INST_CACHE_DEPTH";
te_persist.check_mark = "check_mark_post";
te_persist.post_link = "";
te_persist.link_type_name = te_prefix.type + "link_t";
te_persist.persist_file = "sys_persist";
te_persist.factory_init = te_prefix.result + "PersistFactoryInit";
te_persist.commit = te_prefix.result + "PersistenceCommit";
te_persist.restore = te_prefix.result + "PersistenceRestore";
te_persist.remove = te_prefix.result + "PersistDelete";
te_persist.link_cache_depth = te_prefix.define_u + "PERSIST_LINK_CACHE_DEPTH";
// Return the name of the extended attribute variable for use by
// the persistent restore operation.  This attribute represents the
// instance index of the class extent at time of persistent stowage
// together with the class number (across domains) of the class.
// Also return the types for this attribute variable.
te_persist.domainnum_name = "domainnum";
te_persist.domainnum_type = te_typemap.domain_number_name;
te_persist.classnum_name = "classnum";
te_persist.classnum_type = te_typemap.object_number_name;
te_persist.index_name = "index";
te_persist.index_type = te_typemap.instance_index_name;
te_persist.instid_type = "InstanceIdentifier_t";
te_persist.instid_name = "instance_identifier";
te_persist.dirty_type = "s1_t";
te_persist.dirty_name = "persist_dirty";
te_persist.dirty_dirty = 1;
te_persist.dirty_clean = 0;
@@@
prefix_factory@void@@te_prefix@inst_ref<prefix>@@@
//
//
te_prefix = param.te_prefix;
te_prefix.symbol = "Escher_";
te_prefix.type = "Escher_";
te_prefix.define_u = "ESCHER_";
te_prefix.define_c = "Escher_";
te_prefix.symbolsw = "";
te_prefix.typesw = "";
te_prefix.result = "Escher_";
te_prefix.define_csw = "";
te_prefix.define_usw = "";
te_prefix.file = "";
te_prefix.provided_port = "pport_";
te_prefix.required_port = "rport_";
te_prefix.channel = "channel_";
@@@
relinfo_factory@void@@te_relinfo@inst_ref<relationship information>@@@
//
//
te_relinfo = param.te_relinfo;
te_relinfo.multiplicity = 0;
te_relinfo.rel_phrase = "";
te_relinfo.is_formalizer = false;
te_relinfo.is_supertype = false;
te_relinfo.generate_subtype = false;
te_relinfo.gen_declaration = false;
@@@
relstore_factory@void@@te_relstore@inst_ref<relationship storage>@@@
//
//
te_relstore = param.te_relstore;
te_relstore.data_init = "";
te_relstore.link_calls = "";
te_relstore.link_index = 0;
te_relstore.data_fini = "";
te_relstore.self_name = "self";
te_relstore.data_declare = "";
@@@
set_factory@void@@te_set@inst_ref<set>@@@
//
//
te_set = param.te_set;
select any te_prefix from instances of TE_PREFIX;
te_set.module = "";
te_set.copy = te_prefix.result + "CopySet";
te_set.clear = te_prefix.result + "ClearSet";
te_set.setadd = te_prefix.result + "SetAdd";
te_set.insert_element = te_prefix.result + "SetInsertElement";
te_set.element_count = te_prefix.result + "SetCardinality";
te_set.iterator_class_name = te_prefix.result + "Iterator_s";
te_set.number_of_containoids = te_prefix.define_usw + "SYS_MAX_CONTAINERS";
te_set.factory = te_prefix.result + "SetFactoryInit";
te_set.insert_block = te_prefix.result + "SetInsertBlock";
te_set.remove_instance = te_prefix.result + "SetRemoveInstance";
te_set.contains = te_prefix.result + "SetContains";
te_set.equality = te_prefix.result + "SetEquality";
te_set.init = te_prefix.result + "InitSet";
te_set.insert_instance = te_prefix.result + "SetInsertInstance";
te_set.emptiness = te_prefix.result + "SetIsEmpty";
te_set.get_any = te_prefix.result + "SetGetAny";
te_set.remove_element = te_prefix.result + "SetRemoveElement";
te_set.iterator_reset = te_prefix.result + "IteratorReset";
te_set.iterator_next = te_prefix.result + "IteratorNext";
te_set.base_class = te_prefix.result + "ObjectSet_s";
te_set.element_type = te_prefix.result + "SetElement_s";
te_set.scope = "";
@@@
slist_factory@void@@te_slist@inst_ref<slist>@@@
//
//
te_slist = param.te_slist;
select any te_prefix from instances of TE_PREFIX;
te_slist.remove_node = te_prefix.result + "SetRemoveNode";
@@@
string_factory@void@@te_string@inst_ref<string>@@@
//
//
te_string = param.te_string;
select any te_prefix from instances of TE_PREFIX;
te_string.memset = te_prefix.result + "memset";
te_string.memmove = te_prefix.result + "memmove";
te_string.strcpy = te_prefix.result + "strcpy";
te_string.stradd = te_prefix.result + "stradd";
te_string.strlen = te_prefix.result + "strlen";
te_string.itoa = te_prefix.result + "itoa";
te_string.atoi = te_prefix.result + "atoi";
te_string.strcmp = te_prefix.result + "strcmp";
te_string.strget = te_prefix.result + "strget";
te_string.max_string_length = te_prefix.define_u + "SYS_MAX_STRING_LEN";
te_string.debug_buffer_depth = te_prefix.define_u + "DEBUG_BUFFER_DEPTH";
@@@
thread_factory@void@@te_thread@inst_ref<thread>@@@
//
//
te_thread = param.te_thread;
select any te_prefix from instances of TE_PREFIX;
te_thread.file = "sys_thread";
te_thread.mutex_lock = te_prefix.result + "mutex_lock";
te_thread.mutex_unlock = te_prefix.result + "mutex_unlock";
te_thread.nonbusy_wait = te_prefix.result + "nonbusy_wait";
te_thread.nonbusy_wake = te_prefix.result + "nonbusy_wake";
te_thread.shutdown = te_prefix.result + "thread_shutdown";
te_thread.create = te_prefix.result + "thread_create";
te_thread.enabled = false;
te_thread.flavor = "POSIX";
te_thread.serialize = false;
te_thread.number_of_threads = 1;
te_thread.extra_initialization = "";
te_thread.AUTOSAR_enabled = te_prefix.define_usw + "AUTOSAR_ENABLED";
@@@
tim_factory@void@@te_tim@inst_ref<timer>@@@
//
//
te_tim = param.te_tim;
select any te_prefix from instances of TE_PREFIX;
te_tim.max_timers = te_prefix.define_u + "SYS_MAX_XTUML_TIMERS";
te_tim.keyed_timer_support = false;
te_tim.recurring_timer_support = true;
te_tim.internal_type = "ETimer_t";
te_tim.timer_event_search_and_destroy = false;
te_tim.event_name = "";
@@@
typemap_factory@void@@te_typemap@inst_ref<type map>@@@
//
//
te_typemap = param.te_typemap;
select any te_prefix from instances of TE_PREFIX;
te_typemap.instance_index_name = te_prefix.result + "InstanceIndex_t";
te_typemap.instance_index_type = "u2_t";
te_typemap.object_size_name = te_prefix.type + "ClassSize_t";
te_typemap.object_size_type = te_prefix.type + "size_t";
te_typemap.object_number_name = te_prefix.type + "ClassNumber_t";
te_typemap.object_number_type = "u2_t";
te_typemap.state_number_name = te_prefix.type + "StateNumber_t";
te_typemap.state_number_type = "u1_t";
te_typemap.domain_number_name = te_prefix.type + "DomainNumber_t";
te_typemap.domain_number_type = "u1_t";
te_typemap.event_number_name = te_prefix.type + "EventNumber_t";
te_typemap.event_number_type = "u1_t";
te_typemap.event_priority_name = te_prefix.type + "EventPriority_t";
te_typemap.event_priority_type = "u1_t";
te_typemap.event_flags_name = te_prefix.type + "EventFlags_t";
te_typemap.event_flags_type = "u1_t";
te_typemap.poly_return_name = te_prefix.type + "PolyEventRC_t";
te_typemap.poly_return_type = "u1_t";
te_typemap.SEM_cell_type = "u1_t";
te_typemap.SEM_cell_name = te_prefix.type + "SEMcell_t";
@@@
callout_factory@void@@te_callout@inst_ref<user callout>@@@
//
//
te_callout = param.te_callout;
select any te_prefix from instances of TE_PREFIX;
te_callout.initialization = te_prefix.symbolsw + "UserInitializationCallout";
te_callout.pre_xtUML_initialization = te_prefix.symbolsw + "UserPreOoaInitializationCallout";
te_callout.post_xtUML_initialization = te_prefix.symbolsw + "UserPostOoaInitializationCallout";
te_callout.background_processing = te_prefix.symbolsw + "UserBackgroundProcessingCallout";
te_callout.pre_shutdown = te_prefix.symbolsw + "UserPreShutdownCallout";
te_callout.event_no_instance = te_prefix.symbolsw + "UserEventNoInstanceCallout";
te_callout.event_free_list_empty = te_prefix.symbolsw + "UserEventFreeListEmptyCallout";
te_callout.object_pool_empty = te_prefix.symbolsw + "UserObjectPoolEmptyCallout";
te_callout.node_list_empty = te_prefix.symbolsw + "UserNodeListEmptyCallout";
te_callout.interleaved_bridge_overflow = te_prefix.symbolsw + "UserInterleavedBridgeOverflowCallout";
te_callout.self_event_queue_empty = te_prefix.symbolsw + "UserSelfEventQueueEmptyCallout";
te_callout.non_self_event_queue_empty = te_prefix.symbolsw + "UserNonSelfEventQueueEmptyCallout";
te_callout.persistence_error = te_prefix.symbolsw + "UserPersistenceErrorCallout";
te_callout.file = "sys_user_co";
te_callout.post_shutdown = te_prefix.symbolsw + "UserPostShutdownCallout";
te_callout.event_cant_happen = te_prefix.symbolsw + "UserEventCantHappenCallout";
te_callout.empty_handle_detected = te_prefix.symbolsw + "UserEmptyHandleDetectedCallout";
@@@
trace_factory@void@@te_trace@inst_ref<trace>@@@
//
//
te_trace = param.te_trace;
select any te_prefix from instances of TE_PREFIX;
te_trace.component_msg_start = te_prefix.define_usw + "COMP_MSG_START_TRACE";
te_trace.component_msg_end = te_prefix.define_usw + "COMP_MSG_END_TRACE";
te_trace.state_txn_start = te_prefix.define_usw + "STATE_TXN_START_TRACE";
te_trace.oal_trace = te_prefix.define_usw + "OAL_ACTION_TRACE";
te_trace.state_txn_end = te_prefix.define_usw + "STATE_TXN_END_TRACE";
te_trace.state_txn_event_ignored = te_prefix.define_usw + "STATE_TXN_IG_TRACE";
te_trace.state_txn_cant_happen = te_prefix.define_usw + "STATE_TXN_CH_TRACE";
@@@
target_factory@void@@te_target@inst_ref<target>@@@
//
te_target = param.te_target;
te_target.language = "C";
te_target.c2cplusplus_linkage_begin = "#ifdef\t__cplusplus\nextern\t&quot;C&quot;\t{\n#endif";
te_target.c2cplusplus_linkage_end = "#ifdef\t__cplusplus\n}\n#endif";
te_target.main = "main";
@@@
sys_singletons@void@@@
//
create object instance te_prefix of TE_PREFIX;
::prefix_factory( te_prefix:te_prefix );
create object instance te_typemap of TE_TYPEMAP;
::typemap_factory( te_typemap:te_typemap );
create object instance te_container of TE_CONTAINER;
::container_factory( te_container:te_container );
create object instance te_copyright of TE_COPYRIGHT;
::copyright_factory( te_copyright:te_copyright );
create object instance te_dlist of TE_DLIST;
::dlist_factory( te_dlist:te_dlist );
create object instance te_dma of TE_DMA;
::dma_factory( te_dma:te_dma );
create object instance te_eq of TE_EQ;
::eq_factory( te_eq:te_eq );
create object instance te_file of TE_FILE;
::file_factory( te_file:te_file );
create object instance te_instance of TE_INSTANCE;
::instance_factory( te_instance:te_instance );
create object instance te_ilb of TE_ILB;
::ilb_factory( te_ilb:te_ilb );
create object instance te_persist of TE_PERSIST;
::persist_factory( te_persist:te_persist );
create object instance te_relinfo of TE_RELINFO;
::relinfo_factory( te_relinfo:te_relinfo );
create object instance te_relstore of TE_RELSTORE;
::relstore_factory( te_relstore:te_relstore );
create object instance te_set of TE_SET;
::set_factory( te_set:te_set );
create object instance te_slist of TE_SLIST;
::slist_factory( te_slist:te_slist );
create object instance te_string of TE_STRING;
::string_factory( te_string:te_string );
create object instance te_thread of TE_THREAD;
::thread_factory( te_thread:te_thread );
create object instance te_tim of TE_TIM;
::tim_factory( te_tim:te_tim );
create object instance te_callout of TE_CALLOUT;
::callout_factory( te_callout:te_callout );
create object instance te_trace of TE_TRACE;
::trace_factory( te_trace:te_trace );
create object instance te_extent of TE_EXTENT;
::extent_factory( te_extent:te_extent );
create object instance te_target of TE_TARGET;
::target_factory( te_target:te_target );
//
create object instance te_assign of TE_ASSIGN;
create object instance te_create_instance of TE_CREATE_INSTANCE;
create object instance te_for of TE_FOR;
create object instance te_if of TE_IF;
create object instance te_while of TE_WHILE;
create object instance te_elif of TE_ELIF;
create object instance te_delete_instance of TE_DELETE_INSTANCE;
create object instance te_create_event of TE_CREATE_EVENT;
create object instance te_relate of TE_RELATE;
create object instance te_relate_using of TE_RELATE_USING;
create object instance te_unrelate of TE_UNRELATE;
create object instance te_unrelate_using of TE_UNRELATE_USING;
create object instance te_select of TE_SELECT;
create object instance te_select_where of TE_SELECT_WHERE;
create object instance te_generate_precreated_event of TE_GENERATE_PRECREATED_EVENT;
create object instance te_event_parameters of TE_EVENT_PARAMETERS;
create object instance te_generate of TE_GENERATE;
create object instance te_generate_creator_event of TE_GENERATE_CREATOR_EVENT;
create object instance te_generate_to_class of TE_GENERATE_TO_CLASS;
create object instance te_sgn of TE_SGN;
create object instance te_iop of TE_IOP;
create object instance te_operation of TE_OPERATION;
create object instance te_bridge of TE_BRIDGE;
create object instance te_function of TE_FUNCTION;
create object instance te_return of TE_RETURN;
@@@
