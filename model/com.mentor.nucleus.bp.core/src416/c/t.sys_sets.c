if ( 0==strcmp("C",te_target->language) ) {
if ( te_sys->TotalContainers > 0 ) {
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Allocate the storage for the pool of container nodes.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("static ");
T_b(te_set->base_class);
T_b(" node1_FreeList;");
T_b("\n");
T_b("static ");
T_b(te_set->element_type);
T_b(" node1s[ ");
T_b(te_set->number_of_containoids);
T_b(" ];");
T_b("\n");
} else {
T_b("/* No containers allocated.  */");
T_b("\n");
}
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Initialize the node1 instances by linking them into a collection.");
T_b("\n");
T_b(" ");
T_b("* These containoids will be collected into a null-terminated,");
T_b("\n");
T_b(" ");
T_b("* singly linked list (slist).");
T_b("\n");
T_b(" ");
T_b("* This needs to be called during architecture initialization.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->factory);
T_b("( const i_t n1_size )");
T_b("\n");
T_b("{");
T_b("\n");
if ( ( te_sys->TotalContainers > 0 ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("  ");
T_b("u2_t i;");
T_b("\n");
T_b("  ");
T_b("node1_FreeList.head = &node1s[ 0 ];");
T_b("\n");
T_b("  ");
T_b("/* Build the collection (linked list) of node1 instances.  */");
T_b("\n");
if ( ( te_sys->TotalContainers > 0 ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("  ");
T_b("for ( i = 0; i < ( n1_size - 1 ); i++ ) {");
T_b("\n");
T_b("    ");
T_b("node1s[ i ].next = &node1s[ i + 1 ];");
T_b("\n");
T_b("    ");
T_b("node1s[ i ].object = 0;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
}
T_b("  ");
T_b("node1s[ n1_size - 1 ].next = 0;");
T_b("\n");
} else {
T_b("  ");
T_b("/* Set factory initialization optimized out.  */");
T_b("\n");
}
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* This will copy all of the elements from one set into another");
T_b("\n");
T_b(" ");
T_b("* set.  If the target set is not empty, it will be cleared");
T_b("\n");
T_b(" ");
T_b("* before the copy operation occurs freeing any nodes in that set.");
T_b("\n");
T_b(" ");
T_b("* The new set will use containoids from the free list.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( te_sys->TotalContainers > 0 ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("void ");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->copy);
T_b("( ");
T_b(te_set->base_class);
T_b(" * to_set,");
T_b("\n");
T_b("                ");
T_b(te_set->base_class);
T_b(" * const from_set )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_set->element_type);
T_b(" * slot;");
T_b("\n");
T_b("  ");
T_b("/* May be copying into an existing set, release target collection nodes.  */");
T_b("\n");
T_b("  ");
T_b(te_set->clear);
T_b("( to_set );");
T_b("\n");
T_b("  ");
T_b("for ( slot = from_set->head; ( slot != 0 ); slot = slot->next ) {");
T_b("\n");
T_b("    ");
T_b(te_set->insert_element);
T_b("( to_set, slot->object ); ");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Set copy code optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Release all nodes in the given set back to the free pool.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( te_sys->TotalContainers > 0 ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->clear);
T_b("( ");
T_b(te_set->base_class);
T_b(" * set )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("if ( set->head != 0 ) {                                    /* empty set  */");
T_b("\n");
T_b("    ");
T_b(te_set->element_type);
T_b(" * slot;");
T_b("\n");
T_b("    ");
T_b("for ( slot = set->head; ( slot->next != 0 ); slot = slot->next ); /* Find end.  */");
T_b("\n");
if ( te_thread->enabled ) {
T_b("    ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_INSTANCE );");
T_b("\n");
}
T_b("    ");
T_b("slot->next = node1_FreeList.head;     /* Tie string to free list.      */");
T_b("\n");
T_b("    ");
T_b("node1_FreeList.head = set->head;      /* Point free list to head.      */");
T_b("\n");
if ( te_thread->enabled ) {
T_b("    ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_INSTANCE );");
T_b("\n");
}
T_b("    ");
T_b(te_set->init);
T_b("( set );                /* Zero set out.  */");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Set clearing code optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Insert a single element into the set in no particular order.");
T_b("\n");
T_b(" ");
T_b("* The element is a data item.  A container node will be allocated");
T_b("\n");
T_b(" ");
T_b("* to link in the element.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( te_sys->TotalContainers > 0 ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->insert_element);
T_b("(");
T_b("\n");
T_b("  ");
T_b(te_set->base_class);
T_b(" * set,");
T_b("\n");
T_b("  ");
T_b("void * const substance");
T_b("\n");
T_b(")");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b(te_set->element_type);
T_b(" * slot;");
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_INSTANCE );");
T_b("\n");
}
T_b("  ");
T_b("if ( 0 == node1_FreeList->head ) {");
T_b("\n");
if ( te_sys->UnitsToDynamicallyAllocate != 0 ) {
T_b("    ");
T_b(te_set->element_type);
T_b(" * new_mem = ( ");
T_b(te_set->element_type);
T_b(" *) ");
T_b(te_dma->allocate);
T_b("( ");
T_b(te_sys->UnitsToDynamicallyAllocate);
T_b(" * sizeof( ");
T_b(te_set->element_type);
T_b(" ) );");
T_b("\n");
T_b("    ");
T_b("if ( 0 == new_mem ) {");
T_b("\n");
T_b("      ");
T_b(te_callout->node_list_empty);
T_b("(); /* Bad news!  No more heap space.  */");
T_b("\n");
T_b("    ");
T_b("} else {");
T_b("\n");
T_b("      ");
T_b("u1_t i;");
T_b("\n");
T_b("      ");
T_b("for ( i = 0; i < ");
T_b(te_sys->UnitsToDynamicallyAllocate);
T_b(" - 1; i++ ) {");
T_b("\n");
T_b("        ");
T_b("new_mem[ i ].next = (");
T_b(te_set->element_type);
T_b(" *) &(new_mem[ i + 1 ]);");
T_b("\n");
T_b("      ");
T_b("}");
T_b("\n");
T_b("      ");
T_b("new_mem[ ");
T_b(te_sys->UnitsToDynamicallyAllocate);
T_b(" - 1 ].next = 0;");
T_b("\n");
T_b("      ");
T_b("node1_FreeList.head = new_mem;");
T_b("\n");
T_b("      ");
T_b(te_set->insert_element);
T_b("( set, substance );");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
} else {
T_b("    ");
T_b(te_callout->node_list_empty);
T_b("(); /* Bad news!  No more nodes.         */");
T_b("\n");
}
T_b("  ");
T_b("} else {");
T_b("\n");
T_b("    ");
T_b("slot = node1_FreeList.head; /* Extract node from free list head. */");
T_b("\n");
T_b("    ");
T_b("node1_FreeList.head = node1_FreeList.head->next;");
T_b("\n");
T_b("    ");
T_b("slot->object = substance;");
T_b("\n");
T_b("    ");
T_b("slot->next = set->head;     /* Insert substance at list front.   */");
T_b("\n");
T_b("    ");
T_b("set->head = slot;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_INSTANCE );");
T_b("\n");
}
T_b("}");
T_b("\n");
} else {
T_b("/* Set insertion code optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Insert a block of objects into the given set in sequence.  Link the");
T_b("\n");
T_b(" ");
T_b("* data into the supplied containers.");
T_b("\n");
T_b(" ");
T_b("* Return a pointer to the linked set.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( not_empty te_cs ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b(te_set->scope);
T_b(te_set->element_type);
T_b(" *");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->insert_block);
T_b("( ");
T_b(te_set->element_type);
T_b(" * container,");
T_b("\n");
T_b("                       ");
T_b("const u1_t * instance,");
T_b("\n");
T_b("                       ");
T_b("const u2_t length,");
T_b("\n");
T_b("                       ");
T_b("u2_t count )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b(te_set->element_type);
T_b(" * head = ( count > 0 ) ? container : 0;");
T_b("\n");
if ( te_sys->CollectionsFlavor == 20 ) {
T_b("  ");
T_b("u2_t n = count;");
T_b("\n");
}
T_b("  ");
T_b("while ( count > 0 ) {");
T_b("\n");
if ( te_sys->CollectionsFlavor == 20 ) {
T_b("    ");
T_b("container->prev = ( count < n ) ? container - 1 : 0;");
T_b("\n");
}
T_b("    ");
T_b("count--;");
T_b("\n");
T_b("    ");
T_b("container->object = (void *) instance;  /* Link in the object data.     */");
T_b("\n");
if ( TRUE ) {
T_b("    ");
T_b("instance = instance + length;           /* Bump to next object image.   */");
T_b("\n");
} else {
T_b("    ");
T_b("{ u2_t i=length; while ( i>0 ) {instance++; i--;} } /* slow for MISRA-C */");
T_b("\n");
}
T_b("    ");
T_b("/* String together or ground containoids.  */");
T_b("\n");
T_b("    ");
T_b("container->next = ( count > 0 ) ? container + 1 : 0;");
T_b("\n");
T_b("    ");
T_b("container++;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return head;");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Block insertion optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Remove an instance from an instance collection.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/* Signature:  void ");
T_b(te_set->remove_instance);
T_b("( pextent, instance, slot, container, pool ) */");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Insert an instance onto an extent.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/* Signature:  void ");
T_b(te_set->insert_instance);
T_b("( pextent, node ) */");
T_b("\n");
if ( te_sys->CollectionsFlavor == 20 ) {
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Remove an item from the given set which is a doubly linked list.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_dlist->remove_node);
T_b("(");
T_b("\n");
T_b("  ");
T_b(te_set->base_class);
T_b(" * set,");
T_b("\n");
T_b("  ");
T_b(te_set->element_type);
T_b(" * const slot");
T_b("\n");
T_b(")");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("if ( set->head == slot ) {     /* node found at head of list       */");
T_b("\n");
T_b("    ");
T_b("set->head = set->head->next; /* Shift off head of list.          */");
T_b("\n");
T_b("  ");
T_b("} else {");
T_b("\n");
T_b("    ");
T_b("slot->prev->next = slot->next;");
T_b("\n");
T_b("    ");
T_b("if ( slot->next ) slot->next->prev = slot->prev;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Remove a data item from the given set.  This requires searching");
T_b("\n");
T_b(" ");
T_b("* the set for the item, unlinking the item (if found) && returning");
T_b("\n");
T_b(" ");
T_b("* the pointer to the removed node.  SetRemoveNode is used");
T_b("\n");
T_b(" ");
T_b("* when some knowledge of the linking mechanism is required (as");
T_b("\n");
T_b(" ");
T_b("* in extent management).  SetRemoveElement is used whenever");
T_b("\n");
T_b(" ");
T_b("* possible.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->element_type);
T_b(" *");
T_b("\n");
T_b(te_set->scope);
T_b(te_slist->remove_node);
T_b("(");
T_b("\n");
T_b("  ");
T_b(te_set->base_class);
T_b(" * set,");
T_b("\n");
T_b("  ");
T_b("const void * const d");
T_b("\n");
T_b(")");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b(te_set->element_type);
T_b(" * t = set->head; /* Start with first node.           */");
T_b("\n");
T_b("  ");
T_b("/* Find node containing data and unlink from list.                 */");
T_b("\n");
T_b("  ");
T_b("if ( t->object == d ) {        /* Element found at head->           */");
T_b("\n");
T_b("    ");
T_b("set->head = t->next;         /* Unlink it from the list.         */");
T_b("\n");
T_b("  ");
T_b("} else {");
T_b("\n");
T_b("    ");
T_b(te_set->element_type);
T_b(" * t_old;");
T_b("\n");
T_b("    ");
T_b("do {                         /* Search for data element.         */");
T_b("\n");
T_b("      ");
T_b("t_old = t;");
T_b("\n");
T_b("      ");
T_b("t = t->next;");
T_b("\n");
T_b("      ");
T_b("if ( t == 0 ) { return 0; } /* absent       */");
T_b("\n");
T_b("    ");
T_b("} while ( t->object != d );");
T_b("\n");
T_b("    ");
T_b("t_old->next = t->next;      /* Unlink element from the list.     */");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
if ( te_sys->InstanceLoading ) {
T_b("  ");
T_b("if ( set->tail == t ) {");
T_b("\n");
T_b("    ");
T_b("set->tail = t->next;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
}
T_b("  ");
T_b("return t;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* This interface is used more often to remove an element.  This is");
T_b("\n");
T_b(" ");
T_b("* used when maximum anonymity is required.  Escher_SetRemoveNode is");
T_b("\n");
T_b(" ");
T_b("* used when some knowledge of the linking mechanism is required (as");
T_b("\n");
T_b(" ");
T_b("* in extent management).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( te_sys->TotalContainers > 0 ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->remove_element);
T_b("(");
T_b("\n");
T_b("  ");
T_b(te_set->base_class);
T_b(" * set,");
T_b("\n");
T_b("  ");
T_b("const void * const d");
T_b("\n");
T_b(")");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b(te_set->element_type);
T_b(" * t;");
T_b("\n");
T_b("  ");
T_b("if ( set->head != 0 ) {                     /* empty set */");
T_b("\n");
T_b("    ");
T_b("t = ");
T_b(te_slist->remove_node);
T_b("( set, d );");
T_b("\n");
T_b("    ");
T_b("/* Return node to architecture collection (free list).             */");
T_b("\n");
T_b("    ");
T_b("if ( t != 0 ) {");
T_b("\n");
if ( te_thread->enabled ) {
T_b("      ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_INSTANCE );");
T_b("\n");
}
T_b("      ");
T_b("t->next = node1_FreeList.head;");
T_b("\n");
T_b("      ");
T_b("node1_FreeList.head = t;");
T_b("\n");
if ( te_thread->enabled ) {
T_b("      ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_INSTANCE );");
T_b("\n");
}
T_b("    ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Set remove element code optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Return a pointer to the found element when the set contains the ");
T_b("\n");
T_b(" ");
T_b("* given data element.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( not_empty te_cs ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("const void *");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->contains);
T_b("(");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_set->base_class);
T_b(" * const set,");
T_b("\n");
T_b("  ");
T_b("const void * const element");
T_b("\n");
T_b(")");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_set->element_type);
T_b(" * node = set->head;");
T_b("\n");
T_b("  ");
T_b("while ( node != 0 ) {");
T_b("\n");
T_b("    ");
T_b("if ( node->object == element ) { return node; }  /* found  */");
T_b("\n");
T_b("    ");
T_b("node = node->next;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return 0;                                      /* absent */");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Set containment method optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Count the elements in the set.  Return that count.");
T_b("\n");
T_b(" ");
T_b("* This routine counts nodes.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( not_empty te_cs ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("u2_t ");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->element_count);
T_b("( const ");
T_b(te_set->base_class);
T_b(" * const set )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u2_t result = 0;");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_set->element_type);
T_b(" * node = set->head;");
T_b("\n");
T_b("  ");
T_b("while ( node != 0 ) {");
T_b("\n");
T_b("    ");
T_b("result++;");
T_b("\n");
T_b("    ");
T_b("node = node->next;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return result;");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Counting of set elements optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Return true when the left and right set are equivalent.");
T_b("\n");
T_b(" ");
T_b("* Note:  This currently is not implemented.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
if ( ( not_empty te_cs ) || ( 0==strcmp("C++",te_target->language) ) ) {
T_b("bool");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->equality);
T_b("( ");
T_b(te_set->base_class);
T_b(" * const left_set,");
T_b("\n");
T_b("                    ");
T_b(te_set->base_class);
T_b(" * const right_set )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("bool rc = false;");
T_b("\n");
T_b("  ");
T_b("if ( (left_set->head == 0) && (right_set->head == 0) ) {");
T_b("\n");
T_b("    ");
T_b("rc = true;");
T_b("\n");
T_b("  ");
T_b("} else if ( ( (left_set->head != 0) && (right_set->head != 0) ) &&");
T_b("\n");
T_b("    ");
T_b("(");
T_b(te_set->element_count);
T_b("( left_set ) == ");
T_b(te_set->element_count);
T_b("( right_set )) ) {");
T_b("\n");
T_b("    ");
T_b("rc = true;");
T_b("\n");
T_b("  ");
T_b("} else { /* nop */ }");
T_b("\n");
T_b("  ");
T_b("return rc;");
T_b("\n");
T_b("}");
T_b("\n");
} else {
T_b("/* Set equality function optimized out.  */");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Initialize a set variable.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/* Signature:  void ");
T_b(te_set->init);
T_b("( ");
T_b(te_set->base_class);
T_b(" * set ) */");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Get any element (1st) from a collection.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/* Signature:  void * ");
T_b(te_set->get_any);
T_b("( ");
T_b(te_set->base_class);
T_b(" * const set ) */");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Return true if set is empty->");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/* Signature:  bool ");
T_b(te_set->emptiness);
T_b("( const ");
T_b(te_set->base_class);
T_b(" * const set ) */");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Use this method to reset the cursor.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/* Signature:  void ");
T_b(te_set->iterator_reset);
T_b("( ");
T_b(te_set->iterator_class_name);
T_b(" * const iterator,");
T_b("\n");
T_b(" ");
T_b("*                                        ");
T_b(te_set->base_class);
T_b(" * const set )");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Interate to the next element and return it.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void *");
T_b("\n");
T_b(te_set->scope);
T_b(te_set->iterator_next);
T_b("( ");
T_b(te_set->iterator_class_name);
T_b(" * const iter )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("void * element = 0;");
T_b("\n");
T_b("  ");
T_b("if ( iter->cursor != 0 ) {");
T_b("\n");
T_b("    ");
T_b("element = iter->cursor->object;");
T_b("\n");
T_b("    ");
T_b("iter->cursor = iter->cursor->next;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return element;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Set memory bytes to value at destination.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->memset);
T_b("( void * const dst, const u1_t val, u2_t len )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t * d = (u1_t *) dst;");
T_b("\n");
T_b("  ");
T_b("while ( len > 0 ) {");
T_b("\n");
T_b("    ");
T_b("len--;");
T_b("\n");
T_b("    ");
T_b("*d++ = val;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Move memory bytes from source to destination.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->memmove);
T_b("( void * const dst, const void * const src, u2_t len )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t * s = (u1_t *) src;");
T_b("\n");
T_b("  ");
T_b("u1_t * d = (u1_t *) dst;");
T_b("\n");
T_b("  ");
T_b("while ( len > 0 ) {");
T_b("\n");
T_b("    ");
T_b("len--;");
T_b("\n");
T_b("    ");
T_b("*d++ = *s++;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Copy characters and be paranoid about null delimiter.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("c_t *");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->strcpy);
T_b("( c_t * dst, const c_t * src )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("c_t * s = dst;");
T_b("\n");
if ( te_sys->InstanceLoading ) {
T_b("  ");
T_b("if ( 0 != src ) {");
T_b("\n");
T_b("    ");
T_b("i_t i = ");
T_b(te_set->scope);
T_b(te_string->strlen);
T_b("( src ) + 1;");
T_b("\n");
T_b("    ");
T_b("s = ");
T_b(te_set->scope);
T_b(te_dma->allocate);
T_b("( i );");
T_b("\n");
T_b("    ");
T_b("dst = s;");
T_b("\n");
} else {
T_b("  ");
T_b("s2_t i = ");
T_b(te_string->max_string_length);
T_b(" - 1;");
T_b("\n");
T_b("  ");
T_b("if ( ( 0 != src ) && ( 0 != dst ) ) {");
T_b("\n");
}
T_b("    ");
T_b("while ( ( i > 0 ) && ( *src != '\0' ) ) {");
T_b("\n");
T_b("      ");
T_b("--i;");
T_b("\n");
T_b("      ");
T_b("*dst++ = *src++;");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
T_b("    ");
T_b("*dst = '\0';  /* Ensure delimiter.  */");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return s;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Add two strings.  Allocate a temporary memory variable to return the value.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("c_t *");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->stradd);
T_b("( const c_t * left, const c_t * right )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("s2_t i = ");
T_b(te_string->max_string_length);
T_b(" - 1;");
T_b("\n");
T_b("  ");
T_b("c_t * s = ");
T_b(te_set->scope);
T_b(te_string->strget);
T_b("();");
T_b("\n");
T_b("  ");
T_b("c_t * dst = s;");
T_b("\n");
T_b("  ");
T_b("if ( 0 == left ) left = \"\";");
T_b("\n");
T_b("  ");
T_b("if ( 0 == right ) right = \"\";");
T_b("\n");
T_b("  ");
T_b("while ( ( i > 0 ) && ( *left != '\0' ) ) {");
T_b("\n");
T_b("    ");
T_b("--i;");
T_b("\n");
T_b("    ");
T_b("*dst++ = *left++;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("while ( ( i > 0 ) && ( *right != '\0' ) ) {");
T_b("\n");
T_b("    ");
T_b("--i;");
T_b("\n");
T_b("    ");
T_b("*dst++ = *right++;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("*dst = '\0';  /* Ensure delimiter.  */");
T_b("\n");
T_b("  ");
T_b("return s;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Compare two strings.");
T_b("\n");
T_b(" ");
T_b("* Return negative number if s1 < s2->");
T_b("\n");
T_b(" ");
T_b("* Return zero if s1 == s2->");
T_b("\n");
T_b(" ");
T_b("* Return postive number if s1 > s2->");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("c_t");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->strcmp);
T_b("( const c_t *p1, const c_t *p2 )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("const c_t *s1 = p1;");
T_b("\n");
T_b("  ");
T_b("const c_t *s2 = p2;");
T_b("\n");
T_b("  ");
T_b("c_t c1, c2;");
T_b("\n");
T_b("  ");
T_b("i_t i = ");
T_b(te_string->max_string_length);
T_b(";");
T_b("\n");
if ( te_sys->InstanceLoading ) {
T_b("  ");
T_b("if ( 0 == p1 ) s1 = \"\";");
T_b("\n");
T_b("  ");
T_b("if ( 0 == p2 ) s2 = \"\";");
T_b("\n");
}
T_b("  ");
T_b("do {");
T_b("\n");
T_b("    ");
T_b("c1 = *s1++;");
T_b("\n");
T_b("    ");
T_b("c2 = *s2++;");
T_b("\n");
T_b("    ");
T_b("if ( c1 == 0 ) { break; }");
T_b("\n");
T_b("    ");
T_b("--i;");
T_b("\n");
T_b("  ");
T_b("} while ( ( c1 == c2 ) && ( i >= 0 ) );");
T_b("\n");
T_b("  ");
T_b("return ( c1 - c2 );");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Return a string buffer.  Rotate through a pool.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("c_t *");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->strget);
T_b("( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("static u1_t i = 0;");
T_b("\n");
T_b("  ");
T_b("static c_t s[ 16 ][ ");
T_b(te_string->max_string_length);
T_b(" ];");
T_b("\n");
T_b("  ");
T_b("i = ( i + 1 ) % 16;");
T_b("\n");
T_b("  ");
T_b("s[ i ][ 0 ] = 0;");
T_b("\n");
T_b("  ");
T_b("return ( &s[ i ][ 0 ] );");
T_b("\n");
T_b("}");
T_b("\n");
if ( ( te_sys->InstanceLoading ) || ( 0 != te_sys->UnitsToDynamicallyAllocate ) ) {
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Measure the length of the given string.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("i_t");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->strlen);
T_b("( const c_t * s )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("i_t len = 0;");
T_b("\n");
T_b("  ");
T_b("i_t i = ");
T_b(te_string->max_string_length);
T_b(" * 4;");
T_b("\n");
T_b("  ");
T_b("if ( s != 0 ) {");
T_b("\n");
T_b("    ");
T_b("while ( ( *s != 0 ) && ( i >= 0 ) ) {");
T_b("\n");
T_b("      ");
T_b("s++;");
T_b("\n");
T_b("      ");
T_b("len++;");
T_b("\n");
T_b("      ");
T_b("--i;");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return len;");
T_b("\n");
T_b("}");
T_b("\n");
}
if ( te_sys->InstanceLoading ) {
T_b("#define ");
T_b(te_prefix->define_u);
T_b("ATOI_RADIX 10");
T_b("\n");
T_b("c_t *");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->itoa);
T_b("( c_t * string, s4_t value )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("c_t tmp[16];");
T_b("\n");
T_b("  ");
T_b("c_t * sp, * tp = tmp;");
T_b("\n");
T_b("  ");
T_b("s4_t i;");
T_b("\n");
T_b("  ");
T_b("bool sign;");
T_b("\n");
T_b("  ");
T_b("u4_t v;");
T_b("\n");
T_b("  ");
T_b("sign = ( value < 0 );");
T_b("\n");
T_b("  ");
T_b("if ( sign ) {");
T_b("\n");
T_b("    ");
T_b("v = -value;");
T_b("\n");
T_b("  ");
T_b("} else {");
T_b("\n");
T_b("    ");
T_b("v = (unsigned) value;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("while ( ( v != 0 ) || ( tp == tmp ) ) {");
T_b("\n");
T_b("    ");
T_b("i = v % ");
T_b(te_prefix->define_u);
T_b("ATOI_RADIX;");
T_b("\n");
T_b("    ");
T_b("v = v / ");
T_b(te_prefix->define_u);
T_b("ATOI_RADIX;");
T_b("\n");
T_b("    ");
T_b("if ( i < 10 ) {");
T_b("\n");
T_b("      ");
T_b("*tp++ = i + '0';");
T_b("\n");
T_b("    ");
T_b("} else {");
T_b("\n");
T_b("      ");
T_b("*tp++ = i + 'a' - 10;");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("sp = string;");
T_b("\n");
T_b("  ");
T_b("if ( sign ) {");
T_b("\n");
T_b("    ");
T_b("*sp++ = '-';");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("while ( tp > tmp ) {");
T_b("\n");
T_b("    ");
T_b("*sp++ = *--tp;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("*sp = 0;");
T_b("\n");
T_b("  ");
T_b("return string;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("s4_t");
T_b("\n");
T_b(te_set->scope);
T_b(te_string->atoi);
T_b("( const char * p )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("s4_t n = 0;");
T_b("\n");
T_b("  ");
T_b("s1_t f = 0;");
T_b("\n");
T_b("  ");
T_b("for ( ; ; p++ ) {");
T_b("\n");
T_b("    ");
T_b("switch( *p ) {");
T_b("\n");
T_b("    ");
T_b("case ' ':");
T_b("\n");
T_b("    ");
T_b("case '\t':");
T_b("\n");
T_b("      ");
T_b("continue;");
T_b("\n");
T_b("    ");
T_b("case '-':");
T_b("\n");
T_b("      ");
T_b("f++;");
T_b("\n");
T_b("    ");
T_b("case '+':");
T_b("\n");
T_b("      ");
T_b("p++;");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
T_b("    ");
T_b("break;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("while ( ( *p >= '0' ) && ( *p <= '9' ) ) {");
T_b("\n");
T_b("    ");
T_b("n = n * 10 + *p++ - '0';");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return ( f ? -n : n );");
T_b("\n");
T_b("}");
T_b("\n");
}
if ( 0 != te_sys->UnitsToDynamicallyAllocate ) {
T_b("/*----------------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* This routine provides a central connection to ANSI-standard system-level");
T_b("\n");
T_b(" ");
T_b("* memory allocation.  MC-3020 is optimized for static memory allocation");
T_b("\n");
T_b(" ");
T_b("* and only uses dynamic memory allocation when enabled with marking.");
T_b("\n");
T_b(" ");
T_b("* Dynamic memory allocation can be used in conjunction with static");
T_b("\n");
T_b(" ");
T_b("* allocation providing protection against unexpected memory \"overflows\"");
T_b("\n");
T_b(" ");
T_b("* conditions.");
T_b("\n");
T_b(" ");
T_b("*--------------------------------------------------------------------------*/");
T_b("\n");
T_b("#include <stdlib.h>");
T_b("\n");
if ( te_dma->debugging_heap ) {
T_b("#define ROX_MALLOC_HEAP_SIZE 0x7fffffff");
T_b("\n");
T_b("static size_t used_heap = 0;");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Allocate memory from the system heap.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void * ");
T_b("\n");
T_b(te_set->scope);
T_b(te_dma->allocate);
T_b("( const u4_t b )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("void * new_mem = 0;");
T_b("\n");
T_b("  ");
T_b("size_t bytes = ( size_t ) b;");
T_b("\n");
if ( te_dma->debugging_heap ) {
T_b("  ");
T_b("if ( used_heap + bytes <= ROX_MALLOC_HEAP_SIZE ) {");
T_b("\n");
T_b("    ");
T_b("new_mem = malloc( bytes );");
T_b("\n");
T_b("    ");
T_b("if ( 0 != new_mem ) {");
T_b("\n");
T_b("      ");
T_b("used_heap = used_heap + bytes;");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("} ");
T_b("\n");
} else {
T_b("  ");
T_b("new_mem = malloc( bytes );");
T_b("\n");
T_b("  ");
T_b("if ( 0 == new_mem ) {");
T_b("\n");
T_b("    ");
T_b("// fprintf( stderr, \"Escher_malloc:  out of memory\n\" );");
T_b("\n");
T_b("    ");
T_b("// exit( 1 );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
}
T_b("  ");
T_b("return new_mem;");
T_b("\n");
T_b("}");
T_b("\n");
}
