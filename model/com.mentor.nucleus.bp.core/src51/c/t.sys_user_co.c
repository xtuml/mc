T_b("/*----------------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* File:  ");
T_b(te_file->callout);
T_b(".");
T_b(te_file->src_file_ext);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* Description:");
T_b("\n");
T_b(" ");
T_b("* Interface call-outs allow the user to capture execution control of the");
T_b("\n");
T_b(" ");
T_b("* generated system running on a target.");
T_b("\n");
T_b(" ");
T_b("* Especially in the deeply embedded software/hardware development world,");
T_b("\n");
T_b(" ");
T_b("* it may be necessary to tightly interface the xtUML system to the");
T_b("\n");
T_b(" ");
T_b("* surrounding/containing system. MC-3020 provides callout routines");
T_b("\n");
T_b(" ");
T_b("* that enable the user to easily interface code generated by the model");
T_b("\n");
T_b(" ");
T_b("* compiler with other system code. These callout routines are empty when");
T_b("\n");
T_b(" ");
T_b("* generated by the model compiler. It is up to the user to define");
T_b("\n");
T_b(" ");
T_b("* additional functionality (if necessary) to be performed at these");
T_b("\n");
T_b(" ");
T_b("* callout points.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_copyright->body);
T_b("\n");
T_b(" ");
T_b("*--------------------------------------------------------------------------*/");
T_b("\n");
T_b("#include \"");
T_b(te_file->types);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
T_b("#include \"");
T_b(te_file->callout);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
T_b("#ifdef SYS_USER_CO_PRINTF_ON");
T_b("\n");
T_b("#include <stdio.h>");
T_b("\n");
T_b("#define SYS_USER_CO_PRINTF( s ) printf( s );");
T_b("\n");
T_b("#else");
T_b("\n");
T_b("#define SYS_USER_CO_PRINTF( s )");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->initialization);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked at the immediate beginning of application");
T_b("\n");
T_b(" ");
T_b("* initialization. It is the very first function to be executed at system");
T_b("\n");
T_b(" ");
T_b("* startup.");
T_b("\n");
T_b(" ");
T_b("* User supplied implementation of this function should be restricted to");
T_b("\n");
T_b(" ");
T_b("* things like memory initialization, early hardware duties, etc.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->initialization);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("/* Activate this invocation to initialize the example simple TIM.  */");
T_b("\n");
if ( 0==strcmp("C",te_target->language) ) {
T_b("  ");
T_b("#if ");
T_b(te_tim->max_timers);
T_b(" > 0");
T_b("\n");
T_b("  ");
T_b("TIM_init();");
T_b("\n");
T_b("  ");
T_b("#endif");
T_b("\n");
}
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->initialization);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->pre_xtUML_initialization);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked immediately prior to executing any xtUML");
T_b("\n");
T_b(" ");
T_b("* initialization functions.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->pre_xtUML_initialization);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->pre_xtUML_initialization);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->post_xtUML_initialization);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked immediately after executing any xtUML");
T_b("\n");
T_b(" ");
T_b("* initialization functions.");
T_b("\n");
T_b(" ");
T_b("* When this callout function returns, the system dispatcher will allow the");
T_b("\n");
T_b(" ");
T_b("* xtUML application analysis state models to start consuming events.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->post_xtUML_initialization);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->post_xtUML_initialization);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->background_processing);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked once during each loop execution of the system");
T_b("\n");
T_b(" ");
T_b("* dispather.");
T_b("\n");
T_b(" ");
T_b("* It is invoked at the 'top' of the system dispatcher loop, immediately");
T_b("\n");
T_b(" ");
T_b("* prior to dispatching any xtUML application analysis events.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->background_processing);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
if ( 0==strcmp("C++",te_target->language) ) {
if ( 0!=strcmp("SystemC",te_thread->flavor) ) {
T_b("  ");
T_b("/* Activate this invocation to periodically tick the example simple TIM.  */");
T_b("\n");
T_b("  ");
T_b("#if ");
T_b(te_tim->max_timers);
T_b(" > 0");
T_b("\n");
T_b("  ");
T_b("//TIM::tick();");
T_b("\n");
T_b("  ");
T_b("#endif");
T_b("\n");
}
} else if ( 0==strcmp("C",te_target->language) ) {
T_b("  ");
T_b("/* Activate this invocation to periodically tick the example simple TIM.  */");
T_b("\n");
T_b("  ");
T_b("#if ");
T_b(te_tim->max_timers);
T_b(" > 0");
T_b("\n");
T_b("  ");
T_b("TIM_tick();");
T_b("\n");
T_b("  ");
T_b("#endif");
T_b("\n");
}
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->pre_shutdown);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked at termination of the system dispatcher, but");
T_b("\n");
T_b(" ");
T_b("* prior to performing any xtUML application analysis shutdown sequencing.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->pre_shutdown);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->pre_shutdown);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->post_shutdown);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked immediately before application exit.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->post_shutdown);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->post_shutdown);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->event_cant_happen);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked any time that an event is received that");
T_b("\n");
T_b(" ");
T_b("* results in a \"cant happen\" transition.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->event_cant_happen);
T_b("f(");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_typemap->state_number_name);
T_b(" current_state,");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_typemap->state_number_name);
T_b(" next_state,");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_typemap->event_number_name);
T_b(" event_number )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->event_cant_happen);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->event_no_instance);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when we failed to validate the instance");
T_b("\n");
T_b(" ");
T_b("* to which an event was directed.  This can happen in normal operation");
T_b("\n");
T_b(" ");
T_b("* when the instance was deleted while the event was in flight (analysis");
T_b("\n");
T_b(" ");
T_b("* error).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->event_no_instance);
T_b("f(");
T_b("\n");
T_b("  ");
T_b("const ");
T_b(te_typemap->event_number_name);
T_b(" event_number )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->event_no_instance);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->event_free_list_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to allocate an");
T_b("\n");
T_b(" ");
T_b("* event, but there are no more left.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->event_free_list_empty);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->event_free_list_empty);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->empty_handle_detected);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to use an instance");
T_b("\n");
T_b(" ");
T_b("* reference variable (handle) that is null (empty).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->empty_handle_detected);
T_b("f( c_t * object_keyletters, c_t * s )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->empty_handle_detected);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->object_pool_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to create an");
T_b("\n");
T_b(" ");
T_b("* instance of an object, but there are no instances available.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->object_pool_empty);
T_b("f( const ");
T_b(te_typemap->domain_number_name);
T_b(" component_number, const ");
T_b(te_typemap->object_number_name);
T_b(" class_number )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->object_pool_empty);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->node_list_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to allocate a");
T_b("\n");
T_b(" ");
T_b("* node, but there are no more left.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->node_list_empty);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->node_list_empty);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to post too many");
T_b("\n");
T_b(" ");
T_b("* interleaved bridges.  The depth of this list is defined by");
T_b("\n");
T_b(" ");
T_b("* SYS_MAX_INTERLEAVED_BRIDGES (unless changed in the archetype).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->interleaved_bridge_overflow);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->interleaved_bridge_overflow);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->self_event_queue_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when the events to self queue is");
T_b("\n");
T_b(" ");
T_b("* interrogated and found to be empty.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->self_event_queue_empty);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->non_self_event_queue_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when the events to instance queue is");
T_b("\n");
T_b(" ");
T_b("* interrogated and found to be empty.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->non_self_event_queue_empty);
T_b("f( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->persistence_error);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when the events to instance queue is");
T_b("\n");
T_b(" ");
T_b("* interrogated and found to be empty.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_callout->persistence_error);
T_b("f( i_t error_code )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("/* Insert implementation specific code here.  */");
T_b("\n");
T_b("  ");
T_b("SYS_USER_CO_PRINTF( \"");
T_b(te_callout->persistence_error);
T_b("\n\" )");
T_b("\n");
T_b("}");
T_b("\n");
