T_b("/*---------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* File:  ");
T_b(te_file->thread);
T_b(".");
T_b(te_file->src_file_ext);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* Description:");
T_b("\n");
T_b(" ");
T_b("* This file provides implementation of multi-tasking/threading");
T_b("\n");
T_b(" ");
T_b("* capabilities allowing classes/subsystems to run in different");
T_b("\n");
T_b(" ");
T_b("* threads on a multi-tasking/threading OS/RTOS.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_copyright->body);
T_b("\n");
T_b(" ");
T_b("*-------------------------------------------------------------------*/");
T_b("\n");
T_b("#include <pthread.h>   /* POSIX thread declarations */");
T_b("\n");
T_b("#include \"");
T_b(te_file->types);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
if ( te_sys->MaxTimers > 0 ) {
T_b("#include \"");
T_b(te_file->tim);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
}
T_b("static pthread_mutex_t mutices[ SEMAPHORE_FLAVOR_MAX ];");
T_b("\n");
T_b("static pthread_cond_t nonbusy_wait_cond[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("static u1_t threadnumber[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Initialize those structures that need to be set up once at system");
T_b("\n");
T_b(" ");
T_b("* bring-up time.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_prefix->result);
T_b("InitializeThreading( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t i;");
T_b("\n");
T_b("  ");
T_b("int rc;");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < NUM_OF_TOTAL_THREADS; i++ ) {");
T_b("\n");
T_b("    ");
T_b("threadnumber[ i ] = i;");
T_b("\n");
T_b("    ");
T_b("rc = pthread_cond_init( &nonbusy_wait_cond[ i ], 0 );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < SEMAPHORE_FLAVOR_MAX; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = pthread_mutex_init( &mutices[ i ], 0 );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Obtain a resource lock so that this thread has mutually exclusive");
T_b("\n");
T_b(" ");
T_b("* access.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->mutex_lock);
T_b("( const u1_t flavor )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("int rc = pthread_mutex_lock( &mutices[ flavor ] );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Release a resource lock that was obtained with the lock method.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->mutex_unlock);
T_b("( const u1_t flavor )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("int rc = pthread_mutex_unlock( &mutices[ flavor ] );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Go into a non-busy wait state waiting on someone to wake us");
T_b("\n");
T_b(" ");
T_b("* up with the nonbusy_wake method.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->nonbusy_wait);
T_b("( const u1_t thread )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("int rc;");
T_b("\n");
T_b("  ");
T_b("void * vp = 0;");
T_b("\n");
T_b("  ");
T_b("pthread_cond_t * dwc = &nonbusy_wait_cond[ thread ];");
T_b("\n");
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_NONBUSY );");
T_b("\n");
if ( te_sys->MaxTimers > 0 ) {
T_b("  ");
T_b("if ( thread == 0 ) {");
T_b("\n");
T_b("    ");
T_b("struct timespec ts;");
T_b("\n");
T_b("    ");
T_b("vp = TIM_duration_until_next_timer_pop( ( void * ) &ts );");
T_b("\n");
T_b("    ");
T_b("if ( vp != 0 ) {");
T_b("\n");
T_b("      ");
T_b("rc = pthread_cond_timedwait(");
T_b("\n");
T_b("        ");
T_b("dwc, &mutices[ SEMAPHORE_FLAVOR_NONBUSY ], &ts );");
T_b("\n");
T_b("    ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
}
T_b("  ");
T_b("if ( ( thread != 0 ) || ( vp == 0 ) ) {");
T_b("\n");
T_b("    ");
T_b("rc = pthread_cond_wait( dwc, &mutices[ SEMAPHORE_FLAVOR_NONBUSY ] );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_NONBUSY );");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Wake up a thread that went to sleep waiting for something to happen.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->nonbusy_wake);
T_b("( const u1_t thread )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("int rc;");
T_b("\n");
T_b("  ");
T_b("pthread_cond_t * dwc = &nonbusy_wait_cond[ thread ];");
T_b("\n");
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_NONBUSY );");
T_b("\n");
T_b("  ");
T_b("rc = pthread_cond_broadcast( dwc );");
T_b("\n");
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_NONBUSY );");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Create and spin off a task/thread to run the input routine.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->create);
T_b("( void *(routine)(void *), const u1_t i )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("static pthread_t pthread[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("  ");
T_b("int rc = pthread_create( &pthread[ i - 1 ], 0, routine, &threadnumber[ i ] );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Cleanup the structures initialized in ");
T_b(te_prefix->result);
T_b("InitializeThreading.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->shutdown);
T_b("( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t i;");
T_b("\n");
T_b("  ");
T_b("int rc;");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < NUM_OF_TOTAL_THREADS; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = pthread_cond_destroy( &nonbusy_wait_cond[ i ] );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < SEMAPHORE_FLAVOR_MAX; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = pthread_mutex_destroy( &mutices[ i ] );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("}");
T_b("\n");
