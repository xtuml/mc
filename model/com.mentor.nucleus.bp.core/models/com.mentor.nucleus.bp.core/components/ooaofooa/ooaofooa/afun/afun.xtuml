-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'afun',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("0621fcb5-c026-4d92-93b3-509f2bbbfd38",
	112,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'4.0.0',
	'com.mentor.nucleus.bp.core::components::ooaofooa::ooaofooa::afun');
INSERT INTO DIM_DIA
	VALUES ("0621fcb5-c026-4d92-93b3-509f2bbbfd38",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("17b26926-9233-4f3b-bf40-b2ba7a6e61f2",
	"00000000-0000-0000-0000-000000000000",
	'a0',
	'',
	'::parm_sort();
::rel_pseudoformalize();
::sys_singletons();

// These are markings that are for the model-based MC.
select any stringpointer_s_dt from instances of S_DT where ( selected.Name == "stringpointer" );
if ( not_empty stringpointer_s_dt )
  select many o_attrs from instances of O_ATTR where ( ( selected.Name == "Action_Semantics_internal" ) or ( selected.Name == "Descrip" ) );
  for each o_attr in o_attrs
    select one s_dt related by o_attr->S_DT[R114];
    unrelate o_attr from s_dt across R114;
    // o_attr.DT_ID = 00
    relate o_attr to stringpointer_s_dt across R114;
    // o_attr.DT_ID = s_dt.DT_ID
  end for;
  ::MapDataTypeAsPointer( component_name:"*", dt_name:"stringpointer", pointer_type:"c_t", include_file:"" );
end if;

::sys_populate();

select any te_sys from instances of TE_SYS;
::sys_analyze( te_sys:te_sys );
::CreateSpecialWhereClauseInstances( te_sys:te_sys );

select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Propagate domain information to the system level.
  ::te_c_CollectLimits( te_c:te_c );
  select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
  c = ::class_sort( te_classs:te_classs );
end for;

::val_translate();
::oal_translate();
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("17b26926-9233-4f3b-bf40-b2ba7a6e61f2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c97282a5-4cce-4b8b-b968-c8e44c6dcb62",
	"00000000-0000-0000-0000-000000000000",
	'AutoInitializeUniqueIDs',
	'',
	'//============================================================================
// $RCSfile: frag_util.arc,v $
//
// Description:
// This archetype file provides general purpose functions used during 
// action language translation. They are not specific to any particular
// fragment generator entry points.
//============================================================================
//
//============================================================================
// Initialize the attributes of type unique_id that are identifiers
// and therefore need to be automatically set up at create time.
//============================================================================
te_class = param.te_class;
instance = param.instance;
//
::oal( s:"T_clear();" );
select any te_file from instances of TE_FILE;
select any te_instance from instances of TE_INSTANCE;
select any te_string from instances of TE_STRING;
select any te_sys from instances of TE_SYS;
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  select one o_attr related by te_attr->O_ATTR[R2033];
  if ( te_attr.translate )
    r = ::GetAttributeCodeGenType( o_attr:o_attr );
    te_dt = r;
    not_empty_o_oida = false;
    if ( not_empty te_dt )
      if ( 5 == te_dt.Core_Typ )
        select any o_oida related by o_attr->O_OIDA[R105];
        if ( not_empty o_oida )
          not_empty_o_oida = true;
        end if;
      end if;
      T::include(file:"c/t.class.attribute.init.c");
    end if;
  end if;
  //
  // Advance to the next object attribute, if any.
  select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
end while;
return T::body();
',
	"ba5eda7a-def5-0000-0000-000000000004",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("a6718cba-0b4b-4f5c-8a1c-80f606e928b4",
	"c97282a5-4cce-4b8b-b968-c8e44c6dcb62",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f975acb7-4246-4a87-9c5a-75481f096785",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Class>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("c06ec8e7-a859-4e9c-979c-b7eb471feed7",
	"c97282a5-4cce-4b8b-b968-c8e44c6dcb62",
	'instance',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a6718cba-0b4b-4f5c-8a1c-80f606e928b4",
	'');
INSERT INTO PE_PE
	VALUES ("c97282a5-4cce-4b8b-b968-c8e44c6dcb62",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f0534f28-a84b-45ed-99fc-7905f8c0f848",
	"00000000-0000-0000-0000-000000000000",
	'ExpandNonOptimizedSpecialWhereComparison',
	'',
	'//
//============================================================================
o_obj = param.o_obj;
special = param.special;
selected_var_name = param.selected_var_name;
//
compare_stmt = "";
if ( special )
  select any te_instance from instances of TE_INSTANCE;
  select any te_string from instances of TE_STRING;
  compare_stmt = "";
  cmp_element = "";
  select one te_class related by o_obj->TE_CLASS[R2019];
  // Be sure we have the first attribute in the class.
  select any first_te_attr related by te_class->TE_ATTR[R2061];
  while ( not_empty first_te_attr )
    select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
    if ( empty prev_te_attr )
      break;
    end if;
    first_te_attr = prev_te_attr;
  end while;
  te_attr = first_te_attr;
  while ( not_empty te_attr )
    //.if ( 4 == te_attr.Core_Typ )
    if ( 4 == 4 )
      cmp_element = "!${te_instance.module}${te_string.strcmp}(${selected_var_name}->${te_attr.GeneratedName}, ${te_attr.ParamBuffer})";
    else
      cmp_element = "${selected_var_name}->${te_attr.GeneratedName} == ${te_attr.ParamBuffer}";
    end if;
    compare_stmt = compare_stmt + cmp_element;
    // Advance to the next object attribute, if any.
    select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
    if ( not_empty te_attr )
      compare_stmt = compare_stmt + " && ";
    end if;
  end while;
end if;
return compare_stmt;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("a22bd648-1f1a-4272-a9bc-4d29731dd336",
	"f0534f28-a84b-45ed-99fc-7905f8c0f848",
	'o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SPARM
	VALUES ("def354f7-e36d-4098-84b8-4c59320df2ca",
	"f0534f28-a84b-45ed-99fc-7905f8c0f848",
	'special',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"a22bd648-1f1a-4272-a9bc-4d29731dd336",
	'');
INSERT INTO S_SPARM
	VALUES ("69e0675f-03e5-446d-befd-1134901c3adf",
	"f0534f28-a84b-45ed-99fc-7905f8c0f848",
	'selected_var_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"def354f7-e36d-4098-84b8-4c59320df2ca",
	'');
INSERT INTO PE_PE
	VALUES ("f0534f28-a84b-45ed-99fc-7905f8c0f848",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bdfd5866-5127-4294-b8d2-c0dcd76d5839",
	"00000000-0000-0000-0000-000000000000",
	'CreateSpecialWhereComparisonArguments',
	'',
	'//
//============================================================================
te_class = param.te_class;
o_id = param.o_id;
//
select many o_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105];
num_ident_attr = cardinality o_attrs;
//
param_list = "";
oida_count = 0;
//
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  if ( te_attr.Included )
    oida_count = oida_count + 1;
    param_list = param_list + te_attr.ParamBuffer;
    if ( oida_count < num_ident_attr )
      param_list = param_list + ", ";
    end if;
  end if;
  select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
end while;
//
return param_list;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("3a3a4027-da5b-420c-a3c7-82a0528b0e7a",
	"bdfd5866-5127-4294-b8d2-c0dcd76d5839",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("3c46d87a-c6a1-4c5d-bc50-fa2e59db5376",
	"bdfd5866-5127-4294-b8d2-c0dcd76d5839",
	'o_id',
	"65d0a895-bf6c-48fa-ba74-80985a75698b",
	0,
	'',
	"3a3a4027-da5b-420c-a3c7-82a0528b0e7a",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("65d0a895-bf6c-48fa-ba74-80985a75698b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class Identifier>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("bdfd5866-5127-4294-b8d2-c0dcd76d5839",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("702d79a8-9810-4e7c-83af-a367fc96884f",
	"00000000-0000-0000-0000-000000000000",
	'oal',
	'',
	'//
s = param.s;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("2f547cc5-0c57-4975-9553-528b82f36485",
	"702d79a8-9810-4e7c-83af-a367fc96884f",
	's',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("702d79a8-9810-4e7c-83af-a367fc96884f",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9de29a01-7414-4fd2-9e55-0529a8b581ee",
	"00000000-0000-0000-0000-000000000000",
	'GetBaseTypeForUDT',
	'',
	'//============================================================================
// Recursively locate the datatype at the base of the UDT type definition 
// chain. Traverses up through UDTs based on UDTs until we find the underlying
// S_DT instance (which may actually be EDT, SDT, IRDT or CDT).
//============================================================================
s_udt = param.s_udt;
select one s_dt related by s_udt->S_DT[R18];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
return s_dt;
',
	"3f421b34-9cdd-4a99-947a-7224e3b97776",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("025bfd69-e92c-4d60-b547-a0d38c178259",
	"9de29a01-7414-4fd2-9e55-0529a8b581ee",
	's_udt',
	"fbb3cc5a-c0d2-405d-a9fd-46fcd925a160",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fbb3cc5a-c0d2-405d-a9fd-46fcd925a160",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<User Data Type>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("9de29a01-7414-4fd2-9e55-0529a8b581ee",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("3f421b34-9cdd-4a99-947a-7224e3b97776",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SYNC
	VALUES ("ca588f02-462f-49c3-a01f-68aa0a2a0813",
	"00000000-0000-0000-0000-000000000000",
	'GetAttributeCodeGenType',
	'',
	'//
//============================================================================
//   Get the S_DT and S_CDT object references for a given attribute
//   (O_ATTR) instance.
//============================================================================
o_attr = param.o_attr;
//
select one s_dt related by o_attr->S_DT[R114];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
select one te_dt related by s_dt->TE_DT[R2021];
select one s_cdt related by s_dt->S_CDT[R17];
//
if ( empty s_cdt )
  select one s_edt related by s_dt->S_EDT[R17];
  if ( empty s_edt )
    select one s_sdt related by s_dt->S_SDT[R17];
    if ( empty s_sdt )
      select one s_irdt related by s_dt->S_IRDT[R17];
      if ( empty s_irdt )
        T::print(s:"Error in attribute ${o_attr.Name}");
        T::print(s:"with data type ${s_dt.Name}");
        T::exit(i:100);
      end if;
    end if;
  else
    // Enum, use integer type.
    // CDS Some day we should pass along the enumeration type.
    select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
  end if;
end if;
//
if ( not_empty s_cdt )
  if ( 7 == s_cdt.Core_Typ )
    // s_cdt.Core_Typ is "same_as<Base_Attribute>"
    select one base_o_attr related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106];
    if ( empty base_o_attr )
      select one o_obj related by o_attr->O_OBJ[R102];
      T::print(s:"\nCould not find O_BATTR for object ${o_obj.Name} (${o_obj.Key_Lett}) attribute ${o_attr.Name} !");
      T::print(s:"\nDid you combine a referential and then rename the combined attribute?");
      T::exit(i:101);
    end if;
    // Note: the following is a recursive call to this function
    r = ::GetAttributeCodeGenType( o_attr:base_o_attr );
    te_dt = r;
  end if;
end if;
return te_dt;
',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("53e38919-698c-4304-8352-3c343760700f",
	"ca588f02-462f-49c3-a01f-68aa0a2a0813",
	'o_attr',
	"f597d699-ee8c-4635-9196-5082b710160d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f597d699-ee8c-4635-9196-5082b710160d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("ca588f02-462f-49c3-a01f-68aa0a2a0813",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("5b20f7fb-179b-4254-a8de-922a50a1225d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Data Type>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("5d02ed60-0a8b-44f8-98fa-88c4ed91b71b",
	"00000000-0000-0000-0000-000000000000",
	'MapUserSpecifiedDataTypePrecision',
	'',
	'//
//============================================================================
// Map a user defined data types precision into its corresponding instance
// of Data Type (S_DT).
// Note:  Might prefer POSIX type support here, but doubt we can count
// on most embedded targets thinking this way.  Thus brute force the types.
//============================================================================
te_dt = param.te_dt;
mapping = param.mapping;
error = false;
type = mapping;
if ( ( type == "uchar_t" ) or ( ( type == "u_char" ) or ( type == "unsignedchar" ) ) )
  te_dt.ExtName = "unsigned char";
elif ( ( type == "char_t" ) or ( type == "char" ) )
  te_dt.ExtName = "char";
elif ( type == "signedchar" )
  te_dt.ExtName = "signed char";
elif ( ( type == "ushort_t" ) or ( ( type == "u_short" ) or ( type == "unsignedshort" ) ) )
  te_dt.ExtName = "unsigned short";
elif ( ( type == "short_t" ) or ( type == "short" ) )
  te_dt.ExtName = "short";
elif ( type == "signedshort" )
  te_dt.ExtName = "signed short";
elif ( ( type == "uint_t" ) or ( ( type == "u_int" ) or ( type == "unsignedint" ) ) )
  te_dt.ExtName = "unsigned int";
elif ( type == "s1_t" )
  te_dt.ExtName = "s1_t";
elif ( type == "u1_t" )
  te_dt.ExtName = "u1_t";
elif ( type == "s2_t" )
  te_dt.ExtName = "s2_t";
elif ( type == "u2_t" )
  te_dt.ExtName = "u2_t";
elif ( type == "s4_t" )
  te_dt.ExtName = "s4_t";
elif ( type == "u4_t" )
  te_dt.ExtName = "u4_t";
elif ( type == "i_t" )
  te_dt.ExtName = "i_t";
elif ( ( type == "int_t" ) or ( type == "int" ) )
  te_dt.ExtName = "int";
elif ( type == "signedint" )
  te_dt.ExtName = "signed int";
elif ( ( type == "ulong_t" ) or ( ( type == "u_long" ) or ( type == "unsignedlong" ) ) )
  te_dt.ExtName = "unsigned long";
elif ( ( type == "long_t" ) or ( type == "long" ) )
  te_dt.ExtName = "long";
elif ( type == "signedlong" )
  te_dt.ExtName = "signed long";
elif ( ( type == "u_longlong_t" ) or ( ( type == "u_longlong_t" ) or ( type == "unsignedlonglong" ) ) )
  te_dt.ExtName = "unsigned long long";
elif ( ( type == "longlong_t" ) or ( ( type == "longlong" ) or ( type == "signedlonglong" ) ) )
  te_dt.ExtName = "long long";
  //
elif ( type == "float" )
  te_dt.ExtName = "float";
elif ( type == "r4_t" )
  te_dt.ExtName = "r4_t";
elif ( type == "double" )
  te_dt.ExtName = "double";
elif ( type == "r8_t" )
  te_dt.ExtName = "r8_t";
  //
elif ( type == "size_t" )
  te_dt.ExtName = "size_t";
elif ( type == "ssize_t" )
  te_dt.ExtName = "ssize_t";
elif ( type == "time_t" )
  te_dt.ExtName = "time_t";
elif ( type == "clock_t" )
  te_dt.ExtName = "clock_t";
elif ( type == "volatile_clock_t" )
  te_dt.ExtName = "volatile unsigned long";
  //
else
  error = true;
end if;
return error;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("c1367499-fcf0-45d3-a4a9-f4c89ee3b7b9",
	"5d02ed60-0a8b-44f8-98fa-88c4ed91b71b",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("1afb70e4-f9e7-4dc0-a75f-4d0ef6dc173b",
	"5d02ed60-0a8b-44f8-98fa-88c4ed91b71b",
	'mapping',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c1367499-fcf0-45d3-a4a9-f4c89ee3b7b9",
	'');
INSERT INTO PE_PE
	VALUES ("5d02ed60-0a8b-44f8-98fa-88c4ed91b71b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("30a2dd58-728c-484d-aed0-cc8cfa1109ec",
	"00000000-0000-0000-0000-000000000000",
	'UserSuppliedDataTypeIncludes',
	'',
	'//
// Return the structure type for persistent links.
select any te_file from instances of TE_FILE;
sys_types_file_name = ( te_file.types + "." ) + te_file.hdr_file_ext;
select many special_te_dts from instances of TE_DT where ( ( selected.Include_File != "" ) and ( selected.Include_File != sys_types_file_name ) );
s = "";
for each special_te_dt in special_te_dts
  s = ( s + "#include " ) + ( special_te_dt.Include_File + "\n" );
  ::oal( s:"s = Escher_strcpy( s, Escher_stradd( Escher_stradd( s, #include  ), Escher_stradd( special_te_dt->Include_File, \n ) ) ); // Ccode" );
end for;
return s;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("30a2dd58-728c-484d-aed0-cc8cfa1109ec",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("564db6a0-acaf-4f59-9ee2-dbe7267e10ae",
	"00000000-0000-0000-0000-000000000000",
	'sys_analyze',
	'',
	'//============================================================================
// This query file provides the "first pass" of a multi-pass translation
// model compiler.  The first pass analyzes the action semantics embodied
// in the analysis domain, and applies optimization algorithms to the
// action language statements encountered.  The results of these algorithmic
// operations are then leveraged by subsequent passes of the structural
// queries and templates to realize time/space/performance trade offs in
// the generated application code.
//============================================================================
//
//
te_sys = param.te_sys;
T::print(s:"Analyzing model and making optimizations....");
// Identify state models having at least one state, event and transition.
::SM_SM_mark_valid();
// Count up how many times each event is created/generated.
::event_smt_used();
// Find classes that are created in some way and identify invalid creates.
::class_smt_created();
// Detect invalid deletions.
::class_smt_deleted();
// Track down optimizable where clauses.
::selection_whereclause_identify_special();
// Identify the associations that need link and/or unlink methods.
::association_mark_link_unlink_needed();
// Identify associations that are navigated (in either or both directions).
::association_R_OIR_mark_navigated();
// Find which event queues are necessary.
::event_queue_analyze_needed();
::attr_analyze_accesses();
//.invoke attr_analyze_codegen( te_sys )
::TE_TXN_used();
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("743da1a5-5a17-4128-aede-797a1a5d1599",
	"564db6a0-acaf-4f59-9ee2-dbe7267e10ae",
	'te_sys',
	"195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended System>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("564db6a0-acaf-4f59-9ee2-dbe7267e10ae",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("94e0ed2d-eb99-4ab6-9236-5f4d023db788",
	"00000000-0000-0000-0000-000000000000",
	'te_c_CollectLimits',
	'',
	'//============================================================================
// These queries collect static analysis information and propagate it
// forward to the system build step by outputting a set of INSERT
// statements that will populate the system build gen database.
//============================================================================
//
//
//============================================================================
// Store statistics into TE_C.
//============================================================================
te_c = param.te_c;
//
select any te_file from instances of TE_FILE;
//
// Analyze maximums for extents.
// The extents should be analyzed only *after* extent size coloring!
select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
object_class_extents = 0;
relationship_extents = 0;
largest_object_extent = 0;
//
for each te_class in te_classs
  select one o_obj related by te_class->O_OBJ[R2019];
  object_class_extents = object_class_extents + te_class.MaxExtentSize;
  if ( te_class.MaxExtentSize > largest_object_extent )
    largest_object_extent = te_class.MaxExtentSize;
  end if;
  // Calculate maximum extents required for objects on "MANY" side of a relationship.
  select many r_rgos related by o_obj->R_OIR[R201]->R_RGO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rgo in r_rgos
    select one form related by r_rgo->R_FORM[R205];
    if ( not_empty form )
      if ( form.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one assr related by r_rgo->R_ASSR[R205];
    if ( not_empty assr )
      if ( assr.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
  select many r_rtos related by o_obj->R_OIR[R201]->R_RTO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rto in r_rtos
    select one aone related by r_rto->R_AONE[R204];
    if ( not_empty aone )
      if ( aone.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one aoth related by r_rto->R_AOTH[R204];
    if ( not_empty aoth )
      if ( aoth.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
end for;
//
// analyze timers events selects
r = ::timer_analyze_starts();
total_timer_starts = r;
//
// Count up the event specification statements which is the supertype
// of generated and deferred events.  This will give us a starting point
// on allocating event queue resources.
// CDS - We are (re)counting the events for each component, but this code is not component-specific.
// CDS - The event counts should be "harvested" while processing the action language.
max_events = 0;
max_self_events = 0;
max_nonself_events = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many event_specification_statements related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->E_ESS[R603];
  all_events_count = cardinality event_specification_statements;
  select many act_sgns related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->ACT_SGN[R603];
  all_events_count = all_events_count + ( cardinality act_sgns );
  if ( all_events_count > max_events )
    max_events = all_events_count;
  end if;
  // Count up the self events in this body.
  count = 0;
  for each e_ess in event_specification_statements
    select one v_var related by e_ess->E_GES[R701]->E_GSME[R703]->E_GEN[R705]->V_VAR[R712] where ( "self" == T::l(s:selected.Name) );
    if ( not_empty v_var )
      count = count + 1;
    else
      select any v_var related by event_specification_statements->E_CES[R701]->E_CSME[R702]->E_CEI[R704]->V_VAR[R711] where ( "self" == T::l(s:selected.Name) );
      if ( not_empty v_var )
        count = count + 1;
      end if;
    end if;
  end for;
  if ( count > max_self_events )
    max_self_events = count;
  end if;
  count = all_events_count - count;
  if ( count > max_nonself_events )
    max_nonself_events = count;
  end if;
  select one te_aba related by act_act->ACT_FNB[R698]->S_SYNC[R695]->TE_SYNC[R2023]->TE_ABA[R2010];
  if ( not_empty te_aba )
    te_aba.NonSelfEventCount = count;
  end if;
end for;
//
r = ::containoid_select_many_count();
max_select_many = r;
//
// functions
select many te_syncs related by te_c->TE_SYNC[R2084] where ( ( selected.IsSafeForInterrupts ) and ( selected.XlateSemantics ) );
total_interleaved_bridges = cardinality te_syncs;
//
// Count up the priority events.
select many te_evts from instances of TE_EVT where ( selected.Priority != 0 );
total_priority_events = cardinality te_evts;
//
// Count up the classes using preexisting instances defined in data (PEIs).
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.PEIsDefinedInData ) );
pei_class_count = cardinality te_classs;
//
// Count up the persistent classes.
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.Persistent ) );
persist_class_count = cardinality te_classs;
//
te_c.MaxObjExtent = object_class_extents;
te_c.MaxRelExtent = relationship_extents;
te_c.MaxSelectExtent = max_select_many * largest_object_extent;
te_c.MaxSelfEvents = max_self_events;
te_c.MaxNonSelfEvents = max_nonself_events;
te_c.MaxPriorityEvents = total_priority_events;
te_c.MaxTimers = total_timer_starts;
te_c.InterleavedBridges = total_interleaved_bridges;
te_c.PEIClassCount = pei_class_count;
te_c.PersistentClassCount = persist_class_count;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("d6e42134-7238-4eaa-ba10-994242eb954f",
	"94e0ed2d-eb99-4ab6-9236-5f4d023db788",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Component>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("94e0ed2d-eb99-4ab6-9236-5f4d023db788",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c126948e-6d99-4194-8a8a-af20f65e2bf2",
	"00000000-0000-0000-0000-000000000000",
	'selection_whereclause_identify_special',
	'',
	'//============================================================================
// The query/transformations in this file analyze the action language
// of the customer model and gather statistics for use in optimized
// code generation.
//============================================================================
//
//
//
// Identify (special) where clauses that can be optimized.
//
// Select the class from which extent we are selecting.
//  Mark its identifying attributes.
// Select the blind select statements having where clauses.
// Select the values that represent the where clauses that
// are binary expressions where the operator is == or AND.
// BUG:  R676 and R677 should be unconditional on the O_OBJ side.
// Select the V_SLRs and their attributes.
// Compare the two sets.
//
select many act_fiws from instances of ACT_FIW;
for each act_fiw in act_fiws
  select one v_bin related by act_fiw->V_VAL[R610]->V_BIN[R801] where ( ( selected.Operator == "and" ) or ( selected.Operator == "==" ) );
  if ( not_empty v_bin )
    select one o_obj related by act_fiw->O_OBJ[R676];
    // Select the TE_WHEREs, because we can check to see if we have
    // already marked a special where.
    select many te_wheres related by o_obj->O_ID[R104]->TE_WHERE[R2032] where ( not selected.WhereKey );
    if ( not_empty te_wheres )
      // Clear out the included flag on all attributes of this class.
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      // Call a routine that will recursively drill down and mark any
      // attributes compared in the where clause.
      ::where_clause_mark_selected_attributes( v_bin:v_bin );
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033] where ( selected.Included );
      if ( not_empty te_attrs )
        for each te_where in te_wheres
          select many identifying_te_attrs related by te_where->O_ID[R2032]->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
          if ( te_attrs == identifying_te_attrs )
            T::print(s:"marking SPECIAL where on ${o_obj.Key_Lett}:${o_obj.Name}");
            te_where.WhereKey = true;
          end if;
        end for;
      end if;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("c126948e-6d99-4194-8a8a-af20f65e2bf2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e7b965e1-6815-4b42-bbed-8c234cfd56b9",
	"00000000-0000-0000-0000-000000000000",
	'where_clause_mark_selected_attributes',
	'',
	'//
//
// Recursively drill down into the where clause expression marking
// selected attributes along the way.
//
v_bin = param.v_bin;
if ( v_bin.Operator == "and" )
  select one left_v_val related by v_bin->V_VAL[R802];
  select one right_v_val related by v_bin->V_VAL[R803];
  select one v_bin related by left_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
  select one v_bin related by right_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
elif ( v_bin.Operator == "==" )
  select one te_attr related by v_bin->V_VAL[R802]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
  select one te_attr related by v_bin->V_VAL[R803]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
else
  // allow return
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("ccb91e49-bacd-4544-abb9-b72d3afeb0a1",
	"e7b965e1-6815-4b42-bbed-8c234cfd56b9",
	'v_bin',
	"a6e95352-7701-470f-a154-2a42ea44c24d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a6e95352-7701-470f-a154-2a42ea44c24d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Binary Operation>',
	'',
	'',
	'../Value/Value.xtuml');
INSERT INTO PE_PE
	VALUES ("e7b965e1-6815-4b42-bbed-8c234cfd56b9",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("74835c7d-d91e-48e7-b23e-b21cf0c0998c",
	"00000000-0000-0000-0000-000000000000",
	'SM_SM_mark_valid',
	'',
	'//
//
// Find valid state machines and mark them thusly.
// Such state machines have at least one each of state, event and transition.
//
// Select only the state machines that have been configured for generation.
select many te_sms from instances of TE_SM;
for each te_sm in te_sms
  select one sm_sm related by te_sm->SM_SM[R2043];
  select any sm_state related by sm_sm->SM_STATE[R501];
  if ( not_empty sm_state )
    select any sm_txn related by sm_sm->SM_TXN[R505];
    if ( not_empty sm_txn )
      select any sm_evt related by sm_sm->SM_EVT[R502];
      if ( not_empty sm_evt )
        te_sm.complete = true;
      end if;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("74835c7d-d91e-48e7-b23e-b21cf0c0998c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c429c5c1-bda3-49a9-8b16-705aa957f466",
	"00000000-0000-0000-0000-000000000000",
	'TE_TXN_used',
	'',
	'//
//
// Update the size of SEM cells when transition actions are present.
//
select any te_sm from instances of TE_SM where ( selected.txn_action_count > 0 );
if ( not_empty te_sm )
  select any te_typemap from instances of TE_TYPEMAP;
  te_typemap.SEM_cell_type = "u2_t";
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("c429c5c1-bda3-49a9-8b16-705aa957f466",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ca8d9feb-a26e-429e-a97d-097e2a4b4eef",
	"00000000-0000-0000-0000-000000000000",
	'event_smt_used',
	'',
	'//
//
// Find and mark/count events that are used in action language.
// Even though we store the information in a count, this query
// only counts each event once.
//
select many e_gsmes from instances of E_GSME;
select many te_evts related by e_gsmes->SM_EVT[R707]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
select many e_csmes from instances of E_CSME;
select many te_evts related by e_csmes->SM_EVT[R706]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
// Mark all of the signals (inter-component class-based events) as used.
select many sm_sgevts from instances of SM_SGEVT;
select many te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("ca8d9feb-a26e-429e-a97d-097e2a4b4eef",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2dbefb2c-1b55-4fbc-a974-59fa71fd5cc8",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_created',
	'',
	'//
//
// Mark classes that are created synchronously (nonself) or
// asynchronously (self).
//
select many act_crs from instances of ACT_CR;
select many te_classs related by act_crs->O_OBJ[R671]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
select many act_cnvs from instances of ACT_CNV;
select many te_classs related by act_cnvs->O_OBJ[R672]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
// Now find any creator events to classes.
select many e_gecs from instances of E_GEC;
select many te_classs related by e_gecs->E_GSME[R705]->SM_EVT[R707]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.SelfCreated = true;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("2dbefb2c-1b55-4fbc-a974-59fa71fd5cc8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d4311d32-e2c5-4a86-bdc3-e7faaf4ce9f1",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_deleted',
	'',
	'//
//
// Check for classes that are deleted synchronously and should not be.
//
select many act_dels from instances of ACT_DEL;
select many te_classs related by act_dels->V_VAR[R634]->V_INT[R814]->O_OBJ[R818]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("d4311d32-e2c5-4a86-bdc3-e7faaf4ce9f1",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("84c570a2-e67e-4571-8e1a-0b3bbb956649",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_crdel_check',
	'',
	'//
te_classs = param.te_classs;
for each te_class in te_classs
  if ( te_class.IsReadOnly )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete read-only object ${o_obj.Name} (${o_obj.Key_Lett})");
  end if;
  if ( te_class.IsFixedPopulation )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete object ${o_obj.Name} (${o_obj.Key_Lett}) within static instance population.");
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("22b8091c-c11b-40df-8f30-02e0cfa190f8",
	"84c570a2-e67e-4571-8e1a-0b3bbb956649",
	'te_classs',
	"54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Class>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("84c570a2-e67e-4571-8e1a-0b3bbb956649",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4658d148-7e4a-460b-b9f4-8a789413a995",
	"00000000-0000-0000-0000-000000000000",
	'event_queue_analyze_needed',
	'',
	'//
// Count up all the places that events are either generated directly (E_GEN)
// or where they are created for deferred generation (E_CEI).
// Also count up the self versus nonself events.
//
self_queue_needed = false;
nonself_queue_needed = false;
select many e_gens from instances of E_GEN;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name == "self" );
if ( not_empty v_var )
  self_queue_needed = true;
end if;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name != "self" );
if ( not_empty v_var )
  nonself_queue_needed = true;
end if;
if ( not ( self_queue_needed and nonself_queue_needed ) )
  select many e_ceis from instances of E_CEI;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name == "self" );
  if ( not_empty v_var )
    self_queue_needed = true;
  end if;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name != "self" );
  if ( not_empty v_var )
    nonself_queue_needed = true;
  end if;
end if;
if ( self_queue_needed )
  T::print(s:"Self event queue needed.");
end if;
if ( nonself_queue_needed )
  T::print(s:"Instance event queue needed.");
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("4658d148-7e4a-460b-b9f4-8a789413a995",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b028906c-e28e-458e-985a-842cc5ccb3d4",
	"00000000-0000-0000-0000-000000000000",
	'attr_analyze_accesses',
	'',
	'//
//
// Analyze and mark the attributes of the customer model to flag which
// attributes are read and/or written.  We will use this information
// later to optimize out member data access code that is not needed.
// Also, mark attributes participating as identifiers as used.
// Mark written, read and Used attributes to TE_ATTR.
//
attributes_read_count = 0;
attributes_written_count = 0;
//
// Select all the attribute values references.
// Cycle through them marking their associated attributes as being read.
// Then, see if they are written by determining whether they participate
// as an lval in an assignment.
// Note, there can be several V_AVLs for each O_ATTR.
//
select many te_attrs from instances of TE_ATTR;
for each te_attr in te_attrs
  select many v_avls related by te_attr->O_ATTR[R2033]->V_AVL[R806];
  if ( not_empty v_avls )
    if ( not te_attr.read )
      attributes_read_count = attributes_read_count + 1;
    end if;
    te_attr.read = true;
    te_attr.Used = true;
  end if;
  // attributes written
  select any act_ai related by v_avls->V_VAL[R801]->ACT_AI[R689];
  if ( not_empty act_ai )
    if ( not te_attr.written )
      attributes_written_count = attributes_written_count + 1;
      select one te_class related by te_attr->TE_CLASS[R2061];
      if ( te_class.IsReadOnly )
        T::print(s:"ERROR:  Attempt to write to read-only object ${te_class.Name} (${te_class.Key_Lett}).");
      end if;
    end if;
    te_attr.written = true;
  end if;
end for;
// Identifying attributes are copied across in RELATE statements
// even if they are never read or written.
select many o_oidas from instances of O_OIDA;
select many te_attrs related by o_oidas->O_ATTR[R105]->TE_ATTR[R2033];
for each te_attr in te_attrs
  te_attr.Used = true;
end for;
msg = T::s(i:attributes_read_count) + " attributes read";
T::print(s:"${msg}");
msg = T::s(i:attributes_written_count) + " attributes written";
T::print(s:"${msg}");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("b028906c-e28e-458e-985a-842cc5ccb3d4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("954799d1-01f5-4c01-8909-b1f5d2f213b8",
	"00000000-0000-0000-0000-000000000000",
	'attr_analyze_codegen',
	'',
	'//
//
// Mark attributes that are not used, needed and should be optimized out.
//
te_sys = param.te_sys;
optimized_out_count = 0;
select many te_cs from instances of TE_C where ( not selected.OptDisabled );
select many te_attrs related by te_cs->TE_CLASS[R2064]->TE_ATTR[R2061];
for each te_attr in te_attrs
  select one o_attr related by te_attr->O_ATTR[R2033];
  // Do not translate current_state attributes.
  select one s_cdt related by o_attr->S_DT[R114]->S_CDT[R17] where ( selected.Core_Typ == 6 );
  if ( not_empty s_cdt )
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  end if;
  if ( not te_attr.Used )
    // not accessed?
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  else
    // referential attribute?
    select one o_rattr related by o_attr->O_RATTR[R106];
    if ( not_empty o_rattr )
      // Is referential not also an identifying attribute?
      select any o_oida related by o_attr->O_OIDA[R105] where ( selected.Attr_ID == o_rattr.Attr_ID );
      if ( ( empty o_oida ) and ( not te_attr.Used ) )
        if ( not te_sys.InstanceLoading )
          te_attr.translate = false;
          optimized_out_count = optimized_out_count + 1;
        end if;
      end if;
    end if;
  end if;
end for;
msg = T::s(i:optimized_out_count) + " attributes optimized out";
T::print(s:"${msg}");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("7f5531a5-965a-47b2-bb95-a75595d9b3cc",
	"954799d1-01f5-4c01-8909-b1f5d2f213b8",
	'te_sys',
	"195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("954799d1-01f5-4c01-8909-b1f5d2f213b8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6027860f-314c-49c6-90d7-633b13d8a380",
	"00000000-0000-0000-0000-000000000000",
	'association_R_OIR_mark_navigated',
	'',
	'//
//
// Here we mark which classes are navigated across associations in each
// direction, from the formalizer or from the participant.  The results
// are stored in instances linked to instances of R_OIR (TE_OIR).
//
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  select any r_oir related by act_lnk->R_REL[R681]->R_OIR[R201] where ( selected.Obj_ID == act_lnk.Obj_ID );
  select one te_oir related by r_oir->TE_OIR[R2035];
  if ( not_empty te_oir )
    te_oir.NavigatedTo = true;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("6027860f-314c-49c6-90d7-633b13d8a380",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("31f05994-7d71-4f14-816f-ea0c618c3f6a",
	"00000000-0000-0000-0000-000000000000",
	'association_mark_link_unlink_needed',
	'',
	'//
//
// Select all of the association instances and mark the ones that
// actually get linked with the relate/unrelate OAL statements.
//
// Mark all navigation (across a particular association).
// Mark all assocations that get navigated.
//
select many te_rels from instances of TE_REL;
select many r_rels related by te_rels->R_REL[R2034];
for each r_rel in r_rels
  link_needed = false;
  unlink_needed = false;
  navigated = false;
  // Check if navigated.
  select any act_lnk related by r_rel->ACT_LNK[R681];
  if ( not_empty act_lnk )
    navigated = true;
  end if;
  // Check if related.
  select any act_rel related by r_rel->ACT_REL[R653];
  if ( not_empty act_rel )
    link_needed = true;
  else
    select any act_ru related by r_rel->ACT_RU[R654];
    if ( not_empty act_ru )
      link_needed = true;
    end if;
  end if;
  // Check if unrelated.
  select any act_unr related by r_rel->ACT_UNR[R655];
  if ( not_empty act_unr )
    unlink_needed = true;
  else
    select any act_uru related by r_rel->ACT_URU[R656];
    if ( not_empty act_uru )
      unlink_needed = true;
    end if;
  end if;
  // Apply results to TE_REL.
  if ( ( link_needed or unlink_needed ) or navigated )
    select one te_rel related by r_rel->TE_REL[R2034];
    if ( navigated )
      te_rel.Navigated = true;
    end if;
    if ( link_needed )
      te_rel.LinkNeeded = true;
    end if;
    if ( unlink_needed )
      te_rel.UnlinkNeeded = true;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("31f05994-7d71-4f14-816f-ea0c618c3f6a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("de950578-7973-46aa-8cf8-0cb23dc07b22",
	"00000000-0000-0000-0000-000000000000",
	'containoid_select_many_count',
	'',
	'//============================================================================
// Utility functions specifically for OAL analysis.
//============================================================================
//
//
//
// Find the maximum number of "select many" statements expressed in
// one action body.  We will use this number to estimate the container
// pool.
// CDS - This gets called for each component but uses all actions in 
// the system.  And it gets called too many times.
//
result = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many act_smts related by act_act->ACT_BLK[R601]->ACT_SMT[R602];
  select many act_sels related by act_smts->ACT_SEL[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fios related by act_smts->ACT_FIO[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fiws related by act_smts->ACT_FIW[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  count = cardinality act_sels;
  c1 = cardinality act_fios;
  count = count + c1;
  c1 = cardinality act_fiws;
  count = count + c1;
  if ( count > result )
    result = count;
  end if;
end for;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000002",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("de950578-7973-46aa-8cf8-0cb23dc07b22",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3ce1490a-5baa-46a1-b601-44e73c798617",
	"00000000-0000-0000-0000-000000000000",
	'timer_analyze_starts',
	'',
	'//
//
// Count up the number of places where a timer is started (or started
// in recurring mode).
//
result = 0;
select any te_target from instances of TE_TARGET;
select many s_ees from instances of S_EE where ( selected.Key_Lett == "TIM" );
if ( "C++" == te_target.language )
  if ( not_empty s_ees )
    result = 1;
  end if;
end if;
for each s_ee in s_ees
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start_recurring" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
end for;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000002",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("3ce1490a-5baa-46a1-b601-44e73c798617",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b2645b58-9b92-4c56-ac83-08d050500875",
	"00000000-0000-0000-0000-000000000000",
	'CreateSpecialWhereClauseInstances',
	'',
	'//
//============================================================================
// Class: 2000.  Special Where Clause
// CREATE TABLE TE_SWC (
// 	Obj_Kl		STRING,
// 	Where_Spec	STRING,
// 	Key	        STRING,
// 	Ret_Val	        BOOLEAN,
//	Built_In	BOOLEAN,
//	Oid_ID	        INTEGER );
//
// Notes:
// (1) The selected attributes of the where clause _Key_ are specified in the
//     same order as they appear on the OIM. This convention allows other
//     archetypes a _rule_ for dealing with the positional parameter
//     information provided during fragment parsing of a special where clause.
//============================================================================
te_sys = param.te_sys;
//
// Special Where Clause patterns that may be optimized by the model compiler.
//
unique_num = 0;
select many te_classes from instances of TE_CLASS where ( not selected.ExcludeFromGen );
for each te_class in te_classes
  select many o_ids related by te_class->O_OBJ[R2019]->O_ID[R104];
  for each o_id in o_ids
    select one te_where related by o_id->TE_WHERE[R2032];
    // Get all special wheres when loading instances even if they are
    // not seen in the OAL.  We need them for batch_relate.
    if ( te_sys.InstanceLoading )
      select any r_rto related by o_id->R_RTO[R109];
      if ( not_empty r_rto )
        te_where.WhereKey = true;
      end if;
    end if;
    if ( te_where.WhereKey )
      key_number = o_id.Oid_ID + 1;
      where_spec = "";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      //
      select many te_attrs related by te_class->TE_ATTR[R2061];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      //
      select many te_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
      num_ident_attr = cardinality te_attrs;
      for each te_attr in te_attrs
        te_attr.Included = true;
      end for;
      //
      // *** Provide a key without parenthesis.
      // Be sure we have the first attribute in the class.
      select any first_te_attr related by te_class->TE_ATTR[R2061];
      while ( not_empty first_te_attr )
        select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''succeeds''];
        if ( empty prev_te_attr )
          break;
        end if;
        first_te_attr = prev_te_attr;
      end while;
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.${o_attr.Name} == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      // *** Provide a key parenthesized at the outer construct.
      where_spec = "(";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.${o_attr.Name} == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          else
            where_spec = where_spec + ")";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      if ( num_ident_attr > 1 )
        // *** Provide a key parenthesized at outer and inner constructs.
        where_spec = "(";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.${o_attr.Name} == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            else
              where_spec = where_spec + ")";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        // *** Provide a key parenthesized at just inner constructs.
        where_spec = "";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.${o_attr.Name} == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.''precedes''];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        //
      end if;
    end if;
  end for;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("a62afb0f-3f33-424b-b5f0-986a395ee2be",
	"b2645b58-9b92-4c56-ac83-08d050500875",
	'te_sys',
	"195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("b2645b58-9b92-4c56-ac83-08d050500875",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d70bd849-cfcc-40e0-878e-15912bdabee9",
	"00000000-0000-0000-0000-000000000000",
	'te_parm_RenderParameters',
	'',
	'//============================================================================
// Here we deal with parameters.  The declaration, definition and invocation
// renderings are built.
//============================================================================
//
//
te_parms = param.te_parms;
te_aba = param.te_aba;
// Consider that we may have additional parameters (like for passing "self").
defn = "";
decl = "";
if ( empty te_parms )
  decl = " void";
end if;
invo = "";
stru = "";
parameter_trace = "";
string_format = "";
assn = "";
assnbase = "";
param_delimiter = " ";
format_delimiter = "";
Order = 0;
// Be sure we have the first parameter.
select any te_parm from instances of TE_PARM where ( false );
for each te_parm in te_parms
  break;
end for;
while ( not_empty te_parm )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
  if ( empty prev_te_parm )
    break;
  else
    te_parm = prev_te_parm;
  end if;
end while;
while ( not_empty te_parm )
  te_parm.Order = Order;
  Order = Order + 1;
  select one te_dt related by te_parm->TE_DT[R2049];
  te_dt.Included = true;
  defn = defn + param_delimiter;
  decl = decl + param_delimiter;
  param_qual = "";
  if ( 0 != te_parm.By_Ref )
    param_qual = param_qual + " *";
  else
    // CDS const correctness goes here
    // Arrays in C are always by ref, so add const to scalars only.
    if ( ( "" == te_parm.array_spec ) and ( ( 1 <= te_dt.Core_Typ ) and ( te_dt.Core_Typ <= 3 ) ) )
      defn = defn + "const ";
      decl = decl + "const ";
    end if;
  end if;
  defn = ( ( defn + te_dt.ExtName ) + ( param_qual + " " ) ) + ( te_parm.GeneratedName + te_parm.array_spec );
  decl = ( ( decl + te_dt.ExtName ) + ( param_qual + te_parm.array_spec ) );
  invo = ( invo + param_delimiter ) + te_parm.GeneratedName;
  stru = ( ( stru + te_dt.ExtName ) + ( param_qual + " " ) ) + ( ( te_parm.GeneratedName + te_parm.array_spec ) + ";\n" );
  if ( ( "" != te_dt.string_format ) and ( "" == te_parm.array_spec ) )
    // Do not trace structures or arrays.
    dereference = "";
    if ( 0 != te_parm.By_Ref )
      dereference = "*";
    end if;
    parameter_trace = ( parameter_trace + ", " ) + ( dereference + te_parm.GeneratedName );
    string_format = ( string_format + format_delimiter ) + te_dt.string_format;
  else
    string_format = ( string_format + format_delimiter ) + "[]";
  end if;
  r = ::t_oal_smt_event_parameters( evt_msg_var:"", parameter:te_parm.Name, value:te_parm.GeneratedName, value_type:te_dt.Core_Typ, ws:"  " );
  assn = assn + r;
  if ( ( "A00portindex" != te_parm.Name ) and ( "A0xtumlsret" != te_parm.Name ) )
    assnbase = assnbase + r;
  end if;
  param_delimiter = ", ";
  format_delimiter = ",";
  select one te_parm related by te_parm->TE_PARM[R2041.''precedes''];
end while;
if ( "" != defn )
  defn = defn + " ";
end if;
te_aba.ParameterDefinition = defn;
te_aba.ParameterDeclaration = decl + " ";
te_aba.ParameterInvocation = invo;
te_aba.ParameterStructure = stru;
te_aba.ParameterTrace = parameter_trace;
te_aba.ParameterFormat = string_format;
te_aba.ParameterAssignment = assn;
te_aba.ParameterAssignmentBase = assnbase;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("bf90e90a-ee68-4d1d-8f9f-4c7c94ebe422",
	"d70bd849-cfcc-40e0-878e-15912bdabee9",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("954dc6bb-6e2a-47a5-aa3b-886723803133",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Parameter>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("429cc305-f3b0-4fcf-8f4a-7a6f51640215",
	"d70bd849-cfcc-40e0-878e-15912bdabee9",
	'te_aba',
	"5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	0,
	'',
	"bf90e90a-ee68-4d1d-8f9f-4c7c94ebe422",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Action Block Anchor>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("d70bd849-cfcc-40e0-878e-15912bdabee9",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("22ecf749-99a8-40f8-8973-3e2c1430249e",
	"00000000-0000-0000-0000-000000000000",
	'sparm_sort',
	'',
	'// CDS temporarily order parameters alphabetically for backwards compatibility
s_sparms = param.s_sparms;
for each s_sparm in s_sparms
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
  if ( not_empty prev_s_sparm )
    unrelate s_sparm from prev_s_sparm across R54.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_sparm related by s_sparms->S_SPARM[R54.''succeeds''] where ( false );
for each s_sparm in s_sparms
  r = ::sparm_insert( head_s_sparm:head_s_sparm, s_sparm:s_sparm );
  head_s_sparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("8140ad31-33f8-48d0-b7f5-6347e882827d",
	"22ecf749-99a8-40f8-8973-3e2c1430249e",
	's_sparms',
	"a397ce5f-c02a-4167-b722-9876a55f62c0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a397ce5f-c02a-4167-b722-9876a55f62c0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Function Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("22ecf749-99a8-40f8-8973-3e2c1430249e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f841714f-056f-4580-a8b5-9b03e0786b13",
	"00000000-0000-0000-0000-000000000000",
	'sparm_insert',
	'',
	'head_s_sparm = param.head_s_sparm;
s_sparm = param.s_sparm;
result = s_sparm;
if ( empty head_s_sparm )
  // Just starting.  Return s_sparm as head.
elif ( s_sparm.Name <= head_s_sparm.Name )
  // insert before
  relate s_sparm to head_s_sparm across R54.''precedes'';
else
  // find bigger
  result = head_s_sparm;
  prev_s_sparm = head_s_sparm;
  select one cursor_s_sparm related by head_s_sparm->S_SPARM[R54.''precedes''];
  while ( not_empty cursor_s_sparm )
    if ( s_sparm.Name <= cursor_s_sparm.Name )
      break;
    else
      prev_s_sparm = cursor_s_sparm;
      select one cursor_s_sparm related by cursor_s_sparm->S_SPARM[R54.''precedes''];
    end if;
  end while;
  relate prev_s_sparm to s_sparm across R54.''precedes'';
  if ( not_empty cursor_s_sparm )
    relate s_sparm to cursor_s_sparm across R54.''precedes'';
  end if;
end if;
return result;
',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("00741bf1-3377-44a9-8f26-a059f25ee5a8",
	"f841714f-056f-4580-a8b5-9b03e0786b13",
	'head_s_sparm',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f822fb34-452f-42a9-8480-07154f3890a4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("953c4f7d-fc2d-4094-8ad8-6b9aa414f8bd",
	"f841714f-056f-4580-a8b5-9b03e0786b13",
	's_sparm',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	0,
	'',
	"00741bf1-3377-44a9-8f26-a059f25ee5a8",
	'');
INSERT INTO PE_PE
	VALUES ("f841714f-056f-4580-a8b5-9b03e0786b13",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("21a13f30-260a-48a1-8a13-913fcbdec406",
	"00000000-0000-0000-0000-000000000000",
	'bparm_sort',
	'',
	'//
//
s_bparms = param.s_bparms;
for each s_bparm in s_bparms
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''succeeds''];
  if ( not_empty prev_s_bparm )
    unrelate s_bparm from prev_s_bparm across R55.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_bparm related by s_bparms->S_BPARM[R55.''succeeds''] where ( false );
for each s_bparm in s_bparms
  r = ::bparm_insert( head_s_bparm:head_s_bparm, s_bparm:s_bparm );
  head_s_bparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("5a5bf5a5-efce-4f03-884d-84e43f00a93b",
	"21a13f30-260a-48a1-8a13-913fcbdec406",
	's_bparms',
	"15271e51-8d77-4dc6-bc1d-a9cb226962e3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15271e51-8d77-4dc6-bc1d-a9cb226962e3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Bridge Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("21a13f30-260a-48a1-8a13-913fcbdec406",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("505e7894-86a0-4f28-b201-844265f9e4e0",
	"00000000-0000-0000-0000-000000000000",
	'bparm_insert',
	'',
	'head_s_bparm = param.head_s_bparm;
s_bparm = param.s_bparm;
result = s_bparm;
if ( empty head_s_bparm )
  // Just starting.  Return s_bparm as head.
elif ( s_bparm.Name <= head_s_bparm.Name )
  // insert before
  relate s_bparm to head_s_bparm across R55.''precedes'';
else
  // find bigger
  result = head_s_bparm;
  prev_s_bparm = head_s_bparm;
  select one cursor_s_bparm related by head_s_bparm->S_BPARM[R55.''precedes''];
  while ( not_empty cursor_s_bparm )
    if ( s_bparm.Name <= cursor_s_bparm.Name )
      break;
    else
      prev_s_bparm = cursor_s_bparm;
      select one cursor_s_bparm related by cursor_s_bparm->S_BPARM[R55.''precedes''];
    end if;
  end while;
  relate prev_s_bparm to s_bparm across R55.''precedes'';
  if ( not_empty cursor_s_bparm )
    relate s_bparm to cursor_s_bparm across R55.''precedes'';
  end if;
end if;
return result;
',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("adc9ba65-d6bb-41b9-8970-73e4ed8e1522",
	"505e7894-86a0-4f28-b201-844265f9e4e0",
	'head_s_bparm',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("09f8590a-5645-4174-b6ce-45d45dbf6e9b",
	"505e7894-86a0-4f28-b201-844265f9e4e0",
	's_bparm',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	0,
	'',
	"adc9ba65-d6bb-41b9-8970-73e4ed8e1522",
	'');
INSERT INTO PE_PE
	VALUES ("505e7894-86a0-4f28-b201-844265f9e4e0",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("228183cf-053d-4b66-b2de-8c3a6a96f451",
	"00000000-0000-0000-0000-000000000000",
	'tparm_sort',
	'',
	'//
//
o_tparms = param.o_tparms;
for each o_tparm in o_tparms
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
  if ( not_empty prev_o_tparm )
    unrelate o_tparm from prev_o_tparm across R124.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_o_tparm related by o_tparms->O_TPARM[R124.''succeeds''] where ( false );
for each o_tparm in o_tparms
  r = ::tparm_insert( head_o_tparm:head_o_tparm, o_tparm:o_tparm );
  head_o_tparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("cf5515b9-59c8-42d7-9318-c3cbf8958a31",
	"228183cf-053d-4b66-b2de-8c3a6a96f451",
	'o_tparms',
	"8223e432-cc81-4a56-a7e3-7dbfcea931f2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8223e432-cc81-4a56-a7e3-7dbfcea931f2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Operation Parameter>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("228183cf-053d-4b66-b2de-8c3a6a96f451",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("50d752bb-17a8-49c0-82c1-febb308bac34",
	"00000000-0000-0000-0000-000000000000",
	'tparm_insert',
	'',
	'head_o_tparm = param.head_o_tparm;
o_tparm = param.o_tparm;
result = o_tparm;
if ( empty head_o_tparm )
  // Just starting.  Return o_tparm as head.
elif ( o_tparm.Name <= head_o_tparm.Name )
  // insert before
  relate o_tparm to head_o_tparm across R124.''precedes'';
else
  // find bigger
  result = head_o_tparm;
  prev_o_tparm = head_o_tparm;
  select one cursor_o_tparm related by head_o_tparm->O_TPARM[R124.''precedes''];
  while ( not_empty cursor_o_tparm )
    if ( o_tparm.Name <= cursor_o_tparm.Name )
      break;
    else
      prev_o_tparm = cursor_o_tparm;
      select one cursor_o_tparm related by cursor_o_tparm->O_TPARM[R124.''precedes''];
    end if;
  end while;
  relate prev_o_tparm to o_tparm across R124.''precedes'';
  if ( not_empty cursor_o_tparm )
    relate o_tparm to cursor_o_tparm across R124.''precedes'';
  end if;
end if;
return result;
',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("fde0ca37-a4ac-49df-ab75-dd16178df5ff",
	"50d752bb-17a8-49c0-82c1-febb308bac34",
	'head_o_tparm',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("e572ccf8-bfd0-4822-b75b-e3e928b6607d",
	"50d752bb-17a8-49c0-82c1-febb308bac34",
	'o_tparm',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	0,
	'',
	"fde0ca37-a4ac-49df-ab75-dd16178df5ff",
	'');
INSERT INTO PE_PE
	VALUES ("50d752bb-17a8-49c0-82c1-febb308bac34",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1fbfa36f-422f-448d-9bdf-a7554aa0621c",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_sort',
	'',
	'//
//
sm_evtdis = param.sm_evtdis;
for each sm_evtdi in sm_evtdis
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
  if ( not_empty prev_sm_evtdi )
    unrelate sm_evtdi from prev_sm_evtdi across R533.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_sm_evtdi related by sm_evtdis->SM_EVTDI[R533.''succeeds''] where ( false );
for each sm_evtdi in sm_evtdis
  r = ::evtdi_insert( head_sm_evtdi:head_sm_evtdi, sm_evtdi:sm_evtdi );
  head_sm_evtdi = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("8fa0d28f-e459-48bc-a620-dc22cde10b94",
	"1fbfa36f-422f-448d-9bdf-a7554aa0621c",
	'sm_evtdis',
	"8d48c15e-5425-419d-a407-d6d4338150d4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8d48c15e-5425-419d-a407-d6d4338150d4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<State Machine Event Data Item>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO PE_PE
	VALUES ("1fbfa36f-422f-448d-9bdf-a7554aa0621c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2a3660c3-1ad6-44dd-9e35-0640eb8b7306",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_insert',
	'',
	'head_sm_evtdi = param.head_sm_evtdi;
sm_evtdi = param.sm_evtdi;
result = sm_evtdi;
if ( empty head_sm_evtdi )
  // Just starting.  Return sm_evtdi as head.
elif ( sm_evtdi.Name <= head_sm_evtdi.Name )
  // insert before
  relate sm_evtdi to head_sm_evtdi across R533.''precedes'';
else
  // find bigger
  result = head_sm_evtdi;
  prev_sm_evtdi = head_sm_evtdi;
  select one cursor_sm_evtdi related by head_sm_evtdi->SM_EVTDI[R533.''precedes''];
  while ( not_empty cursor_sm_evtdi )
    if ( sm_evtdi.Name <= cursor_sm_evtdi.Name )
      break;
    else
      prev_sm_evtdi = cursor_sm_evtdi;
      select one cursor_sm_evtdi related by cursor_sm_evtdi->SM_EVTDI[R533.''precedes''];
    end if;
  end while;
  relate prev_sm_evtdi to sm_evtdi across R533.''precedes'';
  if ( not_empty cursor_sm_evtdi )
    relate sm_evtdi to cursor_sm_evtdi across R533.''precedes'';
  end if;
end if;
return result;
',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("01603309-61f0-456a-b15a-ba61af1b3a8d",
	"2a3660c3-1ad6-44dd-9e35-0640eb8b7306",
	'head_sm_evtdi',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("0c9f0cf6-2dc9-4a20-a0f8-06bac0138dc9",
	"2a3660c3-1ad6-44dd-9e35-0640eb8b7306",
	'sm_evtdi',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	0,
	'',
	"01603309-61f0-456a-b15a-ba61af1b3a8d",
	'');
INSERT INTO PE_PE
	VALUES ("2a3660c3-1ad6-44dd-9e35-0640eb8b7306",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("83e07fc7-ad57-4120-a6e5-fca2cb5f1895",
	"00000000-0000-0000-0000-000000000000",
	'pp_sort',
	'',
	'//
//
c_pps = param.c_pps;
for each c_pp in c_pps
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
  if ( not_empty prev_c_pp )
    unrelate c_pp from prev_c_pp across R4021.''succeeds'';
  end if;
end for;
// Declare an empty instance reference.
select any head_c_pp related by c_pps->C_PP[R4021.''succeeds''] where ( false );
for each c_pp in c_pps
  r = ::pp_insert( head_c_pp:head_c_pp, c_pp:c_pp );
  head_c_pp = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("5853da72-7f6d-4343-8f4b-0ac9eb4ab918",
	"83e07fc7-ad57-4120-a6e5-fca2cb5f1895",
	'c_pps',
	"47b05aeb-144f-4981-85ca-cec108b82bb7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("47b05aeb-144f-4981-85ca-cec108b82bb7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Property Parameter>',
	'',
	'',
	'../Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("83e07fc7-ad57-4120-a6e5-fca2cb5f1895",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8e814aba-80c2-473c-a464-c079dc1d8633",
	"00000000-0000-0000-0000-000000000000",
	'pp_insert',
	'',
	'head_c_pp = param.head_c_pp;
c_pp = param.c_pp;
result = c_pp;
if ( empty head_c_pp )
  // Just starting.  Return c_pp as head.
elif ( c_pp.Name <= head_c_pp.Name )
  // insert before
  relate c_pp to head_c_pp across R4021.''precedes'';
else
  // find bigger
  result = head_c_pp;
  prev_c_pp = head_c_pp;
  select one cursor_c_pp related by head_c_pp->C_PP[R4021.''precedes''];
  while ( not_empty cursor_c_pp )
    if ( c_pp.Name <= cursor_c_pp.Name )
      break;
    else
      prev_c_pp = cursor_c_pp;
      select one cursor_c_pp related by cursor_c_pp->C_PP[R4021.''precedes''];
    end if;
  end while;
  relate prev_c_pp to c_pp across R4021.''precedes'';
  if ( not_empty cursor_c_pp )
    relate c_pp to cursor_c_pp across R4021.''precedes'';
  end if;
end if;
return result;
',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("2a0ae1e3-b0ab-4336-b3b0-252961e23ac0",
	"8e814aba-80c2-473c-a464-c079dc1d8633",
	'head_c_pp',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("bfa384c1-22f6-4068-8fc7-0aad17d7fb4c",
	"8e814aba-80c2-473c-a464-c079dc1d8633",
	'c_pp',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	0,
	'',
	"2a0ae1e3-b0ab-4336-b3b0-252961e23ac0",
	'');
INSERT INTO PE_PE
	VALUES ("8e814aba-80c2-473c-a464-c079dc1d8633",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f0b1c32b-f418-4805-aded-e9e4fae6b007",
	"00000000-0000-0000-0000-000000000000",
	'parm_sort',
	'',
	'//
// CDS temporary for sorting model data parameters
if ( true )
  select many s_syncs from instances of S_SYNC;
  for each s_sync in s_syncs
    select many s_sparms related by s_sync->S_SPARM[R24];
    ::sparm_sort( s_sparms:s_sparms );
  end for;
  select many s_brgs from instances of S_BRG;
  for each s_brg in s_brgs
    select many s_bparms related by s_brg->S_BPARM[R21];
    ::bparm_sort( s_bparms:s_bparms );
  end for;
  select many o_tfrs from instances of O_TFR;
  for each o_tfr in o_tfrs
    select many o_tparms related by o_tfr->O_TPARM[R117];
    ::tparm_sort( o_tparms:o_tparms );
  end for;
  select many sm_evts from instances of SM_EVT;
  for each sm_evt in sm_evts
    select many sm_evtdis related by sm_evt->SM_EVTDI[R532];
    ::evtdi_sort( sm_evtdis:sm_evtdis );
  end for;
  select many c_eps from instances of C_EP;
  for each c_ep in c_eps
    select many c_pps related by c_ep->C_PP[R4006];
    ::pp_sort( c_pps:c_pps );
  end for;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("f0b1c32b-f418-4805-aded-e9e4fae6b007",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("24901374-44db-4ceb-a5c7-ebcadc56f002",
	"00000000-0000-0000-0000-000000000000",
	'rel_pseudoformalize',
	'',
	'//============================================================================
// This query/transformation archetype file contains the functionality
// that will allow the model compiler to generate code for unformalized 
// associations (associations that have not been formalized).
//============================================================================
//
// Find the associations that are not formalized.  They are characterized
// by the existence of 2 instances of R_PART linked to one R_SIMP.
// Migrate the R_PART/R_RTO pair to R_FORM/R_RGO.
// It does not matter which participant we choose unless this is a many
// association.  Grab the many side of a 1-M or any random R_PART and
// migrate it and its parent R_RTO to R_FORM and R_RGO respectively.
select many r_simps from instances of R_SIMP;
for each r_simp in r_simps
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any r_part related by r_simp->R_PART[R207] where ( selected.Mult == 1 );
    if ( empty r_part )
      select any r_part related by r_simp->R_PART[R207];
    end if;
    select one r_rto related by r_part->R_RTO[R204];
    select one r_oir related by r_rto->R_OIR[R203];
    //
    create object instance r_rgo of R_RGO;
    create object instance r_form of R_FORM;
    //
    // Copy the R_PART to the new R_FORM.
    r_form.Mult = r_part.Mult;
    r_form.Cond = r_part.Cond;
    r_form.Txt_Phrs = r_part.Txt_Phrs;
    //
    unrelate r_part from r_rto across R204;
    unrelate r_part from r_simp across R207;
    delete object instance r_part;
    //
    unrelate r_rto from r_oir across R203;
    delete object instance r_rto;
    //
    relate r_rgo to r_oir across R203;
    relate r_form to r_rgo across R205;
    relate r_form to r_simp across R208;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("24901374-44db-4ceb-a5c7-ebcadc56f002",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2590511b-ed78-4dc5-b843-342093a9bd59",
	"00000000-0000-0000-0000-000000000000",
	'sys_populate',
	'',
	'//============================================================================
// This query/transformation archetype file queries the customer model
// and populates the model compiler extensions to the meta-model.
// Instances of the extended classes are created, related and initialized.
//
// Create architectural system-level artifacts first.
// Create leaf-node artifacts (like TE_DT, TE_VAL and TE_PAR) which may need
// to be updated as information is gathered.
// Create component-level artifacts.
// Briefly create and link components, data types.  Select them afterwards.
// Create and link middled-level classes.
// Drill down into component and create object, attributes and the rest.
//============================================================================
//
//
// Create the system interfaces (sys, dom, ee).
//
// Select singletons into scope.
select any te_file from instances of TE_FILE;
select any te_eq from instances of TE_EQ;
select any te_extent from instances of TE_EXTENT;
select any te_instance from instances of TE_INSTANCE;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_string from instances of TE_STRING;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
select any te_tim from instances of TE_TIM;
select any te_typemap from instances of TE_TYPEMAP;
select any empty_cp_cp from instances of CP_CP where ( false );
select many empty_ep_pkgs from instances of EP_PKG where ( false );
select any empty_te_c from instances of TE_C where ( false );
select any empty_te_dim from instances of TE_DIM where ( false );
select many empty_s_dims from instances of S_DIM where ( false );
select any empty_o_obj from instances of O_OBJ where ( false );
select any empty_te_attr from instances of TE_ATTR where ( false );
select any empty_te_mact from instances of TE_MACT where ( false );
select many empty_te_dts from instances of TE_DT where ( false );
select many empty_te_parms from instances of TE_PARM where ( false );
// CDS - Note that in a multiple-system build, we will get lucky, and the
// s_sys from the local project will be selected first.
select any s_sys from instances of S_SYS;
if ( empty s_sys )
  create object instance s_sys of S_SYS;
  s_sys.Name = "sys";
end if;
// Create the system translation extension and relate it.
select any te_sys from instances of TE_SYS;
if ( empty te_sys )
  create object instance te_sys of TE_SYS;
  te_sys.SystemID = 1;
end if;
relate s_sys to te_sys across R2018;
te_sys.Name = T::r(s:s_sys.Name);
if ( "" == te_sys.Name )
  te_sys.Name = "sys";
end if;
te_sys.MaxStringLen = 32;
te_sys.PersistInstanceCacheDepth = 128;
te_sys.PersistLinkCacheDepth = 128;
te_sys.AUTOSAR = false;
te_sys.AllPortsPoly = false;
te_sys.StructuredMessaging = false;
te_sys.NetworkSockets = false;
//
// Update te_sys with system marks
select any tm_systag from instances of TM_SYSTAG;
if ( not_empty tm_systag )
  te_sys.MaxStringLen = tm_systag.MaxStringLen;
  te_sys.MaxRelExtent = tm_systag.MaxRelExtent;
  te_sys.MaxSelectExtent = tm_systag.MaxSelectExtent;
  te_sys.MaxSelfEvents = tm_systag.MaxSelfEvents;
  te_sys.MaxNonSelfEvents = tm_systag.MaxNonSelfEvents;
  te_sys.MaxTimers = tm_systag.MaxTimers;
  te_sys.MaxInterleavedBridges = tm_systag.MaxInterleavedBridges;
  te_sys.MaxInterleavedBridgeDataSize = tm_systag.MaxInterleavedBridgeDataSize;
  te_sys.CollectionsFlavor = tm_systag.CollectionsFlavor;
  te_sys.PersistInstanceCacheDepth = tm_systag.PersistInstanceCacheDepth;
  te_sys.PersistLinkCacheDepth = tm_systag.PersistLinkCacheDepth;
  te_sys.UnitsToDynamicallyAllocate = tm_systag.UnitsToDynamicallyAllocate;
  te_sys.VFB = tm_systag.VFB;
  te_sys.InstanceLoading = tm_systag.InstanceLoading;
  te_sys.SystemCPortsType = tm_systag.SystemCPortsType;
  te_sys.AllPortsPoly = tm_systag.AllPortsPoly;
  te_sys.StructuredMessaging = tm_systag.StructuredMessaging;
  te_sys.NetworkSockets = tm_systag.NetworkSockets;
else
  te_sys.SystemCPortsType = "sc_interface";
end if;
//
// Update the tasking threads based on marking.
select any tm_thread from instances of TM_THREAD;
if ( not_empty tm_thread )
  te_thread.extra_initialization = tm_thread.extra_initialization;
  te_thread.number_of_threads = tm_thread.number_of_threads;
  te_thread.enabled = tm_thread.enabled;
  te_thread.serialize = tm_thread.serialize;
  te_thread.flavor = tm_thread.flavor;
  if ( "AUTOSAR" == te_thread.flavor )
    te_sys.AUTOSAR = true;
  end if;
end if;
//
select any te_disp from instances of TE_DISP;
if ( empty te_disp )
  create object instance te_disp of TE_DISP;
  te_disp.Dispatcher_ID = 1;
  relate te_disp to te_sys across R2003;
end if;
te_disp.Descrip = "dispatcher";
te_disp.Name = "main";
select any te_queue from instances of TE_QUEUE;
select any nonself_te_queue from instances of TE_QUEUE;
if ( empty te_queue )
  create object instance te_queue of TE_QUEUE;
  te_queue.Queue_ID = 1;
  relate te_queue to te_disp across R2004;
  create object instance nonself_te_queue of TE_QUEUE;
  nonself_te_queue.Queue_ID = 2;
  relate nonself_te_queue to te_disp across R2004;
end if;
// Self Queue
te_queue.Descrip = "Self Queue";
te_queue.RenderCode = false;
te_queue.MaxDepth = 0;
te_queue.Type = 1;
// NonSelf Queue
nonself_te_queue.Descrip = "NonSelf Queue";
nonself_te_queue.RenderCode = false;
nonself_te_queue.MaxDepth = 0;
nonself_te_queue.Type = 2;
//
// Create the (domain) class info array instance.
// CDS - This may end up being part of a component rather than a system.
create object instance te_cia of TE_CIA;
te_cia.class_info_name = "domain_class_info";
te_cia.class_info_type = te_extent.type;
te_cia.active_count = "active_count";
te_cia.class_count = "domain_class_count";
te_cia.count_type = te_typemap.object_number_name;
//
//
// Create the Extended Component instance(s) and link them up.
select many c_cs from instances of C_C;
for each c_c in c_cs
  create object instance te_c of TE_C;
  relate te_c to c_c across R2054;
  relate te_c to te_sys across R2065;
  te_c.Name = T::r(s:c_c.Name);
  te_c.Descrip = c_c.Descrip;
  te_c.included_in_build = true;
        select any tm_c from instances of TM_C where ( selected.Name == c_c.Name );
  if ( not_empty tm_c )
    if ( ( tm_c.isRealized ) or ( c_c.isRealized ) )
      // Component is realized, so skip translation of internals.
      te_c.isRealized = true;
    end if;
  end if;
  te_c.internal_behavior = false;
  te_c.module_file = te_c.Name;
  te_c.port_file = te_c.Name;
  te_c.classes_file = te_c.Name + "_classes";
  te_c.CodeComments = true;
  // Create and relate the domain class info to carry details about
  // class extents for this component.
  create object instance te_dci of TE_DCI;
  relate te_dci to te_c across R2090;
  te_dci.class_numbers = te_c.Name + "_CLASS_NUMBERS";
  te_dci.persist_union = te_c.Name + "_CLASS_U";
  te_dci.task_list = te_c.Name + "_task_numbers";
  te_dci.task_numbers = te_c.Name + "_TASK_NUMBERS";
  te_dci.max = te_c.Name + "_MAX_CLASS_NUMBERS";
  te_dci.max_models = te_c.Name + "_STATE_MODELS";
  te_dci.init = te_c.Name + "_CLASS_INFO_INIT";
  te_dci.array_name = te_c.Name + "_class_info";
  // Create the Component Instance instances.
  select many cl_ics related by c_c->CL_IC[R4201];
  for each cl_ic in cl_ics
    create object instance te_ci of TE_CI;
    te_ci.Name = te_c.Name;
    if ( "" == cl_ic.ClassifierName )
      te_ci.ClassifierName = "i" + te_c.Name;
    else
      te_ci.ClassifierName = T::r(s:cl_ic.ClassifierName);
    end if;
    relate te_ci to te_c across R2008;
    relate te_ci to cl_ic across R2009;
  end for;
  // Create the Extended Ports.
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
    if ( not_empty c_i )
      create object instance te_po of TE_PO;
      relate te_po to c_po across R2044;
      relate te_po to te_c across R2005;
      relate te_po to c_i across R2007;
      te_po.InterfaceName = T::r(s:c_i.Name);
      select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
      if ( not_empty c_r )
        te_po.Provision = false;
      else
        te_po.Provision = true;
      end if;
      te_po.polymorphic = false;
      te_po.sibling = 0;
      te_po.Name = c_po.Name;
      te_po.GeneratedName = T::r(s:te_po.Name);
      // Create the Interface Instance instances.
      select many c_irs related by c_po->C_IR[R4016];
      for each c_ir in c_irs
        create object instance te_iir of TE_IIR;
                        relate te_iir to c_ir across R2046;
        relate te_iir to te_po across R2080;
        te_iir.component_name = c_c.Name;
        te_iir.port_name = te_po.Name;
        te_iir.interface_name = te_po.InterfaceName;
        te_iir.polymorphic = false;
        select many cl_iirs related by c_ir->CL_IIR[R4701];
        for each cl_iir in cl_iirs
          create object instance te_iir of TE_IIR;
                              relate te_iir to cl_iir across R2013;
          relate te_iir to te_po across R2080;
          te_iir.port_name = te_po.Name;
          te_iir.interface_name = te_po.InterfaceName;
          te_iir.polymorphic = false;
        end for;
      end for;
    end if;
  end for;
  // Identify polymorhic ports.
  // Polymorphic ports exist more than once in the same orientation on a component.
  port_counter = 0;
  select many te_pos related by te_c->TE_PO[R2005];
  for each te_po in te_pos
    te_po.Order = port_counter;
    port_counter = port_counter + 1;
    select many poly_te_pos related by te_po->TE_C[R2005]->TE_PO[R2005] where ( ( ( selected.c_iId == te_po.c_iId ) and ( selected.Provision == te_po.Provision ) ) and ( selected.ID != te_po.ID ) );
    if ( not_empty poly_te_pos )
      // If we have seen this port already, it will be marked as polymorphic.
      // So, no need to iterate marking as not the first sibling.
      if ( not te_po.polymorphic )
        sibling_counter = 1;
        for each poly_te_po in poly_te_pos
          poly_te_po.polymorphic = true;
          poly_te_po.sibling = sibling_counter;
          sibling_counter = sibling_counter + 1;
        end for;
      end if;
      te_po.polymorphic = true;
      // Now mark the related interface reference instances as polymorphic.
      select many te_iirs related by te_po->TE_IIR[R2080];
      for each te_iir in te_iirs
        te_iir.polymorphic = true;
      end for;
    end if;
  end for;
end for;
// Here we force all the ports and interface references to be polymorphic.  
// We do this step via a second loop here so that we could set up the 
// sibling values earlier before all the ports potentially get forced to polymorphic.
// This loop also configures the satisfaction shortcut we create between local and
// foreign interface references.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_iirs related by te_po->TE_IIR[R2080];
  for each te_iir in te_iirs
    // Select across the satisfaction to get the related TE_IIR.
    if ( te_po.Provision )
      // provision side first
      // CDS There may be more than one here.
      select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        // We are dealing with TE_IIRs that may be on non-imported interface references (connected to C_Cs).
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''provides or is delegated'';
      end if;
    else
      // requirement side first
      select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''requires or delegates'';
      end if;
    end if;
  end for;
end for;
//
// By default, select all components to be translated.  However, if
// a package has been marked, translate only the components contained
// in the package (or referenced from it).
ep_pkgs = empty_ep_pkgs;
cp_cp = empty_cp_cp;
package_to_build = "";
select any tm_build from instances of TM_BUILD;
markedsystems = 0;
if ( not_empty tm_build )
  select many ep_pkgs from instances of EP_PKG where ( selected.Name == tm_build.package_to_build );
  markedsystems = cardinality ep_pkgs;
  if ( empty ep_pkgs )
    T::print(s:"ERROR:  Marked configuration package ${tm_build.package_to_build} was not found in model.  Exiting.");
    T::exit(i:11);
  end if;
  package_to_build = tm_build.package_to_build;
end if;
if ( markedsystems > 1 )
  T::print(s:"WARNING:  More than one package is marked as a system build... choose only one.");
end if;
if ( "" != package_to_build )
  T::print(s:"Marked configuration package ${package_to_build} found.");
  select many te_cs from instances of TE_C;
  // Clear the build flag for all components and then mark only those
  // requested by the marking.
  for each te_c in te_cs
    te_c.included_in_build = false;
  end for;
  select many te_cs related by ep_pkgs->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  select many te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:te_cs );
  // Uncomment the line below to use package name instead of project for the top-level files.
  //.assign te_sys.Name = "$r{package_to_build}"
else
  // Here we use the default name for the system derived from the project name.
end if;
te_file.types = ( te_sys.Name + "_" ) + te_file.types;
te_file.sys_main = ( te_sys.Name + "_" ) + te_file.sys_main;
//
// Create and link the Extended model compiler instances.
// Do not fully initialize, yet.  Create and link and mark.
// These artifacts contain important naming that must propagate.
//
// Create the Generated Data Type instances and link them in.
select many s_dts from instances of S_DT;
for each s_dt in s_dts
  create object instance te_dt of TE_DT;
  relate te_dt to s_dt across R2021;
  te_dt.Name = s_dt.Name;
  te_dt.Core_Typ = -1;
  te_dt.string_format = "";
    // Link the ownership if contained in a component.
  te_c = empty_te_c;
  select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
    te_c = r;
  end if;
  if ( empty te_c )
    // Default the owner to be the system.
    te_dt.Owning_Dom_Name = te_sys.Name;
  else
    te_dt.Owning_Dom_Name = te_c.Name;
    relate te_dt to te_c across R2086;
  end if;
end for;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
//
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  te_c = empty_te_c;
  select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Generated Class instance and link it to the real one.
      r1 = ::FactoryTE_CLASS( o_obj:o_obj, te_c:te_c );
      te_class = r1;
      if ( "C++" == te_target.language )
        te_class.scope = te_class.GeneratedName + "::";
      end if;
    end if;
  end if;
end for;
//
select many s_syncs from instances of S_SYNC;
for each s_sync in s_syncs
  te_c = empty_te_c;
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended Function instance and link it to the real one.
      create object instance te_sync of TE_SYNC;
      relate s_sync to te_sync across R2023;
      relate te_sync to te_c across R2084;
      te_sync.Name = s_sync.Name;
      te_sync.GeneratedName = ( te_c.Name + "_" ) + te_sync.Name;
    end if;
  end if;
end for;
//
select many s_ees from instances of S_EE;
for each s_ee in s_ees
  select one ep_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( empty te_c )
    // Here we have an EE in a package outside of a component.
    create object instance te_ee of TE_EE;
    relate te_ee to s_ee across R2020;
    // Be sure we are not related to any te_c across R2085
      else
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended EE instance and link it to the real one.
      create object instance te_ee of TE_EE;
      relate te_ee to s_ee across R2020;
      relate te_ee to te_c across R2085;
    end if;
  end if;
end for;
//
//
// Create the low-level leaf items.
//
// Initialize information for a core data type:  the ANSI C typedef
// that the data type is known by in the generated code in both a
// normal object declaration and an event declaration and the initial
// value of the data element.
select many s_cdts from instances of S_CDT;
for each s_cdt in s_cdts
  select one te_dt related by s_cdt->S_DT[R17]->TE_DT[R2021];
  te_dt.Core_Typ = s_cdt.Core_Typ;
  te_dt.Include_File = te_file.types + ( "." + te_file.hdr_file_ext );
  if ( 0 == te_dt.Core_Typ )
    // void
    te_dt.ExtName = "void";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "";
  elif ( 1 == te_dt.Core_Typ )
    // boolean
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLBoolean";
    else
      te_dt.ExtName = "bool";
    end if;
    te_dt.Initial_Value = "false";
    te_dt.string_format = "%d";
  elif ( 2 == te_dt.Core_Typ )
    // integer
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLInteger";
    else
      te_dt.ExtName = "i_t";
    end if;
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  elif ( 3 == te_dt.Core_Typ )
    // real
    // float or double:  Default to smaller type for embedded.
    // This can be expanded with the TagDatatypePrecision marking.
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLReal";
    else
      te_dt.ExtName = "r_t";
    end if;
    te_dt.Initial_Value = "0.0";
    te_dt.string_format = "%f";
  elif ( 4 == te_dt.Core_Typ )
    // string
    te_dt.ExtName = "c_t";
    if ( te_sys.InstanceLoading )
      te_dt.ExtName = "c_t *";
    end if;
    te_dt.Initial_Value = "CTOR";
    te_dt.string_format = "%s";
  elif ( 5 == te_dt.Core_Typ )
    // unique_id
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 6 == te_dt.Core_Typ )
    // current_state
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 7 == te_dt.Core_Typ )
    // same as base<Attribute>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 8 == te_dt.Core_Typ )
    // inst_ref<Object>
    te_dt.ExtName = "void *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 9 == te_dt.Core_Typ )
    // inst_ref_set<Object>
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 10 == te_dt.Core_Typ )
    // inst<Event>
    te_dt.ExtName = te_eq.base_event_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 11 == te_dt.Core_Typ )
    // inst<Mapping>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 12 == te_dt.Core_Typ )
    // inst_ref<Mapping>
    te_dt.ExtName = "i_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  else
    // undefined
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%x";
  end if;
end for;
//
// Initialize information for user data types.
select many s_udts from instances of S_UDT;
for each s_udt in s_udts
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  base_s_dt = r;
  select one core_te_dt related by base_s_dt->TE_DT[R2021];
  // Given a user data type (S_UDT) and a core data type (S_CDT), set
  // the C typedef that the user data type is known by in the generated
  // code.  Also set the initial value of the attribute.
  // Note:  An initial value of "CTOR" means to run the constructor.
  select one s_dt related by s_udt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  te_dt.Is_Enum = false;
  te_dt.Core_Typ = core_te_dt.Core_Typ;
  te_dt.Include_File = core_te_dt.Include_File;
  te_dt.ExtName = core_te_dt.ExtName;
  te_dt.string_format = core_te_dt.string_format;
  if ( "" != s_dt.DefaultValue )
    te_dt.Initial_Value = s_dt.DefaultValue;
  else
    te_dt.Initial_Value = core_te_dt.Initial_Value;
  end if;
  //
  // CTOR is a special string used to invoke the constructor of a data
  // attribute on the initialization list of the object constructor.
  if ( s_dt.Name == "date" )
    te_dt.ExtName = te_prefix.type + "Date_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "timestamp" )
    te_dt.ExtName = te_prefix.type + "TimeStamp_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "inst_ref<Timer>" )
    if ( te_tim.keyed_timer_support )
      te_dt.ExtName = te_prefix.type + "Timer_t";
    else
      te_dt.ExtName = te_prefix.type + "Timer_t *";
    end if;
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "inst_ref<StateMachine>" )
    te_dt.ExtName = "<${te_prefix.type}Object Type *>";
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "arbitrary_id" )
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
  end if;
end for;
//
// Initialize information for enumeration data types.
select many s_edts from instances of S_EDT;
for each s_edt in s_edts
  select one s_dt related by s_edt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  // NOTE: We should allow the size of an enum to be colored.
  // For now use small type.
  if ( te_sys.AUTOSAR )
    te_dt.ExtName = "en_" + te_dt.Name;
  elif ( "C" == te_target.language )
    te_dt.ExtName = ( te_sys.Name + "_" ) + ( te_dt.Name + "_t" );
  else
    te_dt.ExtName = te_dt.Name + "_t";
  end if;
  // CDS We should some day pass along the EDT.
  te_dt.Core_Typ = 2;
  te_dt.Is_Enum = true;
  te_dt.Initial_Value = ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "__UNINITIALIZED__e" );
  te_dt.Value = "-1";
  te_dt.string_format = "%d";
  if ( te_dt.Owning_Dom_Name == "sys" )
    te_dt.Include_File = ( te_file.types + "." ) + te_file.hdr_file_ext;
  end if;
  //
  // Create the Generated Enumerators and link them to the real ones.
  select many s_enums related by s_edt->S_ENUM[R27];
  for each s_enum in s_enums
    create object instance te_enum of TE_ENUM;
    relate s_enum to te_enum across R2027;
    te_enum.Name = s_enum.Name;
    te_enum.GeneratedName = ( ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "_" ) ) + ( T::r(s:te_enum.Name) + "_e" );
    value = T::parsekeyword(s:s_enum.Descrip,key:"value");
    if ( "" == value )
      value = T::parsekeyword(s:s_enum.Descrip,key:"Value");
      if ( "" == value )
        value = T::parsekeyword(s:s_enum.Descrip,key:"VALUE");
      end if;
    end if;
    te_enum.Value = value;
  end for;
end for;
//
// Initialize structured data types.
select many s_sdts from instances of S_SDT;
for each s_sdt in s_sdts
  select one te_dt related by s_sdt->S_DT[R17]->TE_DT[R2021];
  te_dt.ExtName = ( te_dt.Owning_Dom_Name + "_sdt_" ) + te_dt.Name;
  te_dt.string_format = "";
  select many s_mbrs related by s_sdt->S_MBR[R44];
  for each s_mbr in s_mbrs
    create object instance te_mbr of TE_MBR;
    relate s_mbr to te_mbr across R2047;
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    relate te_mbr to mbr_te_dt across R2068;
  end for;
  for each s_mbr in s_mbrs
    select one te_mbr related by s_mbr->TE_MBR[R2047];
    select one previous_te_mbr related by s_mbr->S_MBR[R46.''succeeds'']->TE_MBR[R2047];
    if ( not_empty previous_te_mbr )
      relate te_mbr to previous_te_mbr across R2067.''succeeds'';
    else
          end if;
    te_mbr.Name = s_mbr.Name;
    te_mbr.GeneratedName = T::r(s:s_mbr.Name);
    select many s_dims related by s_mbr->S_DIM[R53];
    array_spec = "";
    te_mbr.dimensions = cardinality s_dims;
    te_dim = empty_te_dim;
    dim_index = 0;
    while ( dim_index < te_mbr.dimensions )
      select any s_dim related by s_mbr->S_DIM[R53] where ( selected.dimensionCount == dim_index );
      r1 = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r1;
      if ( dim_index == 0 )
        relate te_dim to te_mbr across R2059;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
      dim_index = dim_index + 1;
    end while;
    te_mbr.array_spec = array_spec;
    // In the C model compiler, treat strings as arrays.
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    if ( ( 4 == mbr_te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
      // string
      te_mbr.dimensions = te_mbr.dimensions + 1;
      te_mbr.array_spec = ( te_mbr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  end for;
end for;
//
// Initialize instance reference data types.
select many s_irdts from instances of S_IRDT;
for each s_irdt in s_irdts
  select one te_dt related by s_irdt->S_DT[R17]->TE_DT[R2021];
  select one te_class related by s_irdt->O_OBJ[R123]->TE_CLASS[R2019];
  if ( s_irdt.isSet )
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Core_Typ = 21;
  else
    te_dt.Core_Typ = 20;
    if ( not_empty te_class )
      te_dt.ExtName = te_class.GeneratedName + " *";
    end if;
  end if;
end for;
//
// Update the precision of the integer and real types based on marking.
select many tm_precisions from instances of TM_PRECISION;
for each tm_precision in tm_precisions
  te_dts = empty_te_dts;
  if ( ( "*" == tm_precision.Domain ) or ( "" == tm_precision.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_precision.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_precision.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_precision.DT_name );
  end if;
  for each te_dt in te_dts
    // Only allow precision specification of core types integer
    // and real and user defined types (UDTs) that are enums
    // (including S_EDT).
    // S_CDT.Core_Typ == 2 is integer, S_CDT.Core_Typ == 3 is real
    select one s_dt related by te_dt->S_DT[R2021];
    select one s_edt related by s_dt->S_EDT[R17];
    select one s_cdt related by s_dt->S_CDT[R17];
    if ( empty s_cdt )
      select one s_udt related by s_dt->S_UDT[R17];
      if ( not_empty s_udt )
        r = ::GetBaseTypeForUDT( s_udt:s_udt );
        base_s_dt = r;
        select one s_cdt related by base_s_dt->S_CDT[R17];
      end if;
      if ( empty s_cdt )
        select one s_irdt related by s_dt->S_IRDT[R17];
        if ( empty s_irdt )
          if ( empty s_edt )
            T::print(s:"Warning:  Could not find a core data type (S_CDT) for input type.");
            T::exit(i:101);
          end if;
          // Enumeration Data Type (S_EDT) - give it a core type of integer.
          select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
        else
          if ( s_irdt.isSet )
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 9 );
          else
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 8 );
          end if;
        end if;
      end if;
    end if;
    if ( ( s_cdt.Core_Typ == 2 ) or ( s_cdt.Core_Typ == 3 ) )
      r = ::MapUserSpecifiedDataTypePrecision( te_dt:te_dt, mapping:tm_precision.xName );
      status_error = r;
      if ( status_error )
        te_dt.ExtName = tm_precision.xName;
      end if;
      if ( ( "" != tm_precision.initial_value ) and ( empty s_edt ) )
        te_dt.Initial_Value = tm_precision.initial_value;
      end if;
    end if;
  end for;
end for;
//
// Map data types to pointers based on marking.
select many tm_pointers from instances of TM_POINTER;
for each tm_pointer in tm_pointers
  te_dts = empty_te_dts;
  if ( ( "*" == tm_pointer.Domain ) or ( "" == tm_pointer.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_pointer.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_pointer.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_pointer.DT_name );
  end if;
  for each te_dt in te_dts
    te_dt.ExtName = tm_pointer.pointer_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.Include_File = tm_pointer.include_file;
    te_dt.Is_Enum = false;
    if ( 4 == te_dt.Core_Typ )
      // Change core type so that dimensions are not added to the pointer.
      te_dt.Core_Typ = -4;
    end if;
  end for;
end for;
//
// Mark enumerator discrete values (from marking).
select many tm_enumvals from instances of TM_ENUMVAL;
for each tm_enumval in tm_enumvals
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enumval.Domain ) or ( "" == tm_enumval.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enumval.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enumval.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_enumval.enumeration );
  end if;
  for each te_dt in te_dts
    select any te_enum related by te_dt->S_DT[R2021]->S_EDT[R17]->S_ENUM[R27]->TE_ENUM[R2027] where ( selected.Name == tm_enumval.enumerator );
    if ( not_empty te_enum )
      te_enum.Value = tm_enumval.value;
    end if;
  end for;
end for;
//
// Mark enumerator default uninitialized values (from marking).
select many tm_enuminits from instances of TM_ENUMINIT;
for each tm_enuminit in tm_enuminits
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enuminit.Domain ) or ( "" == tm_enuminit.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enuminit.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enuminit.Domain );
    select many te_dts related by te_c->TE_DT[R2086] where ( selected.Name == tm_enuminit.enumeration );
  end if;
  for each te_dt in te_dts
    te_dt.Value = tm_enuminit.value;
  end for;
end for;
//
// Create a string parameter that can be duplicated and used for returning string data.
select any string_te_dt from instances of TE_DT where ( selected.Name == "string" );
r3 = ::FactoryTE_PARM( s_dims:empty_s_dims, te_dt:string_te_dt, prefix:"", name:"A0xtumlsret", by_ref:0 );
te_parm = r3;
//
// Create the values and connect them to the V_VAL.
select many v_vals from instances of V_VAL;
for each v_val in v_vals
  create object instance te_val of TE_VAL;
  relate v_val to te_val across R2040;
  te_val.array_spec = "";
  te_val.dimensions = 0;
end for;
//
// Create the extended actual parameters and connect them to V_PAR.
select many v_pars from instances of V_PAR;
for each v_par in v_pars
  create object instance te_par of TE_PAR;
  te_par.Name = v_par.Name;
  te_par.By_Ref = 0;
  relate te_par to v_par across R2063;
end for;
//
// Create the Generated Parameters needed for all types of parameters.
// During this process, te_pars created above will be updated with
// By_Ref information.
// The TE_PARM instances must exist before creating the action bodies
// (for functions, operation, messages, etc).
select many s_bparms from instances of S_BPARM;
for each s_bparm in s_bparms
  select many s_dims related by s_bparm->S_DIM[R49];
  select one te_dt related by s_bparm->S_DT[R22]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_bparm.Name, by_ref:s_bparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = s_bparm.Descrip;
  relate s_bparm to te_parm across R2028;
  select many te_pars related by s_bparm->S_BRG[R21]->ACT_BRG[R674]->V_PAR[R628]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_bparm->S_BRG[R21]->V_BRV[R828]->V_PAR[R810]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_bparm in s_bparms
  select one te_parm related by s_bparm->TE_PARM[R2028];
  select one next_te_parm related by s_bparm->S_BPARM[R55.''precedes'']->TE_PARM[R2028];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many o_tparms from instances of O_TPARM;
for each o_tparm in o_tparms
  select many s_dims related by o_tparm->S_DIM[R121];
  select one te_dt related by o_tparm->S_DT[R118]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:o_tparm.Name, by_ref:o_tparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = o_tparm.Descrip;
  relate o_tparm to te_parm across R2029;
  select many te_pars related by o_tparm->O_TFR[R117]->ACT_TFM[R673]->V_PAR[R627]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by o_tparm->O_TFR[R117]->V_TRV[R829]->V_PAR[R811]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each o_tparm in o_tparms
  select one te_parm related by o_tparm->TE_PARM[R2029];
  select one next_te_parm related by o_tparm->O_TPARM[R124.''precedes'']->TE_PARM[R2029];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many s_sparms from instances of S_SPARM;
for each s_sparm in s_sparms
  select many s_dims related by s_sparm->S_DIM[R52];
  select one te_dt related by s_sparm->S_DT[R26]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_sparm.Name, by_ref:s_sparm.By_Ref );
  te_parm = r;
  te_parm.Descrip = s_sparm.Descrip;
  relate s_sparm to te_parm across R2030;
  select many te_pars related by s_sparm->S_SYNC[R24]->ACT_FNC[R675]->V_PAR[R669]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_sparm->S_SYNC[R24]->V_FNV[R827]->V_PAR[R817]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_sparm in s_sparms
  select one te_parm related by s_sparm->TE_PARM[R2030];
  select one next_te_parm related by s_sparm->S_SPARM[R54.''precedes'']->TE_PARM[R2030];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many sm_evtdis from instances of SM_EVTDI;
for each sm_evtdi in sm_evtdis
  select many s_dims related by sm_evtdi->S_DIM[R531];
  select one te_dt related by sm_evtdi->S_DT[R524]->TE_DT[R2021];
  // Event data items are not passable By_Ref at this time.
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:sm_evtdi.Name, by_ref:0 );
  te_parm = r;
  te_parm.Descrip = sm_evtdi.Descrip;
  relate te_parm to sm_evtdi across R2031;
end for;
// Link the event parameters into order.
for each sm_evtdi in sm_evtdis
  select one te_parm related by sm_evtdi->TE_PARM[R2031];
  select one next_te_parm related by sm_evtdi->SM_EVTDI[R533.''precedes'']->TE_PARM[R2031];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
select many c_pps from instances of C_PP;
for each c_pp in c_pps
  select many s_dims related by c_pp->S_DIM[R4017];
  select one te_dt related by c_pp->S_DT[R4007]->TE_DT[R2021];
  c_pp_name = c_pp.Name;
  if ( "C++" == te_target.language )
    select one c_as related by c_pp->C_EP[R4006]->C_AS[R4004];
    if ( not_empty c_as )
      c_pp_name = ( c_as.Name + "_" ) + c_pp_name;
    else
      select one c_io related by c_pp->C_EP[R4006]->C_IO[R4004];
      c_pp_name = ( c_io.Name + "_" ) + c_pp_name;
    end if;
  end if;
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:c_pp_name, by_ref:c_pp.By_Ref );
  te_parm = r;
  te_parm.Descrip = c_pp.Descrip;
  relate c_pp to te_parm across R2048;
  select many spr_reps related by c_pp->C_EP[R4006]->SPR_REP[R4500];
  if ( not_empty spr_reps )
    select many te_pars related by spr_reps->SPR_RS[R4502]->ACT_SGN[R660]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->SPR_RO[R4502]->ACT_IOP[R657]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->V_MSV[R845]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
  select many spr_peps related by c_pp->C_EP[R4006]->SPR_PEP[R4501];
  if ( not_empty spr_peps )
    select many te_pars related by spr_peps->SPR_PS[R4503]->ACT_SGN[R663]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->SPR_PO[R4503]->ACT_IOP[R680]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->V_MSV[R841]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
end for;
// Link the event parameters into order.
for each c_pp in c_pps
  select one te_parm related by c_pp->TE_PARM[R2048];
  select one next_te_parm related by c_pp->C_PP[R4021.''precedes'']->TE_PARM[R2048];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''precedes'';
  end if;
end for;
//
//
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
//
// Create the port message actions.  There are four types.  Use
// a common extension class for all of them.
// Populate the extension with all of the names it will need from
// the component, interface, port and message.
select many spr_ros from instances of SPR_RO;
for each spr_ro in spr_ros
  select one spr_rep related by spr_ro->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_rep->C_EP[R4500]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_ro.Name, subtypeKL:"SPR_RO" );
  te_mact = r;
  te_mact.Descrip = c_io.Descrip;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_ro across R2052;
end for;
select many spr_rss from instances of SPR_RS;
for each spr_rs in spr_rss
  select one spr_rep related by spr_rs->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_rep->C_EP[R4500]->C_AS[R4004];
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_rs.Name, subtypeKL:"SPR_RS" );
  te_mact = r;
  te_mact.Descrip = c_as.Descrip;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_rs across R2053;
end for;
select many spr_pos from instances of SPR_PO;
for each spr_po in spr_pos
  select one spr_pep related by spr_po->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_pep->C_EP[R4501]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_po.Name, subtypeKL:"SPR_PO" );
  te_mact = r;
  te_mact.Descrip = c_io.Descrip;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_po across R2050;
end for;
select many spr_pss from instances of SPR_PS;
for each spr_ps in spr_pss
  select one spr_pep related by spr_ps->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_pep->C_EP[R4501]->C_AS[R4004];
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_ps.Name, subtypeKL:"SPR_PS" );
  te_mact = r;
  te_mact.Descrip = c_as.Descrip;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_ps across R2051;
end for;
// All the te_pos and te_macts are created now.  Order the te_macts alphabetically inside the ports.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_macts related by te_po->TE_MACT[R2006];
  ::mact_sort( te_macts:te_macts );
end for;
//
//
// Create the generated links (associations) and connect them.
select many r_rels from instances of R_REL;
for each r_rel in r_rels
  create object instance te_rel of TE_REL;
  te_rel.Numb = r_rel.Numb;
  if ( te_sys.InstanceLoading )
    te_rel.LinkNeeded = true;
  else
    te_rel.LinkNeeded = false;
  end if;
  te_rel.UnlinkNeeded = false;
  te_rel.Navigated = false;
  te_rel.Order = 0;
  te_rel.storage_needed = false;
  relate r_rel to te_rel across R2034;
end for;
//
// Create the navigations and connect them to the R_OIRs.
select many r_oirs from instances of R_OIR;
for each r_oir in r_oirs
  create object instance te_oir of TE_OIR;
  select one o_obj related by r_oir->O_OBJ[R201];
  select one r_rel related by r_oir->R_REL[R201];
  te_oir.data_member = ( o_obj.Key_Lett + "_R" ) + T::s(i:r_rel.Numb);
  te_oir.assoc_type = "";
  te_oir.Mult = 0;
  te_oir.rel_phrase = "";
  te_oir.object_id = "";
  te_oir.NavigatedTo = false;
  relate r_oir to te_oir across R2035;
end for;
select many r_parts related by r_rels->R_SIMP[R206]->R_PART[R207];
for each r_part in r_parts
  select one te_oir related by r_part->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "part";
  te_oir.rel_phrase = T::underscore(s:r_part.Txt_Phrs);
  te_oir.Mult = r_part.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_forms from instances of R_FORM;
for each r_form in r_forms
  select one te_oir related by r_form->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "form";
  te_oir.rel_phrase = T::underscore(s:r_form.Txt_Phrs);
  te_oir.Mult = r_form.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aones from instances of R_AONE;
for each r_aone in r_aones
  select one te_oir related by r_aone->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aone";
  te_oir.rel_phrase = T::underscore(s:r_aone.Txt_Phrs);
  te_oir.Mult = r_aone.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aoths from instances of R_AOTH;
for each r_aoth in r_aoths
  select one te_oir related by r_aoth->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aoth";
  te_oir.rel_phrase = T::underscore(s:r_aoth.Txt_Phrs);
  te_oir.Mult = r_aoth.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_assrs from instances of R_ASSR;
for each r_assr in r_assrs
  select one te_oir related by r_assr->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "assr";
  te_oir.Mult = r_assr.Mult;
end for;
select many r_subs from instances of R_SUB;
for each r_sub in r_subs
  select one te_oir related by r_sub->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  select one r_rel related by r_sub->R_SUBSUP[R213]->R_REL[R206];
  te_oir.assoc_type = "subsuper";
  te_oir.object_id = ( "R" + T::s(i:r_rel.Numb) ) + "_object_id";
  te_oir.data_member = ( "R" + T::s(i:r_rel.Numb) ) + "_subtype";
end for;
select many r_supers from instances of R_SUPER;
for each r_super in r_supers
  select one te_oir related by r_super->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "subsuper";
end for;
//
// Create the blocks and connect them to the ACT_BLKs.
select many act_blks from instances of ACT_BLK;
for each act_blk in act_blks
  create object instance te_blk of TE_BLK;
  relate act_blk to te_blk across R2016;
    te_blk.declaration = "";
  te_blk.deallocation = "";
  te_blk.depth = 1;
  first_smt = true;
  // Create the statements and connect them to the ACT_SMTs.
  select many act_smts related by act_blk->ACT_SMT[R602];
  for each act_smt in act_smts
    create object instance te_smt of TE_SMT;
    relate act_smt to te_smt across R2038;
    // Connect the statement to its parent block.
    relate te_smt to te_blk across R2078;
    if ( first_smt )
      // CDS WARNING!! This assumes the gen_erate will give us the first statement first!
      relate te_blk to te_smt across R2014;
      first_smt = false;
    end if;
    te_smt.OAL = "";
    te_smt.buffer = "";
    te_smt.buffer2 = "";
    te_smt.trace = "";
          end for;
  // Link the te_smts into order like the act_smts.
  for each act_smt in act_smts
    select one te_smt related by act_smt->TE_SMT[R2038];
    select one next_act_smt related by act_smt->ACT_SMT[R661.''precedes''];
    if ( not_empty next_act_smt )
      select one next_te_smt related by next_act_smt->TE_SMT[R2038];
      relate te_smt to next_te_smt across R2012.''precedes'';
    end if;
  end for;
end for;
//
// Connect up statements and blocks in the extended subsystem.
// We want statements to know:
// 1) containing block
// 2) sub-block
// [for, while, if, elif and else statements have sub-blocks.]
select many act_fors from instances of ACT_FOR;
for each act_for in act_fors
  select one te_smt related by act_for->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_for->ACT_BLK[R605]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_FOR";
end for;
select many act_whls from instances of ACT_WHL;
for each act_whl in act_whls
  select one te_smt related by act_whl->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_whl->ACT_BLK[R608]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_WHL";
end for;
select many act_ifs from instances of ACT_IF;
for each act_if in act_ifs
  select one te_smt related by act_if->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_if->ACT_BLK[R607]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_IF";
end for;
select many act_els from instances of ACT_EL;
for each act_el in act_els
  select one te_smt related by act_el->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_el->ACT_BLK[R658]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_EL";
end for;
select many act_es from instances of ACT_E;
for each act_e in act_es
  select one te_smt related by act_e->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_e->ACT_BLK[R606]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_E";
end for;
// Calculate the block depth to be used for indentation.
select many te_blks from instances of TE_BLK;
for each te_blk in te_blks
  select one parent_te_blk related by te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  while ( not_empty parent_te_blk )
    te_blk.depth = te_blk.depth + 1;
    select one parent_te_blk related by parent_te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  end while;
  r = ::blk_indentwhitespace( indentation:te_blk.depth );
  te_blk.indentation = r;
end for;
//
// Create the generated chain links and connect them to the ACT_LNKs.
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  ::FactoryTE_LNK( act_lnk:act_lnk );
end for;
// Link the chain links together in extensions as in meta-model proper.
select many te_lnks from instances of TE_LNK;
for each te_lnk in te_lnks
  select one act_lnk related by te_lnk->ACT_LNK[R2042];
  select one next_act_lnk related by act_lnk->ACT_LNK[R604.''precedes''];
  if ( not_empty next_act_lnk )
    select one next_te_lnk related by next_act_lnk->TE_LNK[R2042];
    relate te_lnk to next_te_lnk across R2075.''precedes'';
    // We populate this here.  Populate firsts during statement linkage.
    next_te_lnk.left = te_lnk.linkage;
    // We may have traversed directly from aoth to aone (or vice versa)
    // across an associative association.  If so, insert the associative
    // link between the two ends to enable the traversal.
    r = ::detect_and_insert_associator_TE_LNK( te_lnk:te_lnk, next_te_lnk:next_te_lnk, act_lnk:act_lnk, next_act_lnk:next_act_lnk, start_o_obj:empty_o_obj );
    discard = r;
  else
    // We can detect the end of the chain here.
    // We will detect the beginning during statement linkage.
    if ( not_empty te_lnk )
      te_lnk.last = true;
    end if;
  end if;
end for;
//
// Create the variables and connect them to the V_VAR.
select many v_vars from instances of V_VAR;
for each v_var in v_vars
  create object instance te_var of TE_VAR;
  relate v_var to te_var across R2039;
  if ( "self" == T::l(s:v_var.Name) )
    te_var.OAL = "self";
    te_var.buffer = te_instance.self;
  else
    te_var.OAL = v_var.Name;
    te_var.buffer = T::underscore(s:v_var.Name);
    if ( "C++" == te_target.language )
      // This prepends characters to transients in case the modeler used a C keyword.
      te_var.buffer = "v_" + te_var.buffer;
    end if;
  end if;
  array_spec = "";
  select many s_dims related by v_var->S_DIM[R849];
  te_var.dimensions = cardinality s_dims;
  te_dim = empty_te_dim;
  dim_index = 0;
  while ( dim_index < te_var.dimensions )
    select any s_dim related by v_var->S_DIM[R849] where ( selected.dimensionCount == dim_index );
    r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
    te_dim = r;
    if ( dim_index == 0 )
      relate te_dim to te_var across R2057;
    end if;
    array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    dim_index = dim_index + 1;
  end while;
  te_var.array_spec = array_spec;
  select one te_dt related by v_var->S_DT[R848]->TE_DT[R2021];
  if ( not_empty te_dt )
    // In the C model compiler, treat strings as arrays.
    if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
      // string
      te_var.dimensions = te_var.dimensions + 1;
      te_var.array_spec = ( te_var.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  else
    msg = ( "\nERROR:  Did not find a datatype associated with variable " + v_var.Name ) + ".\n";
    msg = msg + "Check usages of variable for parse errors in the action language.\n";
    msg = msg + "[Parse All Activies and look for errors in the Problems view.]\n";
    T::print(s:"${msg}");
  end if;
end for;
//
//
//
// Continue initializing the components created and linked above.
// Recurse down into the component-level artifacts.
select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Initialize the te_sync instances.
  select many te_syncs related by te_c->TE_SYNC[R2084];
  r = ::sync_sort( te_syncs:te_syncs );
  te_sync = r;
  if ( not_empty te_sync )
    relate te_c to te_sync across R2097;
  end if;
  for each te_sync in te_syncs
    select one s_sync related by te_sync->S_SYNC[R2023];
    te_sync.IsInitFunction = false;
    te_sync.IsSafeForInterrupts = false;
    te_sync.XlateSemantics = true;
    te_sync.deferred_method = te_sync.GeneratedName + "_deferred";
    select any tm_sync from instances of TM_SYNC where ( ( selected.RegisteredDomain == te_c.Name ) and ( selected.Name == te_sync.Name ) );
    if ( not_empty tm_sync )
      te_sync.IsSafeForInterrupts = tm_sync.IsSafeForInterrupts;
      select one rval_dt related by s_sync->S_DT[R25];
      if ( rval_dt.Name != "void" )
        T::print(s:"ERROR:  Function ${te_sync.Name} in ${te_c.Name}");
        T::print(s:"is trying to return data.  Functions marked as safe for");
        T::print(s:"interrupt invocation cannot return data.  They must be");
        T::print(s:"of return type void.");
        T::print(s:"Change the return type of the function or do not mark");
        T::print(s:"it as SafeForInterrupts.");
        T::exit(i:100);
      end if;
    end if;
    if ( te_sync.IsSafeForInterrupts )
      te_sync.intraface_method = te_sync.GeneratedName + "_sync";
    else
      te_sync.intraface_method = te_sync.GeneratedName;
    end if;
    select one te_dt related by s_sync->S_DT[R25]->TE_DT[R2021];
    select many te_parms related by s_sync->S_SPARM[R24]->TE_PARM[R2030];
    r1 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_c.Name, name:te_sync.GeneratedName, subtypeKL:"S_SYNC", te_dt:te_dt );
    te_aba = r1;
    relate te_sync to te_aba across R2010;
    select one te_blk related by s_sync->ACT_FNB[R695]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    if ( not_empty te_blk )
      relate te_blk to te_aba across R2011;
    end if;
  end for;
  //
  // Create the Generated External Entity instances and link them in.
  select many te_ees related by te_c->TE_EE[R2085];
  for each te_ee in te_ees
    ::TE_EE_init( te_ee:te_ee, te_c:te_c );
  end for;
  r1 = ::ee_sort( te_ees:te_ees );
  te_ee = r1;
  if ( not_empty te_ee )
    relate te_c to te_ee across R2098;
  end if;
  //
  select many te_macts related by te_c->TE_MACT[R2002];
  for each te_mact in te_macts
    select one te_aba related by te_mact->TE_ABA[R2010];
    select any te_blk from instances of TE_BLK where ( false );
    if ( "SPR_PO" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_PO[R2050]->ACT_POB[R687]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_RO" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_RO[R2052]->ACT_ROB[R685]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_PS" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_PS[R2051]->ACT_PSB[R686]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    elif ( "SPR_RS" == te_mact.subtypeKL )
      select one te_blk related by te_mact->SPR_RS[R2053]->ACT_RSB[R684]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
    end if;
    if ( not_empty te_blk )
      relate te_blk to te_aba across R2011;
    end if;
  end for;
  //
  // Initialize the Generated Class instances.
  select many te_classs related by te_c->TE_CLASS[R2064];
  for each te_class in te_classs
    select one o_obj related by te_class->O_OBJ[R2019];
    // Initialize model compiler extension attributes.
    te_class.SelfCreated = false;
    te_class.NonSelfCreated = false;
    te_class.Included = false;
    te_class.IsFixedPopulation = false;
    te_class.PEIsDefinedInData = false;
    te_class.IsReadOnly = false;
    // Default is 10 instances per class.
    te_class.MaxExtentSize = 10;
    te_class.Persistent = false;
    te_class.ExcludeFromGen = false;
    te_class.IsTrace = true;
    te_class.ContainerIndex = 0;
    te_class.Task = 0;
    te_class.class_file = te_class.GeneratedName + "_class";
    te_class.system_class_number = te_class.GeneratedName + "_CLASS_NUMBER";
    te_class.CBsystem_class_number = te_class.GeneratedName + "_CLASS_NUMBER_CB";
    te_class.dispatcher = "";
    te_class.CBdispatcher = "";
    select one sm_ism related by o_obj->SM_ISM[R518];
    if ( not_empty sm_ism )
      te_class.dispatcher = te_class.GeneratedName + "_Dispatch";
    end if;
    select one sm_asm related by o_obj->SM_ASM[R519];
    if ( not_empty sm_asm )
      te_class.CBdispatcher = te_class.GeneratedName + "_CBDispatch";
    end if;
    te_class.persist_link = te_class.GeneratedName + "_LinkCentral";
    //
    // Create the Generated Attribute instances and link them to the real ones.
    delimiter = "";
    prev_te_attr = empty_te_attr;
    // Find first o_attr.
    select any o_attr related by o_obj->O_ATTR[R102];
    while ( not_empty o_attr )
      select one prev_o_attr related by o_attr->O_ATTR[R103.''succeeds''];
      if ( empty prev_o_attr )
        break;
      end if;
      o_attr = prev_o_attr;
    end while;
    while ( not_empty o_attr )
      create object instance te_attr of TE_ATTR;
      te_attr.Name = o_attr.Name;
      te_attr.GeneratedName = T::r(s:o_attr.Name);
      te_attr.DefaultValue = o_attr.DefaultValue;
      te_attr.Used = false;
      te_attr.read = false;
      te_attr.written = false;
      te_attr.Included = false;
      te_attr.Order = 0;
      te_attr.ParamBuffer = "";
      te_attr.translate = true;
      relate te_attr to o_attr across R2033;
      relate te_attr to te_class across R2061;
            if ( not_empty prev_te_attr )
        relate prev_te_attr to te_attr across R2087.''precedes'';
      end if;
      select many s_dims related by o_attr->S_DIM[R120];
      array_spec = "";
      te_attr.dimensions = cardinality s_dims;
      te_dim = empty_te_dim;
      dim_index = 0;
      while ( dim_index < te_attr.dimensions )
        select any s_dim related by o_attr->S_DIM[R120] where ( selected.dimensionCount == dim_index );
        r2 = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
        te_dim = r2;
        if ( dim_index == 0 )
          relate te_dim to te_attr across R2055;
        end if;
        array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
        dim_index = dim_index + 1;
      end while;
      te_attr.array_spec = array_spec;
      select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
      // Potentially substitute data type for base attribute data type.
      if ( 7 == te_dt.Core_Typ )
        // referential attribute
        r2 = ::GetAttributeCodeGenType( o_attr:o_attr );
        te_dt = r2;
      end if;
      te_attr.GeneratedType = te_dt.ExtName;
      o_attr_Descrip_Persistent = T::parsekeyword(s:o_attr.Descrip,key:"Persistent");
      if ( o_attr_Descrip_Persistent != "false" )
        if ( "%p" == te_dt.string_format )
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + "%ld";
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    ((long)self->" ) + ( te_attr.GeneratedName + " & ESCHER_IDDUMP_MASK)" );
        elif ( "%s" == te_dt.string_format )
          // Place an escaped tick mark around the %s in the attribute format string.
          te_class.attribute_format = ( ( te_class.attribute_format + delimiter ) + ( "''''" + te_dt.string_format ) ) + "''''";
          te_class.attribute_dump = ( ( ( te_class.attribute_dump + ",\n    ( 0 != self->" ) + ( te_attr.GeneratedName + " ) ? self->" ) ) + ( ( te_attr.GeneratedName + " : " ) + "" ) );
        else
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + te_dt.string_format;
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    self->" ) + te_attr.GeneratedName;
        end if;
      end if;
      // In the C model compiler, treat strings as arrays.
      if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
        // string
        te_attr.dimensions = te_attr.dimensions + 1;
        te_attr.array_spec = ( te_attr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
      end if;
      //
      // Create the Action Block Anchors associated with each action
      // in the user model.  Initialize and link them.
      // Create and link the Generated versions of each of the action homes.
      select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
      if ( not_empty o_dbattr )
        create object instance te_dbattr of TE_DBATTR;
        te_dbattr.Included = false;
        te_dbattr.GeneratedName = ( te_class.GeneratedName + "_MDA_" ) + o_attr.Name;
        relate o_dbattr to te_dbattr across R2026;
        select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
        te_parms = empty_te_parms;
        r2 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:"", name:te_dbattr.GeneratedName, subtypeKL:"O_DBATTR", te_dt:te_dt );
        te_aba = r2;
        relate te_dbattr to te_aba across R2010;
        select one te_blk related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
        if ( not_empty te_blk )
          relate te_blk to te_aba across R2011;
        end if;
      end if;
      delimiter = ",";
      prev_te_attr = te_attr;
      select one o_attr related by o_attr->O_ATTR[R103.''precedes''];
    end while;
    //
    // Create the Generated State Machines and connect them to SM_SM.
    select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:true, sm_sm:sm_sm, te_class:te_class );
    end if;
    select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:false, sm_sm:sm_sm, te_class:te_class );
    end if;
    //
    // Create and relate the generated class operations.
    select many o_tfrs related by o_obj->O_TFR[R115];
    for each o_tfr in o_tfrs
      create object instance te_tfr of TE_TFR;
      te_tfr.Included = false;
      te_tfr.XlateSemantics = true;
      ib = Scope::Instance;
      if ( ib == o_tfr.Instance_Based )
        te_tfr.Instance_Based = 1;
      else
        te_tfr.Instance_Based = 0;
      end if;
      te_tfr.Key_Lett = te_class.Key_Lett;
      te_tfr.Name = o_tfr.Name;
      te_tfr.GeneratedName = ( ( te_c.Name + "_" ) + ( te_tfr.Key_Lett + "_op_" ) ) + te_tfr.Name;
      relate o_tfr to te_tfr across R2024;
      select one te_dt related by o_tfr->S_DT[R116]->TE_DT[R2021];
      select many te_parms related by o_tfr->O_TPARM[R117]->TE_PARM[R2029];
      r2 = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_class.GeneratedName, name:te_tfr.GeneratedName, subtypeKL:"O_TFR", te_dt:te_dt );
      te_aba = r2;
      relate te_tfr to te_aba across R2010;
      select one te_blk related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
      if ( not_empty te_blk )
        relate te_blk to te_aba across R2011;
      end if;
    end for;
    //
    // Create the WhereKey instance connected to O_ID.
    select many o_ids related by o_obj->O_ID[R104];
    for each o_id in o_ids
      create object instance te_where of TE_WHERE;
      te_where.WhereKey = false;
      relate te_where to o_id across R2032;
      number = te_where.Oid_ID + 1;
      te_where.select_any_where = ( te_class.GeneratedName + "_AnyWhere" ) + T::s(i:number);
    end for;
  end for;
end for;
//
select many te_ees from instances of TE_EE;
for each te_ee in te_ees
  select one te_c related by te_ee->TE_C[R2085];
  if ( empty te_c )
    ::TE_EE_init( te_ee:te_ee, te_c:empty_te_c );
  end if;
end for;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("2590511b-ed78-4dc5-b843-342093a9bd59",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d5163c77-9057-4051-8f5b-53eb896adcd4",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_CLASS',
	'',
	'//
//
//============================================================================
// New and return instance of TE_CLASS.
//============================================================================
o_obj = param.o_obj;
te_c = param.te_c;
// Create the Generated Class instance and link it to the model one.
create object instance te_class of TE_CLASS;
relate te_class to o_obj across R2019;
relate te_class to te_c across R2064;
// Copy the Numb attribute for sorting purposes.
te_class.Numb = o_obj.Numb;
// Copy other attributes for convenience so we can avoid accessing o_obj.
te_class.Name = o_obj.Name;
te_class.Key_Lett = o_obj.Key_Lett;
te_class.Key_Lett = T::r(s:te_class.Key_Lett);
// Initialize model compiler extension attributes.
te_class.GeneratedName = ( te_c.Name + "_" ) + te_class.Key_Lett;
te_class.CBGeneratedName = te_class.GeneratedName + "_CB";
te_class.scope = "";
te_class.attribute_format = "";
return te_class;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("140f1409-3829-449e-b07d-2c72ac601832",
	"d5163c77-9057-4051-8f5b-53eb896adcd4",
	'o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("7d3033e7-0343-45d8-9547-f9baa66801db",
	"d5163c77-9057-4051-8f5b-53eb896adcd4",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"140f1409-3829-449e-b07d-2c72ac601832",
	'');
INSERT INTO PE_PE
	VALUES ("d5163c77-9057-4051-8f5b-53eb896adcd4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b53f3b12-fd18-4d26-a05e-3a16453f809c",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_DIM',
	'',
	'//
//
//============================================================================
// New and return instance of TE_DIM.
//============================================================================
s_dim = param.s_dim;
predecessor_te_dim = param.predecessor_te_dim;
create object instance te_dim of TE_DIM;
te_dim.elementCount = s_dim.elementCount;
if ( 0 == te_dim.elementCount )
  // Here we have a VLA (variable length array).
  // Add support here.
end if;
te_dim.dimensionCount = s_dim.dimensionCount;
if ( not_empty predecessor_te_dim )
  relate te_dim to predecessor_te_dim across R2060.''succeeds'';
end if;
return te_dim;
',
	"c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("7e047df5-b4c5-441c-a1b3-3972a56e17ba",
	"b53f3b12-fd18-4d26-a05e-3a16453f809c",
	's_dim',
	"15158ac6-71a4-4ce8-8756-ebf92d171d09",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15158ac6-71a4-4ce8-8756-ebf92d171d09",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Dimensions>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("2de4c54d-4306-46e3-a74a-98a4690e2114",
	"b53f3b12-fd18-4d26-a05e-3a16453f809c",
	'predecessor_te_dim',
	"c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	0,
	'',
	"7e047df5-b4c5-441c-a1b3-3972a56e17ba",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Dimension>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b53f3b12-fd18-4d26-a05e-3a16453f809c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c88f634c-299b-43a6-966f-433416f5d264",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_SM',
	'',
	'//
//
//============================================================================
// New and link state machine instances.
// Allocate and link state instances (in numerically sorted order).
//============================================================================
is_ism = param.is_ism;
sm_sm = param.sm_sm;
te_class = param.te_class;
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
select many empty_te_parms from instances of TE_PARM where ( false );
select one te_c related by te_class->TE_C[R2064];
create object instance te_sm of TE_SM;
relate te_sm to te_class across R2072;
relate te_sm to sm_sm across R2043;
te_sm.complete = false;
class_based = "_CB";
if ( is_ism )
  class_based = "";
end if;
te_sm.SEMname = ( te_class.GeneratedName + class_based ) + "_StateEventMatrix";
te_sm.state_names_array = ( "state_name_strings" + class_based );
te_sm.action_array = ( te_class.GeneratedName + class_based ) + "_acts";
te_sm.txn_action_array = ( te_class.GeneratedName + class_based ) + "_xacts";
te_sm.action_type = "StateAction_t";
te_sm.events_union = ( te_class.GeneratedName + class_based ) + "_Events_u";
//
// Create the Generated States and connect them to SM_STATE.
select many sm_states related by sm_sm->SM_STATE[R501];
te_sm.num_states = cardinality sm_states;
for each sm_state in sm_states
  create object instance te_state of TE_STATE;
  te_state.Name = sm_state.Name;
  te_state.Numb = sm_state.Numb;
  relate te_state to sm_state across R2037;
  te_state.enumerator = ( te_class.GeneratedName + class_based ) + ( "_STATE_" + T::s(i:te_state.Numb) );
  //
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_act" + T::s(i:te_state.Numb) );
  //.select many te_parms related by sm_state->SM_SEME[R503]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  select one te_blk related by sm_act->ACT_SAB[R691]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
end for;
//
// Sort the states for later state event matrix generation.
select many te_states related by sm_states->TE_STATE[R2037];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set = te_states;
//
// Clear the Order attribute of all set members.
for each item in item_set
  item.Order = 0;
end for;
// simple pseudo bubble sort
item_set_copy = item_set;
for each item in item_set
  for each item_copy in item_set_copy
    if ( item_copy.Numb > item.Numb )
      item_copy.Order = item_copy.Order + 1;
    end if;
  end for;
end for;
for each te_state in te_states
  te_state.number = te_state.Order + 1;
  if ( 0 == te_state.Order )
    te_sm.initial_state = te_state.enumerator;
  end if;
end for;
//
// Create the actions for the transitions.
counter = 1;
// This is the hairiest traversal we do.  We are finding actions
// that actually have action language.
select many sm_acts related by sm_sm->SM_TXN[R505]->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514]->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602]->ACT_BLK[R602]->ACT_ACT[R666]->ACT_TAB[R698]->SM_ACT[R688];
for each sm_act in sm_acts
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  select one sm_state related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_STATE[R506];
  te_act.GeneratedName = ( ( te_class.GeneratedName + class_based ) + ( "_xact_to_" + T::s(i:sm_state.Numb) ) ) + ( "_" + T::s(i:counter) );
  te_act.number = counter;
  //.select many te_parms related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  select one te_blk related by sm_act->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
  counter = counter + 1;
end for;
te_sm.txn_action_count = counter - 1;
//
// Create the Generated Events and connect them to SM_EVT.
select many sm_evts related by sm_sm->SM_EVT[R502];
te_sm.num_events = cardinality sm_evts;
for each sm_evt in sm_evts
  create object instance te_evt of TE_EVT;
  relate te_evt to te_sm across R2071;
  te_evt.Name = sm_evt.Mning;
  te_evt.Numb = sm_evt.Numb;
  te_evt.Order = 0;
  te_evt.Used = false;
  te_evt.UsedCount = 0;
  te_evt.Priority = 0;
  relate te_evt to sm_evt across R2036;
  suffix = T::s(i:te_evt.Numb);
  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    // Non local event defined by a polymorphic event
    select one super_sm_evt related by sm_nlevt->SM_PEVT[R527]->SM_EVT[R525];
    select one super_obj related by super_sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    suffix = ( "_" + T::r(s:super_obj.Key_Lett) ) + ( "_PE" + T::s(i:super_sm_evt.Numb) );
  end if;
  te_evt.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "event" + suffix );
  te_evt.Enumerator = T::u(s:te_evt.GeneratedName) + "NUM";
end for;
// Select the local events (only in this state machine), the "true" events
// (land here but also seen as polys) and polymorphic events.  Order the
// events starting with local then true then polys.
select many sm_levts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526];
select many local_te_evts related by sm_levts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set1 = local_te_evts;
//
// Clear the Order attribute of all set members.
for each item1 in item_set1
  item1.Order = 0;
end for;
// simple pseudo bubble sort
item_set1_copy = item_set1;
for each item1 in item_set1
  for each item1_copy in item_set1_copy
    if ( item1_copy.Numb > item1.Numb )
      item1_copy.Order = item1_copy.Order + 1;
    end if;
  end for;
end for;
last_event_number = cardinality local_te_evts;
last_event_number = last_event_number - 1;
select many sm_sgevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_SGEVT[R526];
select many signal_te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in signal_te_evts
  // Mark signals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
  // Link each signal te_mact to its associated signal te_evts.
  select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_PS[R528]->TE_MACT[R2051];
  if ( empty te_mact )
    select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_RS[R529]->TE_MACT[R2053];
  end if;
  if ( not_empty te_mact )
    relate te_mact to te_evt across R2082;
  end if;
end for;
select many sm_nlevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
select many true_te_evts related by sm_nlevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in true_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
// Finally, order the polymorphic events.
// We need their Order to be greater than local and true events, since
// polys are not state event matrix events.
select many poly_te_evts related by sm_sm->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in poly_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("37e6e5a6-7481-497f-b01d-495f96099757",
	"c88f634c-299b-43a6-966f-433416f5d264",
	'is_ism',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("9e223cda-d6b8-4b5f-8099-4ceb9e914909",
	"c88f634c-299b-43a6-966f-433416f5d264",
	'sm_sm',
	"bf37869c-96be-4535-a678-ac4311589cbb",
	0,
	'',
	"37e6e5a6-7481-497f-b01d-495f96099757",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bf37869c-96be-4535-a678-ac4311589cbb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("c9ebbe9a-365f-4fe7-a171-2a682d3b6122",
	"c88f634c-299b-43a6-966f-433416f5d264",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"9e223cda-d6b8-4b5f-8099-4ceb9e914909",
	'');
INSERT INTO PE_PE
	VALUES ("c88f634c-299b-43a6-966f-433416f5d264",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_MACT',
	'',
	'//
//
//============================================================================
// New and link message actions.
//============================================================================
te_parms = param.te_parms;
te_dt = param.te_dt;
te_c = param.te_c;
te_po = param.te_po;
message_name = param.message_name;
subtypeKL = param.subtypeKL;
select any te_file from instances of TE_FILE;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
create object instance te_mact of TE_MACT;
relate te_mact to te_c across R2002;
relate te_mact to te_po across R2006;
// We cannot just look to see if this port is polymorphic, we have to go to the
// associated interface and see if any port tied to that interface is polymorphic.
// TODO - We would like to move this -up- and handle it when the ports are created,
//   perhaps use 2081 for the satisfaction.
select one c_i related by te_po->C_I[R2007];
select any te_po_poly related by c_i->TE_PO[R2007] where ( ( selected.Provision == te_po.Provision ) and selected.polymorphic );
if ( empty te_po_poly )
  te_mact.polymorphic = false;
else
  te_mact.polymorphic = true;
end if;
te_mact.subtypeKL = subtypeKL;
te_mact.Provision = te_po.Provision;
te_mact.MessageName = message_name;
te_mact.InterfaceName = te_po.InterfaceName;
te_mact.PortName = te_po.GeneratedName;
te_mact.ComponentName = te_c.Name;
te_mact.GeneratedName = ( ( te_mact.ComponentName + "_" ) + ( te_mact.PortName + "_" ) ) + message_name;
if ( "C++" == te_target.language )
  te_mact.GeneratedName = ( te_mact.InterfaceName + "_" ) + message_name;
end if;
te_mact.GeneratedName = T::r(s:te_mact.GeneratedName);
te_mact.Name = te_mact.GeneratedName;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
if ( ( "SystemC" == te_thread.flavor ) and ( te_sys.SystemCPortsType == "TLM" ) )
  for each te_parm in te_parms
    // If we are using TLM ports, convert booleans to integers
    select one param_te_dt related by te_parm->TE_DT[R2049];
    if ( 1 == param_te_dt.Core_Typ )
      relate te_parm to converted_bool_te_dt across R2049;
    end if;
  end for;
end if;
if ( ( te_mact.polymorphic ) and ( "SystemC" == te_thread.flavor ) )
  // If polymorphic, then add a parameter that we can use to distinguish 
  // which port the message came in through.
  select many s_dims from instances of S_DIM where ( false );
  select any portindex_te_dt from instances of TE_DT where ( selected.Name == "integer" );
  r1 = ::FactoryTE_PARM( s_dims:s_dims, te_dt:portindex_te_dt, prefix:"", name:"A00portindex", by_ref:0 );
  polymorphic_te_parm = r1;
  polymorphic_te_parm.Descrip = "architectural port selector";
  for each te_parm in te_parms
    if ( 0 == te_parm.Order )
      relate polymorphic_te_parm to te_parm across R2041.''precedes'';
    end if;
  end for;
  te_parms = te_parms;
end if;
r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_mact.ComponentName, name:te_mact.GeneratedName, subtypeKL:"TE_MACT", te_dt:te_dt );
te_aba = r;
relate te_mact to te_aba across R2010;
return te_mact;
',
	"7268e543-f48e-4464-ba70-227deff22727",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("632f0594-a4eb-40c0-beb3-9c7c20d29ba4",
	"fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("fa924079-ccf9-4e33-bb5c-e5a65417c6dd",
	"fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"632f0594-a4eb-40c0-beb3-9c7c20d29ba4",
	'');
INSERT INTO S_SPARM
	VALUES ("db06517b-0a14-4888-b5ad-9e82222bd02e",
	"fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"fa924079-ccf9-4e33-bb5c-e5a65417c6dd",
	'');
INSERT INTO S_SPARM
	VALUES ("4e420494-a8f3-4141-9dff-86c5afc3bf0f",
	"fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	'te_po',
	"472879e3-2bbf-4ca8-9fd2-6077af1f409a",
	0,
	'',
	"db06517b-0a14-4888-b5ad-9e82222bd02e",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("472879e3-2bbf-4ca8-9fd2-6077af1f409a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Port>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("24f72a13-6762-455b-8ddf-b34f2158c435",
	"fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	'message_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4e420494-a8f3-4141-9dff-86c5afc3bf0f",
	'');
INSERT INTO S_SPARM
	VALUES ("155e5e12-d501-4a4c-aaef-c4e5269ca86a",
	"fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"24f72a13-6762-455b-8ddf-b34f2158c435",
	'');
INSERT INTO PE_PE
	VALUES ("fa2301fd-eaaa-4ea6-9ee7-a3ccd72dd009",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("7268e543-f48e-4464-ba70-227deff22727",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Message Action>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("5af1cffd-fa78-4a45-ba9f-8895fd329da6",
	"00000000-0000-0000-0000-000000000000",
	'TE_EE_init',
	'',
	'//
//============================================================================
// Initialize instance of TE_EE.
//============================================================================
te_ee = param.te_ee;
te_c = param.te_c;
select any te_file from instances of TE_FILE;
select any te_target from instances of TE_TARGET;
component_scope = "";
if ( not_empty te_c )
  component_scope = te_c.Name + "_";
end if;
select one s_ee related by te_ee->S_EE[R2020];
// Default the registered name to be the key letters.
// Bridge wiring will override this default, but the default may
// allow the code to compile.
te_ee.Name = s_ee.Name;
te_ee.Descrip = s_ee.Descrip;
te_ee.Key_Lett = s_ee.Key_Lett;
te_ee.RegisteredName = component_scope + T::r(s:te_ee.Key_Lett);
te_ee.Included = false;
te_ee.Used = false;
te_ee.file = te_ee.RegisteredName + "_bridge";
// Leave alone if marked.
if ( "" == te_ee.Include_File )
  te_ee.Include_File = te_ee.file + ( "." + te_file.hdr_file_ext );
end if;
if ( "TIM" == s_ee.Key_Lett )
  // Time (TIM) EE
  te_ee.RegisteredName = "TIM";
  te_ee.Include_File = te_file.tim + ( "." + te_file.hdr_file_ext );
end if;
bridge_scope = "";
if ( "C" == te_target.language )
  bridge_scope = te_ee.RegisteredName + "_";
end if;
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  create object instance te_brg of TE_BRG;
  relate te_brg to s_brg across R2025;
  relate te_brg to te_ee across R2089;
  te_brg.EEkeyletters = s_ee.Key_Lett;
  te_brg.EEname = s_ee.Name;
  te_brg.Name = s_brg.Name;
  te_brg.GeneratedName = bridge_scope + s_brg.Name;
  select one te_dt related by s_brg->S_DT[R20]->TE_DT[R2021];
  select many te_parms related by s_brg->S_BPARM[R21]->TE_PARM[R2028];
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_ee.RegisteredName, name:te_brg.GeneratedName, subtypeKL:"S_BRG", te_dt:te_dt );
  te_aba = r;
  relate te_brg to te_aba across R2010;
  select one te_blk related by s_brg->ACT_BRB[R697]->ACT_ACT[R698]->ACT_BLK[R666]->TE_BLK[R2016];
  if ( not_empty te_blk )
    relate te_blk to te_aba across R2011;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("82c007d5-adf3-444a-a1a0-e10256114d7e",
	"5af1cffd-fa78-4a45-ba9f-8895fd329da6",
	'te_ee',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0be55aee-8704-4315-87a2-36ca7fc72b22",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended External Entity>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("d91f7ae0-f00f-47f9-8ae2-93c39cde67c3",
	"5af1cffd-fa78-4a45-ba9f-8895fd329da6",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"82c007d5-adf3-444a-a1a0-e10256114d7e",
	'');
INSERT INTO PE_PE
	VALUES ("5af1cffd-fa78-4a45-ba9f-8895fd329da6",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_ABA',
	'',
	'//
//============================================================================
// New and return instance of TE_ABA.
//============================================================================
te_c = param.te_c;
te_parms = param.te_parms;
scope = param.scope;
name = param.name;
subtypeKL = param.subtypeKL;
te_dt = param.te_dt;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
create object instance te_aba of TE_ABA;
te_aba.SelfEventCount = 0;
te_aba.NonSelfEventCount = 0;
te_aba.subtypeKL = subtypeKL;
if ( not_empty te_c )
  relate te_aba to te_c across R2088;
end if;
duplicates_needed = false;
select any te_parm from instances of TE_PARM where ( false );
for each te_parm in te_parms
  select one existing_te_aba related by te_parm->TE_ABA[R2062];
  if ( empty existing_te_aba )
    relate te_parm to te_aba across R2062;
  else
    duplicates_needed = true;
  end if;
end for;
first_te_parm = te_parm;
if ( duplicates_needed or ( ( "c_t" == te_dt.ExtName ) or ( "c_t *" == te_dt.ExtName ) ) )
  // Find first te_parm.
  while ( not_empty te_parm )
    select one prev_te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
    if ( empty prev_te_parm )
      first_te_parm = te_parm;
      break;
    else
      te_parm = prev_te_parm;
    end if;
  end while;
end if;
// This duplication is needed because multiple ports can use the same
// interface.  It would be nice to explore a method to avoid duplicating
// the parameter instances.
if ( duplicates_needed )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''succeeds''] where ( false );
  while ( not_empty te_parm )
    r = ::TE_PARM_duplicate( te_parm:te_parm );
    duplicate_te_parm = r;
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty prev_te_parm )
      relate prev_te_parm to duplicate_te_parm across R2041.''precedes'';
    end if;
    prev_te_parm = duplicate_te_parm;
    select one te_parm related by te_parm->TE_PARM[R2041.''precedes''];
  end while;
  select many te_parms related by te_aba->TE_PARM[R2062];
end if;
// Create and insert an architectural parameter for returning a string.
if ( ( "c_t" == te_dt.ExtName ) or ( "c_t *" == te_dt.ExtName ) )
  if ( ( not te_sys.InstanceLoading ) and ( not duplicates_needed ) )
    // mcmc does not return through the by-ref parameter.
    // When duplicating, there is a duplicate by-ref string return parameter.
    select any string_te_parm from instances of TE_PARM where ( selected.Name == "A0xtumlsret" );
    r = ::TE_PARM_duplicate( te_parm:string_te_parm );
    duplicate_te_parm = r;
    duplicate_te_parm.Descrip = "xtuml string return parm";
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty first_te_parm )
      relate duplicate_te_parm to first_te_parm across R2041.''precedes'';
    end if;
    select many te_parms related by te_aba->TE_PARM[R2062];
  end if;
end if;
::te_parm_RenderParameters( te_parms:te_parms, te_aba:te_aba );
te_aba.scope = "";
if ( "C++" == te_target.language )
  te_aba.scope = scope + "::";
  if ( not_empty te_c )
    if ( ( "S_BRG" == te_aba.subtypeKL ) or ( "O_TFR" == te_aba.subtypeKL ) )
      if ( empty te_parms )
        te_aba.ParameterDefinition = ( " " + te_c.Name ) + " * thismodule";
        te_aba.ParameterDeclaration = ( " " + te_c.Name ) + " *";
      else
        te_aba.ParameterDefinition = ( ( " " + te_c.Name ) + ( " * thismodule," + te_aba.ParameterDefinition ) );
        te_aba.ParameterDeclaration = ( ( " " + te_c.Name ) + ( " *," + te_aba.ParameterDeclaration ) );
      end if;
    end if;
  end if;
end if;
te_aba.GeneratedName = name;
te_aba.ReturnDataType = te_dt.ExtName;
te_aba.dimensions = 0;
// In the C model compiler, treat strings as arrays.
if ( ( 4 == te_dt.Core_Typ ) and ( not te_sys.InstanceLoading ) )
  // string
  select any te_string from instances of TE_STRING;
  te_aba.dimensions = te_aba.dimensions + 1;
  te_aba.array_spec = ( te_aba.array_spec + "[" ) + ( te_string.max_string_length + "]" );
end if;
// Allow arrays (including strings) to be returned as pointers.
if ( te_aba.dimensions > 0 )
  te_aba.ReturnDataType = te_aba.ReturnDataType + " *";
end if;
return te_aba;
',
	"5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("4f4d75c3-9bb6-40eb-8543-65892b368be9",
	"01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("13637e24-b392-4d06-bd5b-592c8a2a64ad",
	"01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"4f4d75c3-9bb6-40eb-8543-65892b368be9",
	'');
INSERT INTO S_SPARM
	VALUES ("f853aa52-dc17-471a-b2ee-bd6471bd49df",
	"01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	'scope',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"13637e24-b392-4d06-bd5b-592c8a2a64ad",
	'');
INSERT INTO S_SPARM
	VALUES ("5bdb29ca-9aaf-40a9-bf17-871b5f196b37",
	"01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f853aa52-dc17-471a-b2ee-bd6471bd49df",
	'');
INSERT INTO S_SPARM
	VALUES ("2e374e90-6a19-4104-a5fa-c6f425dc5320",
	"01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5bdb29ca-9aaf-40a9-bf17-871b5f196b37",
	'');
INSERT INTO S_SPARM
	VALUES ("6200451a-8250-4347-a593-09077de8149e",
	"01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"2e374e90-6a19-4104-a5fa-c6f425dc5320",
	'');
INSERT INTO PE_PE
	VALUES ("01e31dd5-0cfa-40e0-a062-d68c84d38c81",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_PARM',
	'',
	'//
//
//============================================================================
// New and link up extended parameter.
//============================================================================
s_dims = param.s_dims;
te_dt = param.te_dt;
prefix = param.prefix;
name = param.name;
by_ref = param.by_ref;
create object instance te_parm of TE_PARM;
te_parm.Order = 0;
te_parm.ParamBuffer = "";
te_parm.OALParamBuffer = "";
te_parm.Name = T::r(s:name);
te_parm.By_Ref = by_ref;
te_parm.GeneratedName = prefix + name;
relate te_parm to te_dt across R2049;
// Set up the array dimensions for the parameter.
te_parm.dimensions = cardinality s_dims;
array_spec = "";
select one te_dim related by te_parm->TE_DIM[R2056] where ( false );
dim_index = 0;
while ( dim_index < te_parm.dimensions )
  for each s_dim in s_dims
    if ( s_dim.dimensionCount == dim_index )
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_parm to te_dim across R2056;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    end if;
  end for;
  dim_index = dim_index + 1;
  te_parm.By_Ref = 0;
end while;
te_parm.array_spec = array_spec;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  select any te_sys from instances of TE_SYS;
  if ( not te_sys.InstanceLoading )
    // string
    select any te_string from instances of TE_STRING;
    te_parm.dimensions = te_parm.dimensions + 1;
    te_parm.array_spec = ( te_parm.array_spec + "[" ) + ( te_string.max_string_length + "]" );
  end if;
  // strings are already by-ref
  te_parm.By_Ref = 0;
end if;
return te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("d87c13a5-34ee-4bbc-9ebd-b78fb8c2c416",
	"70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	's_dims',
	"3a7c5808-2c8c-4c84-865f-70beb289afcd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3a7c5808-2c8c-4c84-865f-70beb289afcd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Dimensions>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("a4c69836-ffc1-452b-ad52-947865266654",
	"70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"d87c13a5-34ee-4bbc-9ebd-b78fb8c2c416",
	'');
INSERT INTO S_SPARM
	VALUES ("97853c27-a692-4c2b-a24f-904b6e6d2078",
	"70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	'prefix',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a4c69836-ffc1-452b-ad52-947865266654",
	'');
INSERT INTO S_SPARM
	VALUES ("5a606be4-352f-4a9f-82c8-c25beff71539",
	"70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"97853c27-a692-4c2b-a24f-904b6e6d2078",
	'');
INSERT INTO S_SPARM
	VALUES ("16dba492-39da-4883-a9b0-de22ed9ae8a7",
	"70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	'by_ref',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"5a606be4-352f-4a9f-82c8-c25beff71539",
	'');
INSERT INTO PE_PE
	VALUES ("70edd6f3-5c92-4f47-b028-788d5a00a1b9",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Parameter>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("35b73dba-70b7-4a9e-852d-6900f9453939",
	"00000000-0000-0000-0000-000000000000",
	'TE_PARM_duplicate',
	'',
	'//
//============================================================================
// Duplicate (copy) an instance of TE_PARM.
//============================================================================
te_parm = param.te_parm;
create object instance duplicate_te_parm of TE_PARM;
duplicate_te_parm.Order = te_parm.Order;
duplicate_te_parm.ParamBuffer = te_parm.ParamBuffer;
duplicate_te_parm.OALParamBuffer = te_parm.OALParamBuffer;
duplicate_te_parm.Name = te_parm.Name;
duplicate_te_parm.Descrip = te_parm.Descrip;
duplicate_te_parm.By_Ref = te_parm.By_Ref;
duplicate_te_parm.GeneratedName = te_parm.GeneratedName;
select one te_dt related by te_parm->TE_DT[R2049];
relate duplicate_te_parm to te_dt across R2049;
duplicate_te_parm.dimensions = te_parm.dimensions;
select one te_dim related by te_parm->TE_DIM[R2056];
if ( not_empty te_dim )
  relate duplicate_te_parm to te_dim across R2056;
else
  end if;
duplicate_te_parm.array_spec = te_parm.array_spec;
return duplicate_te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("5ce66094-2984-4d14-b45c-f0bc11cf6592",
	"35b73dba-70b7-4a9e-852d-6900f9453939",
	'te_parm',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("35b73dba-70b7-4a9e-852d-6900f9453939",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6a78e5fb-6d03-400a-91d5-c6d0622313f4",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_LNK',
	'',
	'//
//============================================================================
// New and return instance of TE_LNK.
//============================================================================
act_lnk = param.act_lnk;
select one o_obj related by act_lnk->O_OBJ[R678];
select one te_class related by o_obj->TE_CLASS[R2019];
if ( not_empty te_class )
  create object instance te_lnk of TE_LNK;
  relate te_lnk to act_lnk across R2042;
  te_lnk.rel_phrase = act_lnk.Rel_Phrase;
    select one r_rel related by act_lnk->R_REL[R681];
  te_lnk.rel_number = r_rel.Numb;
  relate te_lnk to te_class across R2076;
  te_lnk.OAL = ( ( "->" + te_class.Key_Lett ) + ( "[R" + T::s(i:te_lnk.rel_number) ) );
  if ( "" != te_lnk.rel_phrase )
    te_lnk.OAL = ( te_lnk.OAL + "." ) + te_lnk.rel_phrase;
  end if;
  te_lnk.OAL = te_lnk.OAL + "]";
  te_lnk.first = false;
  te_lnk.last = false;
  rel_phrase = T::underscore(s:te_lnk.rel_phrase);
  select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( ( selected.Obj_ID == o_obj.Obj_ID ) and ( selected.rel_phrase == rel_phrase ) );
  if ( empty te_oir )
    select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( selected.Obj_ID == o_obj.Obj_ID );
  end if;
  te_lnk.linkage = te_oir.data_member;
  te_lnk.Mult = te_oir.Mult;
  te_lnk.assoc_type = te_oir.assoc_type;
  // Deal with associative reflexives.
  if ( "assr" == te_oir.assoc_type )
    r = ::is_reflexive( r_rel:r_rel );
    reflexive = r;
    if ( reflexive )
      select one r_aone related by r_rel->R_ASSOC[R206]->R_AONE[R209];
      select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
      if ( te_lnk.rel_phrase == r_aone.Txt_Phrs )
        te_lnk.Mult = r_aone.Mult;
      elif ( te_lnk.rel_phrase == r_aoth.Txt_Phrs )
        te_lnk.Mult = r_aoth.Mult;
      else
        T::print(s:"ERROR:  Unrecognized reflexive association:  R$t{r_rel.Numb}.");
        T::exit(i:13);
      end if;
      te_lnk.linkage = ( te_oir.data_member + "_" ) + rel_phrase;
    end if;
  end if;
  te_lnk.iterator = "i" + te_lnk.linkage;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("61b01e36-e774-4d4b-b1d4-215ca914addf",
	"6a78e5fb-6d03-400a-91d5-c6d0622313f4",
	'act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("44344236-6d4d-42b5-b14f-246447643355",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../Selection/Selection.xtuml');
INSERT INTO PE_PE
	VALUES ("6a78e5fb-6d03-400a-91d5-c6d0622313f4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ab10ffa7-f221-4119-8f13-a35ba4733613",
	"00000000-0000-0000-0000-000000000000",
	'associator_TE_LNK',
	'',
	'//
//============================================================================
// Create and insert a new TE_LNK between these two (for associator).
//============================================================================
left_te_lnk = param.left_te_lnk;
right_te_lnk = param.right_te_lnk;
create object instance te_lnk of TE_LNK;
te_lnk.rel_phrase = "";
// Insert the new link in between the left and right TE_LNKs.
relate te_lnk to right_te_lnk across R2075.''precedes'';
select one r_rel related by right_te_lnk->ACT_LNK[R2042]->R_REL[R681];
te_lnk.rel_number = right_te_lnk.rel_number;
select one te_class related by r_rel->R_ASSOC[R206]->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->TE_CLASS[R2019];
relate te_lnk to te_class across R2076;
// Leave OAL blank, because real OAL is not showing this link.
te_lnk.OAL = "";
select any te_oir related by r_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->TE_OIR[R2035];
te_lnk.linkage = te_oir.data_member;
te_lnk.Mult = te_oir.Mult;
te_lnk.assoc_type = te_oir.assoc_type;
// Reflexive associatives put the relationship phrase onto the AONE/AOTH data members.
if ( "" != right_te_lnk.rel_phrase )
  te_lnk.linkage = ( te_lnk.linkage + "_" ) + T::underscore(s:right_te_lnk.rel_phrase);
end if;
if ( not_empty left_te_lnk )
  relate left_te_lnk to te_lnk across R2075.''precedes'';
  te_lnk.left = left_te_lnk.linkage;
  te_lnk.first = false;
else
  te_lnk.left = te_lnk.linkage;
  te_lnk.first = true;
end if;
te_lnk.last = false;
te_lnk.iterator = "i" + te_lnk.linkage;
te_lnk.Mult = right_te_lnk.Mult;
right_te_lnk.Mult = 0;
right_te_lnk.left = te_lnk.linkage;
return te_lnk;
',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("ed1c66c8-434a-4a65-8887-ed4275468660",
	"ab10ffa7-f221-4119-8f13-a35ba4733613",
	'left_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7fafab07-49e2-4355-8187-c89c6b120460",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Chain Link>',
	'',
	'',
	'../Translation OAL/Translation OAL.xtuml');
INSERT INTO S_SPARM
	VALUES ("b5f0b8dd-54aa-4099-ab48-3f96d1c4fa1b",
	"ab10ffa7-f221-4119-8f13-a35ba4733613",
	'right_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"ed1c66c8-434a-4a65-8887-ed4275468660",
	'');
INSERT INTO PE_PE
	VALUES ("ab10ffa7-f221-4119-8f13-a35ba4733613",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	"00000000-0000-0000-0000-000000000000",
	'detect_and_insert_associator_TE_LNK',
	'',
	'//
//============================================================================
// Detect and insert an associator TE_LNK if needed and adjust the te_lnk
// attributes according to the flavor of associative traversal.
// Accept a pair of te_lnk instances or a start_o_obj and one next_te_lnk.
//============================================================================
te_lnk = param.te_lnk;
next_te_lnk = param.next_te_lnk;
act_lnk = param.act_lnk;
next_act_lnk = param.next_act_lnk;
start_o_obj = param.start_o_obj;
if ( not_empty te_lnk )
  select one start_o_obj related by act_lnk->O_OBJ[R678];
end if;
if ( "aone" == next_te_lnk.assoc_type )
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> aone
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aone
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "aoth" == next_te_lnk.assoc_type )
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  if ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> aoth
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aoth
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "assr" == next_te_lnk.assoc_type )
  // For an associator, the multiplicity is that of the far side.
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( r_aone.Obj_ID == r_aoth.Obj_ID )
    // reflexive associative going from aone/aoth to assr
    if ( r_aone.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aone.Mult;
    elif ( r_aoth.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aoth.Mult;
    else
      T::print(s:"Invalid associative reflexive traversal from ${start_o_obj.Name}/${start_o_obj.Key_Lett} to ${next_te_lnk.te_classGeneratedName}.");
      T::exit(i:100);
    end if;
  elif ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> assr
    next_te_lnk.Mult = r_aoth.Mult;
  elif ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> assr
    next_te_lnk.Mult = r_aone.Mult;
  else
    T::print(s:"Invalid associative reflexive traversal from ${start_o_obj.Name}/${start_o_obj.Key_Lett} to ${next_te_lnk.te_classGeneratedName}.");
    T::exit(i:100);
  end if;
end if;
return te_lnk;
',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("41c47c0f-c22f-4bfe-a050-d2288b69e96d",
	"3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	'te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("8f0b4c03-52a1-4d1e-a606-93c1ed3789cd",
	"3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	'next_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"41c47c0f-c22f-4bfe-a050-d2288b69e96d",
	'');
INSERT INTO S_SPARM
	VALUES ("bfbdde44-1fc1-447b-97ba-d0fe1a02408b",
	"3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	'act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"8f0b4c03-52a1-4d1e-a606-93c1ed3789cd",
	'');
INSERT INTO S_SPARM
	VALUES ("7cd27ee1-e9f0-44eb-bd6a-3a3e9cb21c6d",
	"3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	'next_act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"bfbdde44-1fc1-447b-97ba-d0fe1a02408b",
	'');
INSERT INTO S_SPARM
	VALUES ("b771f53b-eba5-4b46-aa89-cf03115f37fc",
	"3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	'start_o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"7cd27ee1-e9f0-44eb-bd6a-3a3e9cb21c6d",
	'');
INSERT INTO PE_PE
	VALUES ("3d2431bb-6ce7-4822-b13a-112c6e9d14f8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fec0a0da-ff3b-4eff-a175-56bb8584d9c4",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_mark_nested_system',
	'',
	'//
// Recursive call to drill down and get all of the nested components and
// component references.
te_cs = param.te_cs;
for each te_c in te_cs
  te_c.included_in_build = true;
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("61994059-f740-41ba-bedc-4be794dfa3ec",
	"fec0a0da-ff3b-4eff-a175-56bb8584d9c4",
	'te_cs',
	"524464d1-f305-4a50-8ac5-89e6a4df72f0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("524464d1-f305-4a50-8ac5-89e6a4df72f0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Component>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("fec0a0da-ff3b-4eff-a175-56bb8584d9c4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d7fd069c-13f1-4162-b8f2-14728611ca35",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_getContainingComponent',
	'',
	'//
// Recursively search upwards through the package hierarchy to find the
// containing (parent/owning) component.
ep_pkg = param.ep_pkg;
select any te_c from instances of TE_C where ( false );
// Return empty te_c for a top-level package with no containing package or component.
select one s_sys related by ep_pkg->S_SYS[R1401];
if ( empty s_sys )
  select one te_c related by ep_pkg->PE_PE[R8001]->C_C[R8003]->TE_C[R2054];
  if ( empty te_c )
    select one parent_ep_pkg related by ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
    if ( not_empty parent_ep_pkg )
      r = ::TE_C_getContainingComponent( ep_pkg:parent_ep_pkg );
      te_c = r;
    end if;
  end if;
end if;
return te_c;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("7b979b26-c239-4c40-addf-1ea92eb94e01",
	"d7fd069c-13f1-4162-b8f2-14728611ca35",
	'ep_pkg',
	"bc235622-5914-4c46-87f7-e7209f83a876",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bc235622-5914-4c46-87f7-e7209f83a876",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("d7fd069c-13f1-4162-b8f2-14728611ca35",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("feeafd82-a305-4eae-965a-aadbc1eaaae8",
	"00000000-0000-0000-0000-000000000000",
	'EP_PKG_getContainingPackage',
	'',
	'//
// Recursively search upwards through the component hierarcy to find the
// containing (parent/owning) package.
c_c = param.c_c;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
if ( empty ep_pkg )
  select one c_c related by c_c->PE_PE[R8001]->C_C[R8003];
  r = ::EP_PKG_getContainingPackage( c_c:c_c );
  ep_pkg = r;
end if;
return ep_pkg;
',
	"bc235622-5914-4c46-87f7-e7209f83a876",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("ad4b72f7-d795-4f12-b7c8-90db53ccdd06",
	"feeafd82-a305-4eae-965a-aadbc1eaaae8",
	'c_c',
	"3a196930-4610-45a6-baf8-3062a2ef9851",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3a196930-4610-45a6-baf8-3062a2ef9851",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("feeafd82-a305-4eae-965a-aadbc1eaaae8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2f2ee84a-da41-488a-9f3f-a3f3b4759108",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_sort',
	'',
	'//
// Sort a list of TE_Cs.
te_cs = param.te_cs;
// Declare an empty instance reference.
select any head_te_c related by te_cs->TE_C[R2017.''precedes''] where ( false );
for each te_c in te_cs
  r = ::TE_C_insert( head_te_c:head_te_c, te_c:te_c );
  head_te_c = r;
end for;
return head_te_c;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("30b8e5a4-c131-42a3-b3a1-e74bf908a763",
	"2f2ee84a-da41-488a-9f3f-a3f3b4759108",
	'te_cs',
	"524464d1-f305-4a50-8ac5-89e6a4df72f0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("2f2ee84a-da41-488a-9f3f-a3f3b4759108",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a0d433ac-f24a-4ed2-9eb2-beae340e0f42",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_insert',
	'',
	'head_te_c = param.head_te_c;
te_c = param.te_c;
result = te_c;
if ( empty head_te_c )
  // Just starting.  Return te_c as head.
elif ( te_c.Name <= head_te_c.Name )
  // insert before
  relate te_c to head_te_c across R2017.''precedes'';
else
  // find bigger
  result = head_te_c;
  prev_te_c = head_te_c;
  select one cursor_te_c related by head_te_c->TE_C[R2017.''precedes''];
  while ( not_empty cursor_te_c )
    if ( te_c.Name <= cursor_te_c.Name )
      break;
    else
      prev_te_c = cursor_te_c;
      select one cursor_te_c related by cursor_te_c->TE_C[R2017.''precedes''];
    end if;
  end while;
  relate prev_te_c to te_c across R2017.''precedes'';
  if ( not_empty cursor_te_c )
    relate te_c to cursor_te_c across R2017.''precedes'';
  end if;
end if;
return result;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("d7cc79c8-235e-4c66-aba1-665f1ee98389",
	"a0d433ac-f24a-4ed2-9eb2-beae340e0f42",
	'head_te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("89986ded-ec57-4470-b809-d3f5e4b96af3",
	"a0d433ac-f24a-4ed2-9eb2-beae340e0f42",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"d7cc79c8-235e-4c66-aba1-665f1ee98389",
	'');
INSERT INTO PE_PE
	VALUES ("a0d433ac-f24a-4ed2-9eb2-beae340e0f42",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("68678d29-68f6-467e-8c06-fbeb8cea0c3e",
	"00000000-0000-0000-0000-000000000000",
	'class_sort',
	'',
	'//
// Sort a list of TE_CLASSes.
te_classs = param.te_classs;
// Declare an empty instance reference.
select any head_te_class related by te_classs->TE_CLASS[R2092.''precedes''] where ( false );
for each te_class in te_classs
  end for;
for each te_class in te_classs
  r = ::class_insert( head_te_class:head_te_class, te_class:te_class );
  head_te_class = r;
end for;
return head_te_class;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("d3eb12d0-9b2f-42e3-85bc-18a944a2a2ee",
	"68678d29-68f6-467e-8c06-fbeb8cea0c3e",
	'te_classs',
	"54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("68678d29-68f6-467e-8c06-fbeb8cea0c3e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dae8597a-b72f-4762-abc8-55b0732e65c6",
	"00000000-0000-0000-0000-000000000000",
	'class_insert',
	'',
	'head_te_class = param.head_te_class;
te_class = param.te_class;
result = te_class;
if ( empty head_te_class )
  // Just starting.  Return te_class as head.
else
  lkey = T::s(i:te_class.Numb) + te_class.GeneratedName;
  rkey = T::s(i:head_te_class.Numb) + head_te_class.GeneratedName;
  if ( lkey <= rkey )
    // insert before
    relate te_class to head_te_class across R2092.''precedes'';
  else
    // find bigger
    result = head_te_class;
    prev_te_class = head_te_class;
    select one cursor_te_class related by head_te_class->TE_CLASS[R2092.''precedes''];
    while ( not_empty cursor_te_class )
      rkey = T::s(i:cursor_te_class.Numb) + cursor_te_class.GeneratedName;
      if ( lkey <= rkey )
        break;
      else
        prev_te_class = cursor_te_class;
        select one cursor_te_class related by cursor_te_class->TE_CLASS[R2092.''precedes''];
      end if;
    end while;
    relate prev_te_class to te_class across R2092.''precedes'';
    if ( not_empty cursor_te_class )
      relate te_class to cursor_te_class across R2092.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("ac0a1654-c62d-4750-9f1d-bf775f2836e8",
	"dae8597a-b72f-4762-abc8-55b0732e65c6",
	'head_te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("15402075-3444-4d11-b123-599a88260d99",
	"dae8597a-b72f-4762-abc8-55b0732e65c6",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"ac0a1654-c62d-4750-9f1d-bf775f2836e8",
	'');
INSERT INTO PE_PE
	VALUES ("dae8597a-b72f-4762-abc8-55b0732e65c6",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ee7f9e43-b35d-4aee-be28-703e2c67df2b",
	"00000000-0000-0000-0000-000000000000",
	'mact_sort',
	'',
	'//
// Sort a list of TE_MACTs.
te_macts = param.te_macts;
// Declare an empty instance reference.
select any head_te_mact related by te_macts->TE_MACT[R2083.''precedes''] where ( false );
for each te_mact in te_macts
  end for;
for each te_mact in te_macts
  r = ::mact_insert( head_te_mact:head_te_mact, te_mact:te_mact );
  head_te_mact = r;
end for;
counter = 0;
te_mact = head_te_mact;
while ( not_empty te_mact )
  te_mact.Order = counter;
  counter = counter + 1;
  select one te_mact related by te_mact->TE_MACT[R2083.''precedes''];
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("4be9f06c-e774-443a-8265-c7cc02dbcdbd",
	"ee7f9e43-b35d-4aee-be28-703e2c67df2b",
	'te_macts',
	"f368fddc-d16b-426c-81ab-525461c2ac04",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f368fddc-d16b-426c-81ab-525461c2ac04",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Message Action>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("ee7f9e43-b35d-4aee-be28-703e2c67df2b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f68e460b-0b41-4566-bfa0-18a842933cfd",
	"00000000-0000-0000-0000-000000000000",
	'mact_insert',
	'',
	'head_te_mact = param.head_te_mact;
te_mact = param.te_mact;
result = te_mact;
if ( empty head_te_mact )
  // Just starting.  Return te_mact as head.
else
  lkey = te_mact.Name;
  rkey = head_te_mact.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_mact to head_te_mact across R2083.''precedes'';
  else
    // find bigger
    result = head_te_mact;
    prev_te_mact = head_te_mact;
    select one cursor_te_mact related by head_te_mact->TE_MACT[R2083.''precedes''];
    while ( not_empty cursor_te_mact )
      rkey = cursor_te_mact.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_mact = cursor_te_mact;
        select one cursor_te_mact related by cursor_te_mact->TE_MACT[R2083.''precedes''];
      end if;
    end while;
    relate prev_te_mact to te_mact across R2083.''precedes'';
    if ( not_empty cursor_te_mact )
      relate te_mact to cursor_te_mact across R2083.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"7268e543-f48e-4464-ba70-227deff22727",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("d80b272d-ea3d-46a9-8b28-4793e3ef8a78",
	"f68e460b-0b41-4566-bfa0-18a842933cfd",
	'head_te_mact',
	"7268e543-f48e-4464-ba70-227deff22727",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("7e2f38d1-2d3a-46cf-98b8-4cf020f9ac40",
	"f68e460b-0b41-4566-bfa0-18a842933cfd",
	'te_mact',
	"7268e543-f48e-4464-ba70-227deff22727",
	0,
	'',
	"d80b272d-ea3d-46a9-8b28-4793e3ef8a78",
	'');
INSERT INTO PE_PE
	VALUES ("f68e460b-0b41-4566-bfa0-18a842933cfd",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c1990b54-7ef3-4e70-8589-9d5a90f2b0bc",
	"00000000-0000-0000-0000-000000000000",
	'sync_sort',
	'',
	'//
// Sort a list of TE_SYNCs.
te_syncs = param.te_syncs;
// Declare an empty instance reference.
select any head_te_sync related by te_syncs->TE_SYNC[R2095.''precedes''] where ( false );
for each te_sync in te_syncs
  end for;
for each te_sync in te_syncs
  r = ::sync_insert( head_te_sync:head_te_sync, te_sync:te_sync );
  head_te_sync = r;
end for;
return head_te_sync;
',
	"1b75398c-144d-4d61-a1ad-9f5345c0a0a6",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("ba940db4-35c5-4c13-ac4b-faf4b3588853",
	"c1990b54-7ef3-4e70-8589-9d5a90f2b0bc",
	'te_syncs',
	"2d73ae4a-4203-46cf-b2e8-aa8620c0bb2c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2d73ae4a-4203-46cf-b2e8-aa8620c0bb2c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Function>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("c1990b54-7ef3-4e70-8589-9d5a90f2b0bc",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("1b75398c-144d-4d61-a1ad-9f5345c0a0a6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Function>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("bf25846a-59cd-401f-b695-67d9abcd6bd3",
	"00000000-0000-0000-0000-000000000000",
	'sync_insert',
	'',
	'head_te_sync = param.head_te_sync;
te_sync = param.te_sync;
result = te_sync;
if ( empty head_te_sync )
  // Just starting.  Return te_sync as head.
else
  lkey = te_sync.Name;
  rkey = head_te_sync.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_sync to head_te_sync across R2095.''precedes'';
  else
    // find bigger
    result = head_te_sync;
    prev_te_sync = head_te_sync;
    select one cursor_te_sync related by head_te_sync->TE_SYNC[R2095.''precedes''];
    while ( not_empty cursor_te_sync )
      rkey = cursor_te_sync.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_sync = cursor_te_sync;
        select one cursor_te_sync related by cursor_te_sync->TE_SYNC[R2095.''precedes''];
      end if;
    end while;
    relate prev_te_sync to te_sync across R2095.''precedes'';
    if ( not_empty cursor_te_sync )
      relate te_sync to cursor_te_sync across R2095.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"1b75398c-144d-4d61-a1ad-9f5345c0a0a6",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("2d65fd8e-c349-4ebe-9fce-c99371224159",
	"bf25846a-59cd-401f-b695-67d9abcd6bd3",
	'head_te_sync',
	"1b75398c-144d-4d61-a1ad-9f5345c0a0a6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("9df1e330-31f0-442d-a711-36093148a742",
	"bf25846a-59cd-401f-b695-67d9abcd6bd3",
	'te_sync',
	"1b75398c-144d-4d61-a1ad-9f5345c0a0a6",
	0,
	'',
	"2d65fd8e-c349-4ebe-9fce-c99371224159",
	'');
INSERT INTO PE_PE
	VALUES ("bf25846a-59cd-401f-b695-67d9abcd6bd3",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cbf9e707-6fb3-4b26-89aa-03e5ccd91f0e",
	"00000000-0000-0000-0000-000000000000",
	'ee_sort',
	'',
	'//
// Sort a list of TE_EEs.
te_ees = param.te_ees;
// Declare an empty instance reference.
select any head_te_ee related by te_ees->TE_EE[R2096.''precedes''] where ( false );
for each te_ee in te_ees
  select one next_te_ee related by te_ee->TE_EE[R2096.''precedes''];
  if ( not_empty next_te_ee )
    unrelate te_ee from te_ee across R2096.''precedes'';
  end if;
end for;
for each te_ee in te_ees
  r = ::ee_insert( head_te_ee:head_te_ee, te_ee:te_ee );
  head_te_ee = r;
end for;
return head_te_ee;
',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("cb815448-26cf-458e-874e-0eaedb7a52e5",
	"cbf9e707-6fb3-4b26-89aa-03e5ccd91f0e",
	'te_ees',
	"112f5963-baa2-40c7-9bdf-719e88db1b0a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("112f5963-baa2-40c7-9bdf-719e88db1b0a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended External Entity>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("cbf9e707-6fb3-4b26-89aa-03e5ccd91f0e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8cce9671-b9a7-480f-b2a3-af8c78ea2be7",
	"00000000-0000-0000-0000-000000000000",
	'ee_insert',
	'',
	'head_te_ee = param.head_te_ee;
te_ee = param.te_ee;
result = te_ee;
if ( empty head_te_ee )
  // Just starting.  Return te_ee as head.
else
  lkey = te_ee.Name;
  rkey = head_te_ee.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_ee to head_te_ee across R2096.''precedes'';
  else
    // find bigger
    result = head_te_ee;
    prev_te_ee = head_te_ee;
    select one cursor_te_ee related by head_te_ee->TE_EE[R2096.''precedes''];
    while ( not_empty cursor_te_ee )
      rkey = cursor_te_ee.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_ee = cursor_te_ee;
        select one cursor_te_ee related by cursor_te_ee->TE_EE[R2096.''precedes''];
      end if;
    end while;
    relate prev_te_ee to te_ee across R2096.''precedes'';
    if ( not_empty cursor_te_ee )
      relate te_ee to cursor_te_ee across R2096.''precedes'';
    end if;
  end if;
end if;
return result;
',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("5756fd2c-ab24-4ac9-ad49-a306de7d8e4b",
	"8cce9671-b9a7-480f-b2a3-af8c78ea2be7",
	'head_te_ee',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("18b8872e-a6ba-4c70-98f5-bee6b1ce24f6",
	"8cce9671-b9a7-480f-b2a3-af8c78ea2be7",
	'te_ee',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	0,
	'',
	"5756fd2c-ab24-4ac9-ad49-a306de7d8e4b",
	'');
INSERT INTO PE_PE
	VALUES ("8cce9671-b9a7-480f-b2a3-af8c78ea2be7",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("872dcdd2-9ae6-4bf1-8084-4fbbeeafeec9",
	"00000000-0000-0000-0000-000000000000",
	'blk_indentwhitespace',
	'',
	'//
// indentation maker
//
indentation = param.indentation;
result = "";
while ( 0 < indentation )
  indentation = indentation - 1;
  result = result + "  ";
end while;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("57c0ec23-aab5-4537-84a0-6efe66d24e7f",
	"872dcdd2-9ae6-4bf1-8084-4fbbeeafeec9",
	'indentation',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("872dcdd2-9ae6-4bf1-8084-4fbbeeafeec9",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c90724f6-3274-4c9e-bfab-397152947651",
	"00000000-0000-0000-0000-000000000000",
	'gen_parameter_list',
	'',
	'//====================================================================
//
// $RCSfile: q.utils.arc,v $
//
//
//====================================================================
//
v_pars = param.v_pars;
prefix_param_delimiter = param.prefix_param_delimiter;
//
code = "";
OAL = "";
select any te_parm from instances of TE_PARM;
if ( not_empty v_pars )
  select any te_string from instances of TE_STRING;
  item_count = 0;
  lowest_order = 999;
  select many te_pars related by v_pars->TE_PAR[R2063];
  for each te_par in te_pars
    select one te_parm related by te_par->TE_PARM[R2091];
    te_par.Order = te_parm.Order;
    if ( te_par.Order < lowest_order )
      lowest_order = te_par.Order;
    end if;
    item_count = item_count + 1;
  end for;
  item_number = lowest_order;
  param_delimiter = "";
  if ( prefix_param_delimiter )
    param_delimiter = ",";
  end if;
  while ( item_number < ( item_count + lowest_order ) )
    select any te_par related by v_pars->TE_PAR[R2063] where ( selected.Order == item_number );
    select one v_par related by te_par->V_PAR[R2063];
    select one v_val related by v_par->V_VAL[R800];
    select one te_val related by v_val->TE_VAL[R2040];
    OAL = ( OAL + param_delimiter ) + te_val.OAL;
    if ( "" == te_val.buffer )
      ::gen_value( v_val:v_val );
    end if;
    code = code + param_delimiter;
    //
    if ( 0 == te_par.By_Ref )
      code = code + te_val.buffer;
    else
      code = ( ( code + "&(" ) + ( te_val.buffer + ")" ) );
    end if;
    param_delimiter = ", ";
    item_number = item_number + 1;
  end while;
end if;
te_parm.ParamBuffer = code;
te_parm.OALParamBuffer = OAL;
return te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("223e7d56-e8e0-482c-94b6-f6ead73eb614",
	"c90724f6-3274-4c9e-bfab-397152947651",
	'v_pars',
	"ae5b840e-5312-4865-ae17-5c9bba997543",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ae5b840e-5312-4865-ae17-5c9bba997543",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("03442271-3c0c-40b8-83b3-b5ddf7b9f4cd",
	"c90724f6-3274-4c9e-bfab-397152947651",
	'prefix_param_delimiter',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"223e7d56-e8e0-482c-94b6-f6ead73eb614",
	'');
INSERT INTO PE_PE
	VALUES ("c90724f6-3274-4c9e-bfab-397152947651",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("54e1148c-f9db-4162-ab11-2be51adffb79",
	"00000000-0000-0000-0000-000000000000",
	'is_reflexive',
	'',
	'//
//====================================================================
//
r_rel = param.r_rel;
//
result = false;
select one r_simp related by r_rel->R_SIMP[R206];
if ( not_empty r_simp )
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any first_r_part related by r_simp->R_PART[R207];
    select any second_r_part related by r_simp->R_PART[R207] where ( selected.OIR_ID != first_r_part.OIR_ID );
    if ( first_r_part.Obj_ID == second_r_part.Obj_ID )
      result = true;
    end if;
  else
    select any r_part related by r_simp->R_PART[R207];
    select one r_form related by r_simp->R_FORM[R208];
    if ( not_empty r_form )
      if ( r_part.Obj_ID == r_form.Obj_ID )
        result = true;
      end if;
    end if;
  end if;
else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];
    if ( r_aone.Obj_ID == r_aoth.Obj_ID )
      result = true;
    end if;
  end if;
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("35f7a09e-63c8-43fc-acb3-a3a05d0b26ab",
	"54e1148c-f9db-4162-ab11-2be51adffb79",
	'r_rel',
	"620e9be8-e289-47ed-9279-69b359c269c5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("620e9be8-e289-47ed-9279-69b359c269c5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../Association/Association.xtuml');
INSERT INTO PE_PE
	VALUES ("54e1148c-f9db-4162-ab11-2be51adffb79",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	"00000000-0000-0000-0000-000000000000",
	't_oal_smt_event_parameters',
	'',
	'//------------------------------------------------
// Note the use of p_ here.  It is hard-coded and depends upon
// matching the prefix used in initialization population query.
evt_msg_var = param.evt_msg_var;
parameter = param.parameter;
value = param.value;
value_type = param.value_type;
ws = param.ws;
result = "";
select any te_eq from instances of TE_EQ;
if ( "" == evt_msg_var )
  evt_msg_var = te_eq.event_message_variable;
end if;
if ( 4 == value_type )
  // string
  select any te_string from instances of TE_STRING;
  select any te_instance from instances of TE_INSTANCE;
  result = "${ws}  ${te_instance.module}${te_string.strcpy}( ${evt_msg_var}->p_${parameter}, ${value} );";
else
  result = "${ws}  ${evt_msg_var}->p_${parameter} = ${value};";
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("b11ef695-8506-46df-b824-f6e8b3590d3c",
	"fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	'evt_msg_var',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c163f065-7430-4ca0-bd8c-9e25ff2af29c",
	"fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	'parameter',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"b11ef695-8506-46df-b824-f6e8b3590d3c",
	'');
INSERT INTO S_SPARM
	VALUES ("7144192e-5c3c-4c39-b244-fe99f10a5566",
	"fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c163f065-7430-4ca0-bd8c-9e25ff2af29c",
	'');
INSERT INTO S_SPARM
	VALUES ("de91731d-9966-4534-8fdc-b78243a9635d",
	"fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	'value_type',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"7144192e-5c3c-4c39-b244-fe99f10a5566",
	'');
INSERT INTO S_SPARM
	VALUES ("d50d62e2-2263-408b-98f5-a4fda29b6513",
	"fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	'ws',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"de91731d-9966-4534-8fdc-b78243a9635d",
	'');
INSERT INTO PE_PE
	VALUES ("fcc7f1e3-a17b-4e21-afd2-50993da33e56",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b653b0b2-d3b2-4534-bb4a-52132890f9df",
	"00000000-0000-0000-0000-000000000000",
	'container_factory',
	'',
	'//
te_container = param.te_container;
te_container.flavor = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("6969dcaa-4cdb-496e-b25a-9274b18f908e",
	"b653b0b2-d3b2-4534-bb4a-52132890f9df",
	'te_container',
	"bed7aed0-a8ba-4e93-acaa-c7c0ef17e639",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bed7aed0-a8ba-4e93-acaa-c7c0ef17e639",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<container>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b653b0b2-d3b2-4534-bb4a-52132890f9df",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("203dfe8c-ad44-47ee-a0e2-b02a4a1e281f",
	"00000000-0000-0000-0000-000000000000",
	'copyright_factory',
	'',
	'//
//
te_copyright = param.te_copyright;
te_copyright.body = "your copyright statement can go here (from te_copyright.body)";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("f4dc3651-9e21-49ca-bafb-628832174c5b",
	"203dfe8c-ad44-47ee-a0e2-b02a4a1e281f",
	'te_copyright',
	"66047ebf-b4d3-4c3f-ac61-a72efcb39e53",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("66047ebf-b4d3-4c3f-ac61-a72efcb39e53",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<copyright>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("203dfe8c-ad44-47ee-a0e2-b02a4a1e281f",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("71b6006a-bd90-4cf0-86e4-7c1b6aaf7fc2",
	"00000000-0000-0000-0000-000000000000",
	'dlist_factory',
	'',
	'//
//
te_dlist = param.te_dlist;
select any te_prefix from instances of TE_PREFIX;
te_dlist.remove_node = te_prefix.result + "SetRemoveDlistNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("bc5ddc7a-631e-4ec7-aaf5-9dfff2916c01",
	"71b6006a-bd90-4cf0-86e4-7c1b6aaf7fc2",
	'te_dlist',
	"ae4a14e9-ebe7-41e2-97d0-0b6e1b15ceea",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ae4a14e9-ebe7-41e2-97d0-0b6e1b15ceea",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dlist>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("71b6006a-bd90-4cf0-86e4-7c1b6aaf7fc2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("60f356d2-1999-47b2-9c10-7b1fa898ddd2",
	"00000000-0000-0000-0000-000000000000",
	'dma_factory',
	'',
	'//
//
te_dma = param.te_dma;
select any te_prefix from instances of TE_PREFIX;
te_dma.file = "sys_memory";
te_dma.allocate = te_prefix.result + "malloc";
te_dma.release = te_prefix.result + "free";
te_dma.debugging_heap = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("f8acce13-836b-4c6d-9bf5-e90e425ca9df",
	"60f356d2-1999-47b2-9c10-7b1fa898ddd2",
	'te_dma',
	"95c40567-3d38-4e09-ab51-e0a2883d1bae",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("95c40567-3d38-4e09-ab51-e0a2883d1bae",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dynamic memory allocation>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("60f356d2-1999-47b2-9c10-7b1fa898ddd2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("44f1f318-d4d6-48af-8e4a-c8bc52805eeb",
	"00000000-0000-0000-0000-000000000000",
	'eq_factory',
	'',
	'//
//
te_eq = param.te_eq;
select any te_prefix from instances of TE_PREFIX;
te_eq.ignored = "EVENT_IS_IGNORED";
te_eq.cant_happen = "EVENT_CANT_HAPPEN";
te_eq.system_events_union = te_prefix.result + "systemxtUMLevents";
te_eq.system_event_pool = te_prefix.result + "xtUML_event_pool";
te_eq.constant_type = te_prefix.result + "xtUMLEventConstant_t";
te_eq.base_event_type = te_prefix.result + "xtUMLEvent_t";
te_eq.base_variable = "mc_event_base";
te_eq.max_events = te_prefix.define_u + "SYS_MAX_XTUML_EVENTS";
te_eq.max_self_events = te_prefix.define_u + "SYS_MAX_SELF_EVENTS";
te_eq.max_nonself_events = te_prefix.define_u + "SYS_MAX_NONSELF_EVENTS";
te_eq.new = te_prefix.result + "NewxtUMLEvent";
te_eq.allocate = te_prefix.result + "AllocatextUMLEvent";
te_eq.delete = te_prefix.result + "DeletextUMLEvent";
te_eq.modify = te_prefix.result + "ModifyxtUMLEvent";
te_eq.self = te_prefix.result + "SendSelfEvent";
te_eq.non_self = te_prefix.result + "SendEvent";
te_eq.search_and_destroy = te_prefix.result + "EventSearchAndDestroy";
te_eq.run_flag = te_prefix.result + "run_flag";
te_eq.event_message_variable = "e";
te_eq.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("a602c521-0ebb-4870-ae07-088bda8ba2ea",
	"44f1f318-d4d6-48af-8e4a-c8bc52805eeb",
	'te_eq',
	"d6d92349-6671-4f67-b702-a8dcef6f4bab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6d92349-6671-4f67-b702-a8dcef6f4bab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<event queue>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("44f1f318-d4d6-48af-8e4a-c8bc52805eeb",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5d6b7855-afc0-4909-a694-6f0061732ee7",
	"00000000-0000-0000-0000-000000000000",
	'extent_factory',
	'',
	'//
//
te_extent = param.te_extent;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_typemap from instances of TE_TYPEMAP;
select any te_instance from instances of TE_INSTANCE;
te_extent.sets_type = te_set.base_class;
te_extent.type = te_prefix.result + "Extent_t";
te_extent.active = "active";
te_extent.inactive = "inactive";
te_extent.size_type = te_typemap.object_size_name;
te_extent.istate_type = te_typemap.state_number_name;
te_extent.istate_name = "initial_state";
te_extent.container_type = te_set.element_type + "*";
te_extent.container_name = "container";
te_extent.pool_type = te_instance.handle;
te_extent.pool_name = "pool";
te_extent.population_type = te_typemap.instance_index_name;
te_extent.population_name = "population";
te_extent.rstorsize_type = te_typemap.object_size_name;
te_extent.rstorsize_name = "size_no_rel";
te_extent.linkfunc_name = "link_function";
te_extent.size_name = "size";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("af1fda7f-d92f-4687-ac59-1a8241cf36f4",
	"5d6b7855-afc0-4909-a694-6f0061732ee7",
	'te_extent',
	"1f3bdad1-ec0f-48e9-8084-9a44d3c52a99",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1f3bdad1-ec0f-48e9-8084-9a44d3c52a99",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<extent>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("5d6b7855-afc0-4909-a694-6f0061732ee7",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("db64a529-6614-4adb-a9e4-42b10d7ac97d",
	"00000000-0000-0000-0000-000000000000",
	'file_factory',
	'',
	'//
//
te_file = param.te_file;
select any te_prefix from instances of TE_PREFIX;
te_file.hdr_file_ext = "h";
te_file.src_file_ext = "c";
te_file.sys_main = te_prefix.file + "sys_main";
te_file.factory = te_prefix.file + "sys_xtuml";
te_file.events = te_prefix.file + "sys_events";
te_file.obj_file_ext = "o";
te_file.nvs = te_prefix.file + "sys_nvs";
te_file.sets = te_prefix.file + "sys_sets";
te_file.types = te_prefix.file + "sys_types";
te_file.thread = te_prefix.file + "sys_thread";
te_file.trace = te_prefix.file + "sys_trace";
te_file.tim = te_prefix.file + "TIM_bridge";
te_file.callout = te_prefix.file + "sys_user_co";
te_file.ilb = te_prefix.file + "sys_ilb";
te_file.persist = te_prefix.file + "sys_persist";
te_file.xtumlload = te_prefix.file + "sys_xtumlload";
te_file.interfaces = te_prefix.file + "sysc_interfaces";
te_file.registers = te_prefix.file + "RegDefs";
te_file.domain_color_path = ".";
te_file.domain_source_path = "_ch";
te_file.domain_include_path = "_ch";
te_file.system_source_path = "_ch";
te_file.system_include_path = "_ch";
te_file.system_color_path = ".";
te_file.system_mark = "system.mark";
te_file.datatype_mark = "datatype.mark";
te_file.event_mark = "event.mark";
te_file.class_mark = "class.mark";
te_file.domain_mark = "domain.mark";
te_file.system_functions_mark = "sys_functions.arc";
te_file.bridge_mark = "bridge.mark";
te_file.nvs_bridge = te_prefix.file + "NVS_bridge";
te_file.arc_path = "mc3020/arc";
te_file.root_path = ".";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("7946fa6a-a9f6-438b-9cd8-2e07324b823a",
	"db64a529-6614-4adb-a9e4-42b10d7ac97d",
	'te_file',
	"0036820d-a4f4-4951-aaba-f90c9abe57f1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0036820d-a4f4-4951-aaba-f90c9abe57f1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<file>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("db64a529-6614-4adb-a9e4-42b10d7ac97d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("03fabcac-3642-47c0-a276-61eb84693a72",
	"00000000-0000-0000-0000-000000000000",
	'instance_factory',
	'',
	'//
//
te_instance = param.te_instance;
select any te_prefix from instances of TE_PREFIX;
te_instance.scope = "";
te_instance.create = te_prefix.result + "CreateInstance";
te_instance.create_persistent = te_prefix.result + "CreatePersistent";
te_instance.delete = te_prefix.result + "DeleteInstance";
te_instance.delete_persistent = te_prefix.result + "DeletePersistent";
te_instance.self = "self";
te_instance.global_self = te_prefix.result + "GetSelf";
te_instance.base = te_prefix.result + "InstanceBase_t";
te_instance.handle = te_prefix.result + "iHandle_t";
te_instance.factory_init = te_prefix.result + "ClassFactoryInit";
te_instance.get_dci = te_prefix.result + "GetDCI";
te_instance.get_event_dispatcher = te_prefix.result + "GetEventDispatcher";
te_instance.get_thread_assignment = te_prefix.result + "GetThreadAssignment";
te_instance.base_class = te_prefix.result + "Object_s";
te_instance.max_extent = te_prefix.define_u + "SYS_MAX_OBJECT_EXTENT";
te_instance.max_association_extent = te_prefix.define_u + "SYS_MAX_ASSOCIATION_EXTENT";
te_instance.max_transient_extent = te_prefix.define_u + "SYS_MAX_TRANSIENT_EXTENT";
te_instance.current_state = "current_state";
te_instance.module = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("ffd09f09-c33e-407b-a0a6-00a3e3a89dae",
	"03fabcac-3642-47c0-a276-61eb84693a72",
	'te_instance',
	"f0202e24-f724-4165-9b1f-c61a34457bc8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f0202e24-f724-4165-9b1f-c61a34457bc8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<instance>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("03fabcac-3642-47c0-a276-61eb84693a72",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7b61684e-c390-40ab-96f6-52dbde248dc0",
	"00000000-0000-0000-0000-000000000000",
	'ilb_factory',
	'',
	'//
//
te_ilb = param.te_ilb;
select any te_prefix from instances of TE_PREFIX;
te_ilb.file = "sys_ilb";
te_ilb.interleave_bridge = "InterleaveBridge";
te_ilb.define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGES";
te_ilb.data_define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGE_DATA";
te_ilb.interleave_bridge_done = "InterleaveBridgeDone";
te_ilb.get_data = "GetILBData";
te_ilb.dispatch = "DispatchInterleaveBridge";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("49a19a60-2dc8-484b-a7db-f7e61b118049",
	"7b61684e-c390-40ab-96f6-52dbde248dc0",
	'te_ilb',
	"9607434a-e180-4f6f-bfad-1014845a2102",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9607434a-e180-4f6f-bfad-1014845a2102",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<interleaved bridge>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("7b61684e-c390-40ab-96f6-52dbde248dc0",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5f131d09-2500-4826-996a-260cbd11efb4",
	"00000000-0000-0000-0000-000000000000",
	'persist_factory',
	'',
	'//
//
te_persist = param.te_persist;
select any te_prefix from instances of TE_PREFIX;
select any te_typemap from instances of TE_TYPEMAP;
te_persist.class_union = "";
te_persist.instance_cache_depth = te_prefix.define_u + "PERSIST_INST_CACHE_DEPTH";
te_persist.check_mark = "check_mark_post";
te_persist.post_link = "";
te_persist.link_type_name = te_prefix.type + "link_t";
te_persist.persist_file = "sys_persist";
te_persist.factory_init = te_prefix.result + "PersistFactoryInit";
te_persist.commit = te_prefix.result + "PersistenceCommit";
te_persist.restore = te_prefix.result + "PersistenceRestore";
te_persist.remove = te_prefix.result + "PersistDelete";
te_persist.link_cache_depth = te_prefix.define_u + "PERSIST_LINK_CACHE_DEPTH";
// Return the name of the extended attribute variable for use by
// the persistent restore operation.  This attribute represents the
// instance index of the class extent at time of persistent stowage
// together with the class number (across domains) of the class.
// Also return the types for this attribute variable.
te_persist.domainnum_name = "domainnum";
te_persist.domainnum_type = te_typemap.domain_number_name;
te_persist.classnum_name = "classnum";
te_persist.classnum_type = te_typemap.object_number_name;
te_persist.index_name = "index";
te_persist.index_type = te_typemap.instance_index_name;
te_persist.instid_type = "InstanceIdentifier_t";
te_persist.instid_name = "instance_identifier";
te_persist.dirty_type = "s1_t";
te_persist.dirty_name = "persist_dirty";
te_persist.dirty_dirty = 1;
te_persist.dirty_clean = 0;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("0fad4fd0-fa5e-4809-b853-98892f7328cc",
	"5f131d09-2500-4826-996a-260cbd11efb4",
	'te_persist',
	"64c42b53-ed69-45a1-b7de-39fa11bfa5de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("64c42b53-ed69-45a1-b7de-39fa11bfa5de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<persistence>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("5f131d09-2500-4826-996a-260cbd11efb4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0fb445c9-6670-48dc-a913-ee243752f468",
	"00000000-0000-0000-0000-000000000000",
	'prefix_factory',
	'',
	'//
//
te_prefix = param.te_prefix;
te_prefix.symbol = "Escher_";
te_prefix.type = "Escher_";
te_prefix.define_u = "ESCHER_";
te_prefix.define_c = "Escher_";
te_prefix.symbolsw = "";
te_prefix.typesw = "";
te_prefix.result = "Escher_";
te_prefix.define_csw = "";
te_prefix.define_usw = "";
te_prefix.file = "";
te_prefix.provided_port = "pport_";
te_prefix.required_port = "rport_";
te_prefix.channel = "channel_";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("80e3715f-f500-431d-8268-a4ea23290222",
	"0fb445c9-6670-48dc-a913-ee243752f468",
	'te_prefix',
	"3afdbefc-08c0-46d7-8e35-39767bc796a8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3afdbefc-08c0-46d7-8e35-39767bc796a8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<prefix>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("0fb445c9-6670-48dc-a913-ee243752f468",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f4dc6f5d-b514-4460-8a6f-996db414842a",
	"00000000-0000-0000-0000-000000000000",
	'relinfo_factory',
	'',
	'//
//
te_relinfo = param.te_relinfo;
te_relinfo.multiplicity = 0;
te_relinfo.rel_phrase = "";
te_relinfo.is_formalizer = false;
te_relinfo.is_supertype = false;
te_relinfo.generate_subtype = false;
te_relinfo.gen_declaration = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("00270d0a-14d8-4e61-8bec-56541cfbdda5",
	"f4dc6f5d-b514-4460-8a6f-996db414842a",
	'te_relinfo',
	"4ac9e914-7a2d-42a4-afbb-979afa290813",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4ac9e914-7a2d-42a4-afbb-979afa290813",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship information>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("f4dc6f5d-b514-4460-8a6f-996db414842a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8e4cdf62-c4ec-41e1-85aa-05ca02142984",
	"00000000-0000-0000-0000-000000000000",
	'relstore_factory',
	'',
	'//
//
te_relstore = param.te_relstore;
te_relstore.data_init = "";
te_relstore.link_calls = "";
te_relstore.link_index = 0;
te_relstore.data_fini = "";
te_relstore.self_name = "self";
te_relstore.data_declare = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("d5a5bf36-8fa5-41d0-80ff-65c40f5241d9",
	"8e4cdf62-c4ec-41e1-85aa-05ca02142984",
	'te_relstore',
	"e0eff310-4301-4d0e-892a-5e44db181c35",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e0eff310-4301-4d0e-892a-5e44db181c35",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship storage>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("8e4cdf62-c4ec-41e1-85aa-05ca02142984",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cf8a646d-3328-40a9-b10d-69414d7c52ac",
	"00000000-0000-0000-0000-000000000000",
	'set_factory',
	'',
	'//
//
te_set = param.te_set;
select any te_prefix from instances of TE_PREFIX;
te_set.module = "";
te_set.copy = te_prefix.result + "CopySet";
te_set.clear = te_prefix.result + "ClearSet";
te_set.insert_element = te_prefix.result + "SetInsertElement";
te_set.element_count = te_prefix.result + "SetCardinality";
te_set.iterator_class_name = te_prefix.result + "Iterator_s";
te_set.number_of_containoids = te_prefix.define_usw + "SYS_MAX_CONTAINERS";
te_set.factory = te_prefix.result + "SetFactoryInit";
te_set.insert_block = te_prefix.result + "SetInsertBlock";
te_set.remove_instance = te_prefix.result + "SetRemoveInstance";
te_set.contains = te_prefix.result + "SetContains";
te_set.equality = te_prefix.result + "SetEquality";
te_set.init = te_prefix.result + "InitSet";
te_set.insert_instance = te_prefix.result + "SetInsertInstance";
te_set.emptiness = te_prefix.result + "SetIsEmpty";
te_set.get_any = te_prefix.result + "SetGetAny";
te_set.remove_element = te_prefix.result + "SetRemoveElement";
te_set.iterator_reset = te_prefix.result + "IteratorReset";
te_set.iterator_next = te_prefix.result + "IteratorNext";
te_set.base_class = te_prefix.result + "ObjectSet_s";
te_set.element_type = te_prefix.result + "SetElement_s";
te_set.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("c6836b71-1e9e-40c7-9883-913ef6fbc0a5",
	"cf8a646d-3328-40a9-b10d-69414d7c52ac",
	'te_set',
	"acfc1b52-78f3-4f68-9025-f05d65609d43",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("acfc1b52-78f3-4f68-9025-f05d65609d43",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<set>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("cf8a646d-3328-40a9-b10d-69414d7c52ac",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aa0027cd-d3ce-4caa-bb7b-cde19924ea81",
	"00000000-0000-0000-0000-000000000000",
	'slist_factory',
	'',
	'//
//
te_slist = param.te_slist;
select any te_prefix from instances of TE_PREFIX;
te_slist.remove_node = te_prefix.result + "SetRemoveNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("b5452c9c-e32d-4891-886c-a1351c1ebe22",
	"aa0027cd-d3ce-4caa-bb7b-cde19924ea81",
	'te_slist',
	"976fc510-71b7-4ace-b099-c840dff5f3de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("976fc510-71b7-4ace-b099-c840dff5f3de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<slist>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("aa0027cd-d3ce-4caa-bb7b-cde19924ea81",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("04398691-1d15-4a66-9c76-c95c9b5ad04b",
	"00000000-0000-0000-0000-000000000000",
	'string_factory',
	'',
	'//
//
te_string = param.te_string;
select any te_prefix from instances of TE_PREFIX;
te_string.memset = te_prefix.result + "memset";
te_string.memmove = te_prefix.result + "memmove";
te_string.strcpy = te_prefix.result + "strcpy";
te_string.stradd = te_prefix.result + "stradd";
te_string.strlen = te_prefix.result + "strlen";
te_string.itoa = te_prefix.result + "itoa";
te_string.atoi = te_prefix.result + "atoi";
te_string.strcmp = te_prefix.result + "strcmp";
te_string.strget = te_prefix.result + "strget";
te_string.max_string_length = te_prefix.define_u + "SYS_MAX_STRING_LEN";
te_string.debug_buffer_depth = te_prefix.define_u + "DEBUG_BUFFER_DEPTH";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("a7045158-ffd5-4070-8205-79e6b703bf0e",
	"04398691-1d15-4a66-9c76-c95c9b5ad04b",
	'te_string',
	"950366c4-a10b-4518-8cdb-3dc0f89902cc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("950366c4-a10b-4518-8cdb-3dc0f89902cc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<string>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("04398691-1d15-4a66-9c76-c95c9b5ad04b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9323522b-d171-420f-98e7-a3e9aa1e231e",
	"00000000-0000-0000-0000-000000000000",
	'thread_factory',
	'',
	'//
//
te_thread = param.te_thread;
select any te_prefix from instances of TE_PREFIX;
te_thread.file = "sys_thread";
te_thread.mutex_lock = te_prefix.result + "mutex_lock";
te_thread.mutex_unlock = te_prefix.result + "mutex_unlock";
te_thread.nonbusy_wait = te_prefix.result + "nonbusy_wait";
te_thread.nonbusy_wake = te_prefix.result + "nonbusy_wake";
te_thread.shutdown = te_prefix.result + "thread_shutdown";
te_thread.create = te_prefix.result + "thread_create";
te_thread.enabled = false;
te_thread.flavor = "POSIX";
te_thread.serialize = false;
te_thread.number_of_threads = 1;
te_thread.extra_initialization = "";
te_thread.AUTOSAR_enabled = te_prefix.define_usw + "AUTOSAR_ENABLED";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("e25f97f8-80e4-451a-bf2a-dcb2c86a5de1",
	"9323522b-d171-420f-98e7-a3e9aa1e231e",
	'te_thread',
	"11e51b45-1939-4fba-8271-981f25fb85e0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("11e51b45-1939-4fba-8271-981f25fb85e0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<thread>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("9323522b-d171-420f-98e7-a3e9aa1e231e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0b45d5b1-92d7-468b-8ca3-c6060b180323",
	"00000000-0000-0000-0000-000000000000",
	'tim_factory',
	'',
	'//
//
te_tim = param.te_tim;
select any te_prefix from instances of TE_PREFIX;
te_tim.max_timers = te_prefix.define_u + "SYS_MAX_XTUML_TIMERS";
te_tim.keyed_timer_support = false;
te_tim.recurring_timer_support = true;
te_tim.internal_type = "ETimer_t";
te_tim.timer_event_search_and_destroy = false;
te_tim.event_name = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("58c9fc95-5120-4cfe-913a-923d911d0a44",
	"0b45d5b1-92d7-468b-8ca3-c6060b180323",
	'te_tim',
	"64135dee-0504-4c8d-b94c-4103b7459fc0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("64135dee-0504-4c8d-b94c-4103b7459fc0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<timer>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("0b45d5b1-92d7-468b-8ca3-c6060b180323",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fbaf43ef-5eed-4dff-8ac2-bf9b0459fe53",
	"00000000-0000-0000-0000-000000000000",
	'typemap_factory',
	'',
	'//
//
te_typemap = param.te_typemap;
select any te_prefix from instances of TE_PREFIX;
te_typemap.instance_index_name = te_prefix.result + "InstanceIndex_t";
te_typemap.instance_index_type = "u2_t";
te_typemap.object_size_name = te_prefix.type + "ClassSize_t";
te_typemap.object_size_type = te_prefix.type + "size_t";
te_typemap.object_number_name = te_prefix.type + "ClassNumber_t";
te_typemap.object_number_type = "u2_t";
te_typemap.state_number_name = te_prefix.type + "StateNumber_t";
te_typemap.state_number_type = "u1_t";
te_typemap.domain_number_name = te_prefix.type + "DomainNumber_t";
te_typemap.domain_number_type = "u1_t";
te_typemap.event_number_name = te_prefix.type + "EventNumber_t";
te_typemap.event_number_type = "u1_t";
te_typemap.event_priority_name = te_prefix.type + "EventPriority_t";
te_typemap.event_priority_type = "u1_t";
te_typemap.event_flags_name = te_prefix.type + "EventFlags_t";
te_typemap.event_flags_type = "u1_t";
te_typemap.poly_return_name = te_prefix.type + "PolyEventRC_t";
te_typemap.poly_return_type = "u1_t";
te_typemap.SEM_cell_type = "u1_t";
te_typemap.SEM_cell_name = te_prefix.type + "SEMcell_t";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("2b4f0016-ddc4-45dc-9193-724692c65d30",
	"fbaf43ef-5eed-4dff-8ac2-bf9b0459fe53",
	'te_typemap',
	"d98a6bae-7ee6-42d2-a8a1-2f809cba7b82",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d98a6bae-7ee6-42d2-a8a1-2f809cba7b82",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<type map>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("fbaf43ef-5eed-4dff-8ac2-bf9b0459fe53",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3d015713-68f3-40fd-810c-d065e9feeab8",
	"00000000-0000-0000-0000-000000000000",
	'callout_factory',
	'',
	'//
//
te_callout = param.te_callout;
select any te_prefix from instances of TE_PREFIX;
te_callout.initialization = te_prefix.symbolsw + "UserInitializationCallout";
te_callout.pre_xtUML_initialization = te_prefix.symbolsw + "UserPreOoaInitializationCallout";
te_callout.post_xtUML_initialization = te_prefix.symbolsw + "UserPostOoaInitializationCallout";
te_callout.background_processing = te_prefix.symbolsw + "UserBackgroundProcessingCallout";
te_callout.pre_shutdown = te_prefix.symbolsw + "UserPreShutdownCallout";
te_callout.event_no_instance = te_prefix.symbolsw + "UserEventNoInstanceCallout";
te_callout.event_free_list_empty = te_prefix.symbolsw + "UserEventFreeListEmptyCallout";
te_callout.object_pool_empty = te_prefix.symbolsw + "UserObjectPoolEmptyCallout";
te_callout.node_list_empty = te_prefix.symbolsw + "UserNodeListEmptyCallout";
te_callout.interleaved_bridge_overflow = te_prefix.symbolsw + "UserInterleavedBridgeOverflowCallout";
te_callout.self_event_queue_empty = te_prefix.symbolsw + "UserSelfEventQueueEmptyCallout";
te_callout.non_self_event_queue_empty = te_prefix.symbolsw + "UserNonSelfEventQueueEmptyCallout";
te_callout.persistence_error = te_prefix.symbolsw + "UserPersistenceErrorCallout";
te_callout.file = "sys_user_co";
te_callout.post_shutdown = te_prefix.symbolsw + "UserPostShutdownCallout";
te_callout.event_cant_happen = te_prefix.symbolsw + "UserEventCantHappenCallout";
te_callout.empty_handle_detected = te_prefix.symbolsw + "UserEmptyHandleDetectedCallout";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("3e4eefa4-f69a-464c-b1f7-8c05a95484f7",
	"3d015713-68f3-40fd-810c-d065e9feeab8",
	'te_callout',
	"93f43d4c-fd60-4b31-97f4-e74103f19dc9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("93f43d4c-fd60-4b31-97f4-e74103f19dc9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<user callout>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("3d015713-68f3-40fd-810c-d065e9feeab8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("680fce85-b634-4ddf-9a63-c61b0830bf3e",
	"00000000-0000-0000-0000-000000000000",
	'trace_factory',
	'',
	'//
//
te_trace = param.te_trace;
select any te_prefix from instances of TE_PREFIX;
te_trace.component_msg_start = te_prefix.define_usw + "COMP_MSG_START_TRACE";
te_trace.component_msg_end = te_prefix.define_usw + "COMP_MSG_END_TRACE";
te_trace.state_txn_start = te_prefix.define_usw + "STATE_TXN_START_TRACE";
te_trace.oal_trace = te_prefix.define_usw + "OAL_ACTION_TRACE";
te_trace.state_txn_end = te_prefix.define_usw + "STATE_TXN_END_TRACE";
te_trace.state_txn_event_ignored = te_prefix.define_usw + "STATE_TXN_IG_TRACE";
te_trace.state_txn_cant_happen = te_prefix.define_usw + "STATE_TXN_CH_TRACE";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("3861ee18-4020-4b5d-8580-605e3a200375",
	"680fce85-b634-4ddf-9a63-c61b0830bf3e",
	'te_trace',
	"1aa80d4d-ce32-4473-9aa3-f54ad1ca398e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1aa80d4d-ce32-4473-9aa3-f54ad1ca398e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<trace>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("680fce85-b634-4ddf-9a63-c61b0830bf3e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aa88ace3-f59b-4b73-ade5-93c0e8291740",
	"00000000-0000-0000-0000-000000000000",
	'target_factory',
	'',
	'//
te_target = param.te_target;
te_target.language = "C";
te_target.c2cplusplus_linkage_begin = "#ifdef\t__cplusplus\nextern\t&quot;C&quot;\t{\n#endif";
te_target.c2cplusplus_linkage_end = "#ifdef\t__cplusplus\n}\n#endif";
te_target.main = "main";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO S_SPARM
	VALUES ("fc4bb502-435a-467d-83ef-31b75b1cf0fa",
	"aa88ace3-f59b-4b73-ade5-93c0e8291740",
	'te_target',
	"87352925-0272-4445-84b6-d8c3f983377f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("87352925-0272-4445-84b6-d8c3f983377f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<target>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("aa88ace3-f59b-4b73-ade5-93c0e8291740",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("78270698-fa3e-4c4d-89dd-a3ea00488f23",
	"00000000-0000-0000-0000-000000000000",
	'sys_singletons',
	'',
	'//
create object instance te_prefix of TE_PREFIX;
::prefix_factory( te_prefix:te_prefix );
create object instance te_typemap of TE_TYPEMAP;
::typemap_factory( te_typemap:te_typemap );
create object instance te_container of TE_CONTAINER;
::container_factory( te_container:te_container );
create object instance te_copyright of TE_COPYRIGHT;
::copyright_factory( te_copyright:te_copyright );
create object instance te_dlist of TE_DLIST;
::dlist_factory( te_dlist:te_dlist );
create object instance te_dma of TE_DMA;
::dma_factory( te_dma:te_dma );
create object instance te_eq of TE_EQ;
::eq_factory( te_eq:te_eq );
create object instance te_file of TE_FILE;
::file_factory( te_file:te_file );
create object instance te_instance of TE_INSTANCE;
::instance_factory( te_instance:te_instance );
create object instance te_ilb of TE_ILB;
::ilb_factory( te_ilb:te_ilb );
create object instance te_persist of TE_PERSIST;
::persist_factory( te_persist:te_persist );
create object instance te_relinfo of TE_RELINFO;
::relinfo_factory( te_relinfo:te_relinfo );
create object instance te_relstore of TE_RELSTORE;
::relstore_factory( te_relstore:te_relstore );
create object instance te_set of TE_SET;
::set_factory( te_set:te_set );
create object instance te_slist of TE_SLIST;
::slist_factory( te_slist:te_slist );
create object instance te_string of TE_STRING;
::string_factory( te_string:te_string );
create object instance te_thread of TE_THREAD;
::thread_factory( te_thread:te_thread );
create object instance te_tim of TE_TIM;
::tim_factory( te_tim:te_tim );
create object instance te_callout of TE_CALLOUT;
::callout_factory( te_callout:te_callout );
create object instance te_trace of TE_TRACE;
::trace_factory( te_trace:te_trace );
create object instance te_extent of TE_EXTENT;
::extent_factory( te_extent:te_extent );
create object instance te_target of TE_TARGET;
::target_factory( te_target:te_target );
//
create object instance te_assign of TE_ASSIGN;
create object instance te_create_instance of TE_CREATE_INSTANCE;
create object instance te_for of TE_FOR;
create object instance te_if of TE_IF;
create object instance te_while of TE_WHILE;
create object instance te_elif of TE_ELIF;
create object instance te_delete_instance of TE_DELETE_INSTANCE;
create object instance te_create_event of TE_CREATE_EVENT;
create object instance te_relate of TE_RELATE;
create object instance te_relate_using of TE_RELATE_USING;
create object instance te_unrelate of TE_UNRELATE;
create object instance te_unrelate_using of TE_UNRELATE_USING;
create object instance te_select of TE_SELECT;
create object instance te_select_where of TE_SELECT_WHERE;
create object instance te_generate_precreated_event of TE_GENERATE_PRECREATED_EVENT;
create object instance te_event_parameters of TE_EVENT_PARAMETERS;
create object instance te_generate of TE_GENERATE;
create object instance te_generate_creator_event of TE_GENERATE_CREATOR_EVENT;
create object instance te_generate_to_class of TE_GENERATE_TO_CLASS;
create object instance te_sgn of TE_SGN;
create object instance te_iop of TE_IOP;
create object instance te_operation of TE_OPERATION;
create object instance te_bridge of TE_BRIDGE;
create object instance te_function of TE_FUNCTION;
create object instance te_return of TE_RETURN;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	3,
	'');
INSERT INTO PE_PE
	VALUES ("78270698-fa3e-4c4d-89dd-a3ea00488f23",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("e0e8a924-f549-4e50-9ee0-af61843ab967",
	2,
	"efb614c1-5af5-40ee-92c8-706430a99db3",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("efb614c1-5af5-40ee-92c8-706430a99db3",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'ooaofooa',
	'========================================================================

File:          $RCSfile: ooaofooa.xtuml,v $
Version:   $Revision: 1.127 $
Modified:  $Date: 2006/09/26 15:10:20 $

(c) Copyright 2004-2012 by Mentor Graphics Corp. All rights reserved.

========================================================================
This document contains information proprietary and confidential to
Mentor Graphics Corp. and is not for external distribution.
========================================================================

This is the application domain for the Tiger project.

The processing in this model describes the activities
for model capture.



',
	0,
	'../ooaofooa.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'com.mentor.nucleus.bp.core',
	1,
	'../../../../com.mentor.nucleus.bp.core.xtuml');
