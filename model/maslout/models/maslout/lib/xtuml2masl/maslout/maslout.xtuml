-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	"53107551-b0b9-4155-a13f-41b410f63a54",
	'maslout',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("77fe7d4d-51d6-4276-af06-63cebf5e0482",
	112,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'4.1.17',
	'maslout::lib::xtuml2masl::maslout');
INSERT INTO DIM_DIA
	VALUES ("77fe7d4d-51d6-4276-af06-63cebf5e0482",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	"00000000-0000-0000-0000-000000000000",
	'masl_domain',
	'',
	'TRACE::log( flavor:"info", id:103, message:"Starting domain." );

domain = param.domain;

// Query and Populate
// Query the xtUML meta-model and populate the MASL meta-model.

select many c_cs from instances of C_C where ( false );
if ( ( "" == domain ) or ( "*" == domain ) )
  select many c_cs from instances of C_C;
else
  select many c_cs from instances of C_C where ( selected.Name == domain );
end if;
if ( empty c_cs )
  TRACE::log( flavor:"failure", id:1, message:"ERROR:  Component/domain not found in model:  " + domain );
else
  ::component2domain( c_cs:c_cs, project:false, kl:param.kl );
  for each c_c in c_cs
    //gen::render( element:"domain", name:c_c.Name );
  end for;
end if;

TRACE::log( flavor:"info", id:104, message:"Done." );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("9c8d9c3a-c0a1-4d32-81e0-b96654392cc0",
	"0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("865858ba-af92-4a81-a049-10fec802f1e0",
	"0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"9c8d9c3a-c0a1-4d32-81e0-b96654392cc0",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	"00000000-0000-0000-0000-000000000000",
	'masl_project',
	'',
	'TRACE::log( flavor:"info", id:101, message:"Starting Project" );

project = param.project;
// Query and Populate
// Query the xtUML meta-model and populate the MASL meta-model.

select many ep_pkgs from instances of EP_PKG where ( false );
if ( ( "" == project ) or ( "*" == project ) )
  // CDS - temporary for marking the project
  select many ep_pkgs from instances of EP_PKG where ( selected.Descrip == project );
else
  select many ep_pkgs from instances of EP_PKG where ( selected.Name == project );
end if;
if ( empty ep_pkgs )
  TRACE::log( flavor:"failure", id:1, message:"ERROR:  project package was not found:" + project );
end if;

::package2project( ep_pkgs:ep_pkgs, kl:param.kl );

TRACE::log( flavor:"info", id:102, message:"Done" );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("df408732-1e8c-4be3-bbf2-6c34377e1afe",
	"9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	'project',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("16407558-fde5-45f4-8d1c-43d813bf8d28",
	"9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"df408732-1e8c-4be3-bbf2-6c34377e1afe",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("84687e5f-e288-4907-9432-62372e5f265f",
	"00000000-0000-0000-0000-000000000000",
	'component2domain',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_cs = param.c_cs;
for each c_c in c_cs;
  value[0] = c_c.Name;
  out::populate( element:"domain", value:value );
  
  if ( param.project )
    ::type2type( c_c:c_c );
    ::port2terminator( c_c:c_c, project:param.project, kl:param.kl );
  else
    ::class2objectdeclaration( c_c:c_c );
    ::type2type( c_c:c_c );
    ::exception2exception( c_c:c_c );
    ::function2routine( c_c:c_c );
    ::port2terminator( c_c:c_c, project:param.project, kl:param.kl );
    ::association2relationship( c_c:c_c );
    ::class2object( c_c:c_c, kl:param.kl );
  end if;
  
  if ( param.project )
    // Populate pragmas
    select any cl_ic related by c_c->CL_IC[R4201];
    if ( not_empty cl_ic )
      select one ep_pkg related by cl_ic->PE_PE[R8001]->EP_PKG[R8000];
      ::mark2pragma( markable:"Component Reference", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:cl_ic.Name ) );
    end if;

    // output the description
    ::Descrip2description( Descrip:cl_ic.Descrip );
  else
    // Populate pragmas
    ::mark2pragma( markable:"Component", pathkey: ::component_get_path( c_c:c_c, child:"" ) );

    // output the description
    ::Descrip2description( Descrip:c_c.Descrip );
  end if;
  
  out::populate( element:"domain", value:emptyvalue );
end for;
      ',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("cf4db11c-a368-4494-9f14-382c45cdc747",
	"84687e5f-e288-4907-9432-62372e5f265f",
	'c_cs',
	"5228eeb5-5532-4f4d-8d56-d20e0a1a6189",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5228eeb5-5532-4f4d-8d56-d20e0a1a6189",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Component>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("75a907fb-78de-49b0-b748-176ee43e0b29",
	"84687e5f-e288-4907-9432-62372e5f265f",
	'project',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"cf4db11c-a368-4494-9f14-382c45cdc747",
	'');
INSERT INTO S_SPARM
	VALUES ("b4e0ed8b-05be-4594-a8cb-8fd66101c957",
	"84687e5f-e288-4907-9432-62372e5f265f",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"75a907fb-78de-49b0-b748-176ee43e0b29",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("84687e5f-e288-4907-9432-62372e5f265f",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bbd421d2-e67f-41ea-be98-398a6baf075d",
	"00000000-0000-0000-0000-000000000000",
	'package2project',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

ep_pkgs = param.ep_pkgs;
for each ep_pkg in ep_pkgs

  select any project_c_c related by ep_pkg->PE_PE[R8000]->C_C[R8001];
  if ( not_empty project_c_c )

    value[0] = ep_pkg.Name;
    out::populate( element:"project", value:value );

    select many referred_c_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201];
    ::component2domain( c_cs:referred_c_cs, project:true, kl:param.kl );

    // Populate pragmas
    ::mark2pragma( markable:"Component", pathkey: ::component_get_path( c_c:project_c_c, child:"" ) );

    // output the description
    ::Descrip2description( Descrip:project_c_c.Descrip );

    // end project
    out::populate( element:"project", value:emptyvalue );
  
  end if;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e1434ed1-bb84-419d-aa6a-b3a6dcaae855",
	"bbd421d2-e67f-41ea-be98-398a6baf075d",
	'ep_pkgs',
	"2dfbba0c-72a2-4c76-8486-8613e7ea4b99",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2dfbba0c-72a2-4c76-8486-8613e7ea4b99",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Package>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO S_SPARM
	VALUES ("d0cb0012-0c1e-466f-b03e-ee5aa15dc4ca",
	"bbd421d2-e67f-41ea-be98-398a6baf075d",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e1434ed1-bb84-419d-aa6a-b3a6dcaae855",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("bbd421d2-e67f-41ea-be98-398a6baf075d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	"00000000-0000-0000-0000-000000000000",
	'port2terminator',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
// (outbound) port -> terminator
select many c_pos related by c_c->C_PO[R4010]->C_IR[R4016]->C_R[R4009]->C_IR[R4009]->C_PO[R4016];
for each c_po in c_pos
  // if we are processing a project, make sure that there is a provision. If not, this terminator was not
  // defined in the project file and should not be emitted with the project
  select any provision related by c_po->C_IR[R4016]->C_I[R4012]->C_IR[R4012]->C_P[R4009];
  if ( not param.project or ( param.project and not_empty provision ) )

	value[0] = c_po.Name;
	out::populate( element:"terminator", value:value );
	::message2routine( c_c:c_c, c_po:c_po, project:param.project );

	// Populate pragmas
	if ( param.project )
      select any c_p related by c_po->C_IR[R4016]->C_I[R4012]->C_IR[R4012]->C_P[R4009];
	  if ( not_empty c_p )
	    if ( not param.kl )
		  c_p.Descrip = ::remove_kl( s:c_p.Descrip );
		end if;
        ::mark2pragma( markable:"Provision", pathkey: ::component_get_path( c_c:c_c, child:c_p.Name ) );

		// output the description
		::Descrip2description( Descrip:c_p.Descrip );
	  end if;
	else
	  select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
	  if ( not_empty c_r )
	    if ( not param.kl )
		  c_r.Descrip = ::remove_kl( s:c_r.Descrip );
		end if;
        ::mark2pragma( markable:"Requirement", pathkey: ::component_get_path( c_c:c_c, child:c_r.Name ) );

		// output the description
		::Descrip2description( Descrip:c_r.Descrip );
	  end if;
	end if;

	// end terminator
	out::populate( element:"terminator", value:emptyvalue );

  end if;

end for;

  
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e557817d-dd43-43a1-b7c1-a522bda54d2a",
	"3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("0df5f9f2-ee02-4900-9478-2ee36ce46c1d",
	"3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	'project',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e557817d-dd43-43a1-b7c1-a522bda54d2a",
	'');
INSERT INTO S_SPARM
	VALUES ("86f1e636-f893-4b66-9d8c-eb882fb3568f",
	"3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"0df5f9f2-ee02-4900-9478-2ee36ce46c1d",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	"00000000-0000-0000-0000-000000000000",
	'message2routine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
c_po = param.c_po;
// message -> function/service
value[0] = c_c.Name;
value[1] = "";

select many c_eps related by c_po->C_IR[R4016]->C_I[R4012]->C_EP[R4003];
for each c_ep in c_eps
    
  if ( param.project )
    select any spr_po related by c_ep->SPR_PEP[R4501]->SPR_PO[R4503];
    if ( not_empty spr_po )
      if ( ActionDialect::none == spr_po.Dialect )
        // A project can skip supplying a terminator service.  A dialect
        // of ActionDialect::none means no terminator service was provided.
        continue;
      end if;
    end if;
  end if;

  value[2] = "public"; // Outbound messages are considered public.
  value[3] = c_ep.Name;
  out::populate( element:"routine", value:value );
  
  select any c_pp related by c_ep->C_PP[R4006];
  first_c_pp = c_pp;
  while ( not_empty c_pp )
    first_c_pp = c_pp;
    select one c_pp related by c_pp->C_PP[R4021.''succeeds''];
  end while;
  ::parameterC_PP2parameter( c_pp:first_c_pp );
  
  select one s_dt related by c_ep->C_IO[R4004]->S_DT[R4008];
  if ( not_empty s_dt )
    // Do not send a void typeref.  No typeref equals void in MASL.
    if ( "void" != s_dt.Name )
      value[0] = s_dt.Name;
      value[1] = "";
      value[2] = "";
      value[3] = "";
      out::populate( element:"typeref", value:value );
      out::populate( element:"typeref", value:emptyvalue );
    end if;
  end if;
  
  // Populate the action langauge body.
  port_name = "";
  if ( param.project )
    select any project_c_po related by c_po->C_IR[R4016]->C_I[R4012]->C_IR[R4012]->C_P[R4009]->C_IR[R4009]->C_PO[R4016];
    select one project_c_c related by project_c_po->C_C[R4010];
    port_name = project_c_po.Name;
  else
    port_name = c_po.Name;
  end if;
  
  select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
  if ( param.project )
    select any spr_po related by c_ep->SPR_PEP[R4501]->SPR_PO[R4503];
    ::body2code_block( name:"", text:STRING::unescapetics(s:spr_po.Action_Semantics_internal) );

	// Populate pragmas
        select one c_ep related by spr_po->SPR_PEP[R4503]->C_EP[R4501];
        child = c_po.Name + "::" + c_i.Name + "::" + ::message_getsignature( flavor:1, c_ep:c_ep );
        ::mark2pragma( markable:"Provided Operation", pathkey: ::component_get_path( c_c:c_c, child:child ) );

	// output the description
	::Descrip2description( Descrip:spr_po.Descrip );
  else
    select any spr_ro related by c_ep->SPR_REP[R4500]->SPR_RO[R4502];
    ::body2code_block( name:"", text:STRING::unescapetics(s:spr_ro.Action_Semantics_internal) );

	// Populate pragmas
        select one c_ep related by spr_ro->SPR_REP[R4502]->C_EP[R4500];
        child = c_po.Name + "::" + c_i.Name + "::" + ::message_getsignature( flavor:1, c_ep:c_ep );
        ::mark2pragma( markable:"Required Operation", pathkey: ::component_get_path( c_c:c_c, child:child ) );

	// output the description
	::Descrip2description( Descrip:spr_ro.Descrip );
  end if;

  out::populate( element:"routine", value:emptyvalue );
  
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("8898a959-9ae1-44df-90ff-dcc22215a9db",
	"d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"4b7d90b1-ba1a-44db-b40b-6ee2f036eea4",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("4b7d90b1-ba1a-44db-b40b-6ee2f036eea4",
	"d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("bd5f6378-3914-4e0b-98f4-b339368ec422",
	"d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	'project',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"8898a959-9ae1-44df-90ff-dcc22215a9db",
	'');
INSERT INTO PE_PE
	VALUES ("d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	"00000000-0000-0000-0000-000000000000",
	'parameterC_PP2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_pp = param.c_pp;
if ( not_empty c_pp )
  value[0] = c_pp.Name;
  if ( 0 == c_pp.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by c_pp->S_DT[R4007];
  value[0] = s_dt.Name;
  value[1] = "";
  out::populate( element:"typeref", value:value );
  out::populate( element:"typeref", value:emptyvalue );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
  ::parameterC_PP2parameter( c_pp:c_pp );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("a476bde7-fb21-4a1f-b22b-46b5fe763364",
	"dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	"00000000-0000-0000-0000-000000000000",
	'class2object',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
select many o_objs related by c_c->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->O_OBJ[R8001];
for each o_obj in o_objs
  value[0] = o_obj.Name;
  out::populate( element:"object", value:value );
  
  // Link the attributes to each object.
  ::attribute2attribute( c_c:c_c, o_obj:o_obj );
  
  // Set up the identifiers for this object.
  ::identifier2identifier( o_obj:o_obj );
  
  // class operations
  ::classop2objectop( c_c:c_c, o_obj:o_obj );
  
  select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
  if ( not_empty sm_sm )
    // blank type is normal
    ::state2state( o_obj:o_obj, sm_sm:sm_sm, type:"" );
    ::event2event( o_obj:o_obj, sm_sm:sm_sm, type:"" );
    ::statemachine2statemachine( o_obj:o_obj, sm_sm:sm_sm, type:"" );
  end if;
  
  select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
  if ( not_empty sm_sm )
    ::state2state( o_obj:o_obj, sm_sm:sm_sm, type:"assigner" );
    ::event2event( o_obj:o_obj, sm_sm:sm_sm, type:"assigner" );
    ::statemachine2statemachine( o_obj:o_obj, sm_sm:sm_sm, type:"assigner" );
  end if;
  
  // insert the key letters as a pragma
  if ( param.kl )
    value[0] = "key_letter";
    out::populate( element:"pragma", value:value );
    quote = STRING::quote();
    value[0] = quote + o_obj.Key_Lett + quote;
    out::populate( element:"pragmaitem", value:value );
    out::populate( element:"pragma", value:emptyvalue );
  end if;
  
  // output pragmas
  ::mark2pragma( markable:"Model Class", pathkey: ::class_get_path( o_obj:o_obj, child:"" ) );

  // output the description
  ::Descrip2description( Descrip:o_obj.Descrip );
  
  out::populate( element:"object", value:emptyvalue );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("15b7c710-66b8-4afc-8a74-5728d734391a",
	"5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a8f66f26-bfad-46a6-b434-419f388a91f8",
	"5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"15b7c710-66b8-4afc-8a74-5728d734391a",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("636cf3d3-f72d-4072-b665-cde360ef7edb",
	"00000000-0000-0000-0000-000000000000",
	'attribute2attribute',
	'',
	'/*
  Attribute (O_ATTR) -> attribute
  primary identifier (O_OIDA == 1) -> preferred
  Attribute type of unique_id (O_ATTR->S_DT) -> unique
*/
  
value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
c_c = param.c_c;
select many o_attrs related by o_obj->O_ATTR[R102];
for each o_attr in o_attrs
  select one s_dt related by o_attr->S_DT[R114];
  // if it is a referential attribute, get the datatype of the base attribute
  select one o_rattr related by o_attr->O_RATTR[R106];
  if ( not_empty o_rattr )
    select one base_o_attr related by o_rattr->O_BATTR[R113]->O_ATTR[R106];
    if ( not_empty base_o_attr )
      select one s_dt related by base_o_attr->S_DT[R114];
      if ( "unique_id" == s_dt.Name or "MASLunique" == s_dt.Name )
        // referentials referring to a "MASLunique" type should not propagate
        // "unique"-ness ot the referential
        select any s_dt from instances of S_DT where ( selected.Name == "integer" );
      end if;
    end if;
  end if;

  if ( ( "current_state" == o_attr.Name ) and ( "state<State_Model>" == s_dt.Name ) )
    // Do not populate a current_state attribute with type state<State_Model>.
  else
    value[0] = o_attr.Name;
    value[1] = "";
    // See if this attribute is in the primary identifier.
    select any o_oida related by o_attr->O_OIDA[R105] where ( selected.Oid_ID == 0 );
    if ( not_empty o_oida )
      value[1] = "preferred";
    end if;
    value[2] = "";
    // See if the type of this attribute is unique_id or MASLunique.
    // ''unique'' is dropped when this is a referential attribute
    if ( "unique_id" == s_dt.Name or "MASLunique" == s_dt.Name )
      select any o_oida related by o_attr->O_OIDA[R105];
      if ( ( empty o_rattr ) or ( not_empty o_oida ) )
        // unless it is part of an identifier
        value[2] = "unique";
      end if;
    end if;
    // CDS - Coerce inst_ref<Timer>
    if ( "inst_ref<Timer>" == value[2] )
      value[2] = "inst_refTimer";
    end if;
    out::populate( element:"attribute", value:value );
    value[1] = "";
    value[2] = "";
  
    // The default value comes first from the attribute then from its type.
    value[0] = o_attr.DefaultValue;
    if ( "" == o_attr.DefaultValue )
      value[0] = s_dt.DefaultValue;
    end if;
    if ( "" != value[0] )
      // Do not populate expression unless we have something useful.
      out::populate( element:"expression", value:value );
    end if;
  
    // Populate the type referred to by this attribute as a type reference.
    if ( s_dt.Name == "MASLunique" )	// MASLunique is always an integer
      value[0] = "integer";
    else
      value[0] = s_dt.Name;
    end if;
    out::populate( element:"typeref", value:value );
    out::populate( element:"typeref", value:emptyvalue );
    
    // See if this attribute is a referential.
    select many o_refs related by o_attr->O_RATTR[R106]->O_REF[R108];
    for each o_ref in o_refs

      select one rto related by o_ref->O_RTIDA[R111]->R_RTO[R110];
      select one rel related by rto->R_OIR[R203]->R_REL[R201];
      select one rto_obj related by rto->R_OIR[R203]->O_OBJ[R201];
      select one ref_o_attr related by o_ref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105];

      value[0] = "R" + STRING::itoa( i:rel.Numb );	// relationship number
      value[1] = ""; //value[1] = c_c.Name; // domain name
      
      // see if there is a role phrase. if so, include it
      textphrase = "";
      select one r_part related by rto->R_PART[R204];
      if ( not_empty r_part )
        textphrase = r_part.Txt_Phrs;
      else
        select one r_aone related by rto->R_AONE[R204];
        if ( not_empty r_aone )
          textphrase = r_aone.Txt_Phrs;
        else
          select one r_aoth related by rto->R_AOTH[R204];
          if ( not_empty r_aoth )
            textphrase = r_aoth.Txt_Phrs;
          end if;
        end if;
      end if;
      
      if ( "" == textphrase )
        select one r_sup related by rto->R_SUPER[R204];
        if ( not_empty r_sup )	   // if this is a subsuper relationship, exclude the object name
          value[2] = "";
        else
          value[2] = rto_obj.Name; // if there is no text phrase, use the object name
        end if;
        value[3] = "";
      else
        value[2] = textphrase; // use the phrase and the object name
        value[3] = rto_obj.Name; // referred to object name object
      end if;

      value[4] = ref_o_attr.Name; // referred to attribute name
      out::populate( element:"referential", value:value );
      value[1] = "";
      value[2] = "";
      value[3] = "";
      value[4] = "";
      out::populate( element:"referential", value:emptyvalue );
    end for;
    
    // Populate pragmas
    ::mark2pragma( markable:"Attribute", pathkey: ::class_get_path( o_obj:o_obj, child:o_attr.Name ) );

    // output the description
    ::Descrip2description( Descrip:o_attr.Descrip );
  
    out::populate( element:"attribute", value:emptyvalue );
  end if;
  
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("4488e70f-8f35-4b8b-9c0b-8f144d9acacf",
	"636cf3d3-f72d-4072-b665-cde360ef7edb",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"44cd8d5d-9f12-4f3a-b2bf-016ed0e68b7f",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("44cd8d5d-9f12-4f3a-b2bf-016ed0e68b7f",
	"636cf3d3-f72d-4072-b665-cde360ef7edb",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("636cf3d3-f72d-4072-b665-cde360ef7edb",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2f0e3a99-9a8b-44dc-9428-f75cfbd83fdd",
	"00000000-0000-0000-0000-000000000000",
	'type2type',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";
c_c = param.c_c;

// Data types in packages inside the component are considered private.
select many s_dts related by c_c->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001];
for each s_dt in s_dts
  select one s_irdt related by s_dt->S_IRDT[R17];
  // Do not output type definitions for instance reference data types.
  if ( empty s_irdt )
    select one s_udt related by s_dt->S_UDT[R17];
    select one s_edt related by s_dt->S_EDT[R17];

    value[0] = s_dt.Name;
    value[1] = "private";
    
    if ( not_empty s_udt )
      // see what type the UDT is based on
      select one base_s_dt related by s_udt->S_DT[R18];
    
      // get body of type
      if ( s_udt.Definition != "" )
        // handle case where there is a definition
        value[2] = s_udt.Definition;
      else
        // There is no definition, use the underlying type.  If the underlying type
        // is MASLtype, treat this as a typeref and do not output it.  Otherwise
        // output using the underlying type as the definition.
        if ( (base_s_dt.Name == "MASLtype") or (s_dt.Name == "MASLtype") )
          continue;
        else
          value[2] = base_s_dt.Name;
        end if;
      end if;
    elif ( not_empty s_edt )
      select any s_enum from instances of S_ENUM where (false);
      // get to the first entry
      select any prev_s_enum related by s_edt->S_ENUM[R27];
      while (not_empty prev_s_enum)
        assign s_enum = prev_s_enum;
        select one prev_s_enum related by s_enum->S_ENUM[R56.''precedes''];
      end while;
      // now iterate over the entries building up the list
      enum_definition = "enum (";
      next_s_enum = s_enum;
      first = true;
      while (not_empty next_s_enum)
        if (not first)
          enum_definition = enum_definition + ", ";
        end if;
        first = false;
        enum_definition = enum_definition + next_s_enum.Name;
        assign s_enum = next_s_enum;
        select one next_s_enum related by s_enum->S_ENUM[R56.''succeeds''];
      end while;
      enum_definition = enum_definition + ")";      
      value[2] = enum_definition;
    else
      continue;
    end if;
  
    out::populate( element:"type", value:value );

    select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
    ::mark2pragma( markable:"User Data Type", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: s_dt.Name ) );

    ::Descrip2description( Descrip:s_dt.Descrip );
    out::populate( element:"type", value:emptyvalue );
  end if;
end for;

// Data types in packages directly off of the system are considered public.
select many ep_pkgs related by c_c->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1401] where ( selected.Name != "types" );
for each ep_pkg in ep_pkgs
select many s_dts related by ep_pkg->PE_PE[R8000]->S_DT[R8001];
for each s_dt in s_dts
  value[0] = s_dt.Name;
  value[1] = "public";

  // get body of type
  select one s_udt related by s_dt->S_UDT[R17];
  if ( s_udt.Definition != "" )	// only output types if there is a definition
    value[2] = s_udt.Definition;

    out::populate( element:"type", value:value );

    ::mark2pragma( markable:"User Data Type", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: s_dt.Name ) );

    ::Descrip2description( Descrip:s_dt.Descrip );
    out::populate( element:"type", value:emptyvalue );
  end if;
end for;
end for;

// Data types in subpackages of the system packages are also considered public
select many sub_pkgs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001];
while ( not_empty sub_pkgs )
  select many s_dts related by sub_pkgs->PE_PE[R8000]->S_DT[R8001];
  for each s_dt in s_dts
	value[0] = s_dt.Name;
	value[1] = "public";

	// get body of type
	select one s_udt related by s_dt->S_UDT[R17];
    if ( s_udt.Definition != "" )	// only output types if there is a definition
      value[2] = s_udt.Definition;

      out::populate( element:"type", value:value );

      select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
      ::mark2pragma( markable:"User Data Type", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: s_dt.Name ) );

      ::Descrip2description( Descrip:s_dt.Descrip );
      out::populate( element:"type", value:emptyvalue );
    end if;
  end for;
  select many sub_pkgs related by sub_pkgs->PE_PE[R8000]->EP_PKG[R8001];
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("07c30bd2-62a1-4290-9717-fc84fa995641",
	"2f0e3a99-9a8b-44dc-9428-f75cfbd83fdd",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("2f0e3a99-9a8b-44dc-9428-f75cfbd83fdd",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("59846fd7-dd0d-4c7a-b24d-c8bad6617b7c",
	"00000000-0000-0000-0000-000000000000",
	'association2relationship',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
select many r_rels related by c_c->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->R_REL[R8001];
for each r_rel in r_rels
  value[0] = ""; value[1] = ""; value[2] = ""; value[3] = "";
  value[4] = ""; value[5] = ""; value[6] = ""; value[7] = "";
  value[0] = "R" + STRING::itoa( i:r_rel.Numb );  // itoa to form relationship name
  select one ep_pkg related by r_rel->PE_PE[R8001]->EP_PKG[R8000];
  select one r_simp related by r_rel->R_SIMP[R206];
  if ( not_empty r_simp )
    out::populate( element:"regularrel", value:value );
    ::simpleass2regularrel( c_c:c_c, r_simp:r_simp );
    ::mark2pragma( markable:"Association", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: "R" + T::s( i:r_rel.Numb ) ) );
    // output the description
    ::Descrip2description( Descrip:r_rel.Descrip );
    out::populate( element:"regularrel", value:emptyvalue );
  end if;
  
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    // Get the name of the associator.
    select one o_obj related by r_assoc->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
    value[1] = c_c.Name;
    value[2] = o_obj.Name;
    out::populate( element:"associative", value:value );
    ::associative2associative( c_c:c_c, r_assoc:r_assoc );
    out::populate( element:"associative", value:value ); // 2nd call for using
    ::mark2pragma( markable:"Association", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: "R" + T::s( i:r_rel.Numb ) ) );
    // output the description
    ::Descrip2description( Descrip:r_rel.Descrip );
    out::populate( element:"associative", value:emptyvalue );
  end if;
  
  select one r_subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty r_subsup )
    out::populate( element:"subsuper", value:value );
    ::subsuper2subsuper( c_c:c_c, r_subsup:r_subsup );
    ::mark2pragma( markable:"Association", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: "R" + T::s( i:r_rel.Numb ) ) );
    // output the description
    ::Descrip2description( Descrip:r_rel.Descrip );
    out::populate( element:"subsuper", value:emptyvalue );
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("51c46f46-bc0f-4bf0-8fe4-af7d3be1667e",
	"59846fd7-dd0d-4c7a-b24d-c8bad6617b7c",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("59846fd7-dd0d-4c7a-b24d-c8bad6617b7c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("09d28e26-8c9d-40c0-b89a-276922023942",
	"00000000-0000-0000-0000-000000000000",
	'identifier2identifier',
	'',
	'/*
  Assuming 8 or less identifier attributes.
*/
value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
// Select the non-primary identifiers.  The primary identifier will be marked as preferred.
select many o_ids related by o_obj->O_ID[R104] where ( selected.Oid_ID != 0 );
for each o_id in o_ids
  value[7] = ""; value[6] = ""; value[5] = ""; value[4] = "";
  value[3] = ""; value[2] = ""; value[1] = ""; value[0] = "";
  select many o_attrs related by o_id->O_ATTR[R105];
  if ( not_empty o_attrs )
    value[0] = "symbolic"; // non-empty string to indicate start of identifier
    out::populate( element:"identifier", value:value );
    for each o_attr in o_attrs
      value[0] = o_attr.Name;
      out::populate( element:"attribute", value:value );
      out::populate( element:"attribute", value:emptyvalue );
    end for;

    // CDS - identifiers are not actually selectable from the marking editor
    ::mark2pragma( markable:"Class Identifier", pathkey: ::class_get_path( o_obj:o_obj, child: T::s( i:o_id.Oid_ID ) ) );

    out::populate( element:"identifier", value:emptyvalue );
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("a84bec3f-93e6-496d-aa58-e382e6c4e593",
	"09d28e26-8c9d-40c0-b89a-276922023942",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("09d28e26-8c9d-40c0-b89a-276922023942",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	"00000000-0000-0000-0000-000000000000",
	'simpleass2regularrel',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
r_simp = param.r_simp;
select many r_parts related by r_simp->R_PART[R207];
name[7] = ""; phrase[7] = ""; cond[7] = ""; mult[7]= ""; toname[7] = "";
i = 0;
for each r_part in r_parts
  select one o_obj related by r_part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 
  name[i] = o_obj.Name;
  phrase[i] = T::underscore( s:r_part.Txt_Phrs );
  if ( 0 == r_part.Cond )
    cond[i] = "unconditionally";
  else
    cond[i] = "conditionally";
  end if;
  if ( 0 == r_part.Mult )
    mult[i] = "one";
  else
    mult[i] = "many";
  end if;
  toname[i] = ""; // CDS - get toname
  i = i + 1;
end for;

if ( 1 == i )
  // only one participant, go get the formalizer
  select one r_form related by r_simp->R_FORM[R208];
  select one o_obj related by r_form->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]; 
  name[1] = o_obj.Name;
  phrase[1] = T::underscore( s:r_form.Txt_Phrs );
  if ( 0 == r_form.Cond )
    cond[1] = "unconditionally";
  else
    cond[1] = "conditionally";
  end if;
  if ( 0 == r_form.Mult )
    mult[1] = "one";
  else
    mult[1] = "many";
  end if;
  toname[1] = ""; // CDS - get toname
end if;

if ( ( "" == phrase[0] ) or ( "" == phrase[1] ) )
  TRACE::log( flavor:"failure", id:12, message:"no role phrase for:  " + name[0] + " to " + name[1] );
end if;

value[0] = c_c.Name;
value[1] = name[0];
value[2] = phrase[1];
value[3] = cond[1];
value[4] = mult[1];
value[5] = c_c.Name;
value[6] = name[1];
out::populate( element:"participation", value:value );

value[0] = c_c.Name;
value[1] = name[1];
value[2] = phrase[0];
value[3] = cond[0];
value[4] = mult[0];
value[5] = c_c.Name;
value[6] = name[0];
out::populate( element:"participation", value:value );

out::populate( element:"participation", value:emptyvalue );

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("11a9addd-1ac4-4fa9-abbd-0ff170d8e031",
	"844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	'r_simp',
	"322c65da-132b-421a-a1b1-f757cb0acff7",
	0,
	'',
	"4ebc7b0a-e6f4-4dcf-aab8-955aeb9c0826",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("322c65da-132b-421a-a1b1-f757cb0acff7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Simple Association>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("4ebc7b0a-e6f4-4dcf-aab8-955aeb9c0826",
	"844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ca010eda-543b-4971-abfb-32b006d6d31c",
	"00000000-0000-0000-0000-000000000000",
	'function2routine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
value[0] = c_c.Name;
value[1] = "";
select many c_eps related by c_c->C_PO[R4010]->C_IR[R4016]->C_P[R4009]->C_IR[R4009]->C_I[R4012]->C_EP[R4003];
select many s_syncs related by c_c->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_SYNC[R8001];
for each s_sync in s_syncs

  value[2] = "private";
  // Find a provided port message with this same name.  If found, mark public.
  for each c_ep in c_eps
    if ( c_ep.Name == s_sync.Name )
      value[2] = "public";
      break;
    end if;
  end for;
  value[3] = s_sync.Name;
  
  // Get the first parameter.
  select any s_sparm related by s_sync->S_SPARM[R24];
  first_s_sparm = s_sparm;
  while ( not_empty s_sparm )
    first_s_sparm = s_sparm;
    select one s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
  end while;
  
  out::populate( element:"routine", value:value );
  ::parameterS_SPARM2parameter( s_sparm:first_s_sparm );
  // find return type if exists
  select one s_dt related by s_sync->S_DT[R25];
  if ( not_empty s_dt )
    // Do not send a void typeref.  No typeref equals void in MASL.
    if ( "void" != s_dt.Name )
      value[0] = s_dt.Name;
      out::populate( element:"typeref", value:value );
      out::populate( element:"typeref", value:emptyvalue );
    end if;
  end if;
  
  if ( ActionDialect::masl == s_sync.Dialect )
    // Populate the action langauge body.
    ::body2code_block( name:"", text:STRING::unescapetics(s:s_sync.Action_Semantics_internal) );
  end if;
  
  // Populate pragmas
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Function", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: ::function_getsignature( flavor:1, s_sync:s_sync ) ) );

  // output the description
  ::Descrip2description( Descrip:s_sync.Descrip );
  
  out::populate( element:"routine", value:emptyvalue );
  
end for;
  

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("6f121837-e5ec-493f-a1f1-f42c2bc5c711",
	"ca010eda-543b-4971-abfb-32b006d6d31c",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ca010eda-543b-4971-abfb-32b006d6d31c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	"00000000-0000-0000-0000-000000000000",
	'parameterS_SPARM2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

s_sparm = param.s_sparm;
if ( not_empty s_sparm )
  value[0] = s_sparm.Name;
  if ( 0 == s_sparm.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by s_sparm->S_DT[R26];
  value[0] = s_dt.Name;
  value[1] = "";
  out::populate( element:"typeref", value:value );
  out::populate( element:"typeref", value:emptyvalue );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
  ::parameterS_SPARM2parameter( s_sparm:s_sparm );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("60fb8b97-7f20-4095-b943-e08c3a8e2e31",
	"be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a01a1995-8ff8-44fe-abb1-b11213d98016",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("78002803-6c30-4367-95a3-30a4b7969a69",
	"00000000-0000-0000-0000-000000000000",
	'statemachine2statemachine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
sm_sm = param.sm_sm;
value[0] = param.type;

select many sm_states related by sm_sm->SM_STATE[R501];
select any sm_evt related by sm_sm->SM_EVT[R502];
// We must have at least one state and one event to have a table.
if ( ( not_empty sm_states ) and ( not_empty sm_evt ) )

out::populate( element:"transitiontable", value:value );

// only output the Non_Existent row for ISMs
if ( "assigner" != param.type )
  // Get all the transitions starting with "Non_Existent" state.
  value[0] = "Non_Existent";
  select many sm_evts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_EVT[R525];
  for each sm_evt in sm_evts
	value[1] = ""; // domain
	value[2] = ""; // object
	value[3] = sm_evt.Mning;
	value[4] = "Cannot_Happen";		// Non_Existent defaults to Cannot_Happen because this is required
										// for creation, terminal, and instance events (see section 8.3.2
										// of MASL reference manual)
	// if a creation transition exists, use the state name as the destination
	select one sm_crtxn related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
	if ( not_empty sm_crtxn )
	  select one sm_state related by sm_crtxn->SM_TXN[R507]->SM_STATE[R506];
	  value[4] = sm_state.Name;
	end if;
	// If event is non-local, then get the name of the supertype.
	select one poly_o_obj related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    if ( not_empty poly_o_obj and poly_o_obj.Obj_ID != o_obj.Obj_ID )
      value[2] = poly_o_obj.Name;
    end if;
	out::populate( element:"transition", value:value );
	out::populate( element:"transition", value:emptyvalue );
  end for;
	
  // output transition row pragmas
  ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Instance State Machine::Non_Existent" ) );

end if;

for each sm_state in sm_states
  value[0] = sm_state.Name;
  value[1] = ""; // domain
  select many sm_semes related by sm_state->SM_SEME[R503]; 
  for each sm_seme in sm_semes
    value[2] = ""; // object
    value[3] = ""; value[4] = "";
    select one sm_evt related by sm_seme->SM_SEVT[R503]->SM_EVT[R525];
    value[3] = sm_evt.Mning;
    select one poly_o_obj related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    if ( not_empty poly_o_obj and poly_o_obj.Obj_ID != o_obj.Obj_ID )
      value[2] = poly_o_obj.Name;
    end if;
    select one next_sm_state related by sm_seme->SM_NSTXN[R504]->SM_TXN[R507]->SM_STATE[R506];
    if ( not_empty next_sm_state )
      value[4] = next_sm_state.Name;
    else
      select one sm_eign related by sm_seme->SM_EIGN[R504];
      if ( not_empty sm_eign )
        value[4] = "Ignore";
      else
        select one sm_ch related by sm_seme->SM_CH[R504];
        if ( not_empty sm_ch )
          value[4] = "Cannot_Happen";
        else
          TRACE::log( flavor:"failure", id:102, message:"invalid state machine" );
        end if;
      end if;
    end if;
    out::populate( element:"transition", value:value );
    out::populate( element:"transition", value:emptyvalue );
  end for;
	
  // output transition row pragmas
  if ( "assigner" == param.type )
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Class State Machine::" + sm_state.Name ) );
  else
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Instance State Machine::" + sm_state.Name ) );
  end if;
	
end for;

// Populate pragmas
if ( "assigner" == param.type )
  ::mark2pragma( markable:"State Machine", pathkey: ::class_get_path( o_obj:o_obj, child:"Class State Machine" ) );
else
  ::mark2pragma( markable:"State Machine", pathkey: ::class_get_path( o_obj:o_obj, child:"Instance State Machine" ) );
end if;

out::populate( element:"transitiontable", value:emptyvalue );

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("5276c784-1f5f-4e92-a593-1c486c8cf8af",
	"78002803-6c30-4367-95a3-30a4b7969a69",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"fac936f0-5fff-4023-b8c2-2c33c854b8ed",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6562655-0940-4f4f-a1ae-7094b79949a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("3072f139-aa6e-4401-8f4d-6ab4cfd561fe",
	"78002803-6c30-4367-95a3-30a4b7969a69",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5276c784-1f5f-4e92-a593-1c486c8cf8af",
	'');
INSERT INTO S_SPARM
	VALUES ("fac936f0-5fff-4023-b8c2-2c33c854b8ed",
	"78002803-6c30-4367-95a3-30a4b7969a69",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("78002803-6c30-4367-95a3-30a4b7969a69",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7b593c09-c6aa-4291-b5ae-af8401687cb2",
	"00000000-0000-0000-0000-000000000000",
	'event2event',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
sm_sm = param.sm_sm;
// Get the events for this class, and filter out polys.
select many sm_evts related by sm_sm->SM_EVT[R502];
for each sm_evt in sm_evts

  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    continue; // skip to the next event in the iteration
  end if;

  value[0] = sm_evt.Mning;
  
  // set event type
  value[1] = param.type;
  // check for any creation transition associated with this event
  select one sm_crtxn related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
  if ( not_empty sm_crtxn )
    value[1] = "creation";
  end if;

  out::populate( element:"event", value:value );
  
  // Get first parameter.
  select any sm_evtdi related by sm_evt->SM_EVTDI[R532];
  first_sm_evtdi = sm_evtdi;
  while ( not_empty sm_evtdi )
    first_sm_evtdi = sm_evtdi;
    select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
  end while;
  ::parameterSM_EVTDI2parameter( sm_evtdi:first_sm_evtdi );
  
  // Populate pragmas
  if ( "assigner" == param.type )
    ::mark2pragma( markable:"State Machine Event", pathkey: ::class_get_path( o_obj:o_obj, child:"Class State Machine::" + sm_evt.Drv_Lbl + ":" + sm_evt.Mning ) );
  else
    ::mark2pragma( markable:"State Machine Event", pathkey: ::class_get_path( o_obj:o_obj, child:"Instance State Machine::" + sm_evt.Drv_Lbl + ":" + sm_evt.Mning ) );
  end if;

  // output the description
  ::Descrip2description( Descrip:sm_evt.Descrip );
  
  out::populate( element:"event", value:emptyvalue );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("9d4415e3-ad34-4d40-883c-8f8647a5f282",
	"7b593c09-c6aa-4291-b5ae-af8401687cb2",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"d1a4cfaf-538b-4560-bfef-2d391a79d4d6",
	'');
INSERT INTO S_SPARM
	VALUES ("7d621c7d-0fca-4ab6-9aa2-647b9c85918e",
	"7b593c09-c6aa-4291-b5ae-af8401687cb2",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9d4415e3-ad34-4d40-883c-8f8647a5f282",
	'');
INSERT INTO S_SPARM
	VALUES ("d1a4cfaf-538b-4560-bfef-2d391a79d4d6",
	"7b593c09-c6aa-4291-b5ae-af8401687cb2",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("7b593c09-c6aa-4291-b5ae-af8401687cb2",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b22bbb4b-d763-4757-840e-44c5ac1216bd",
	"00000000-0000-0000-0000-000000000000",
	'state2state',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
sm_sm = param.sm_sm;
select many sm_states related by sm_sm->SM_STATE[R501];
select any sm_state related by sm_sm->SM_STATE[R501];
lowest = 7777;
if ( not_empty sm_state )
  lowest = sm_state.Numb; // any random state number
end if;

if ( "assigner" == param.type )
  // Find the lowest numbered state to be ASSIGNER START.
  for each sm_state in sm_states
    if ( sm_state.Numb < lowest )
      lowest = sm_state.Numb;
    end if;
  end for;
else
  //
end if;

value[0] = ""; // domain, grammar allows this but we are not using it
value[1] = o_obj.Name;
for each sm_state in sm_states
  value[2] = sm_state.Name;
  
  // set state type
  value[3] = "";
  if ( ( "assigner" == param.type ) and ( lowest == sm_state.Numb ) )
    value[3] = "assigner start";
  elif ( "assigner" == param.type )
    value[3] = "assigner";
  elif ( 1 == sm_state.Final )
    value[3] = "terminal";
  else
    // check for any creation transition destined to this state
    select any sm_crtxn related by sm_state->SM_TXN[R506]->SM_CRTXN[R507];
    if ( not_empty sm_crtxn )
      value[3] = "creation";
    end if;
  end if;

  out::populate( element:"state", value:value );

  // MASL states declare their parameter signatures.
  // Traverse to any event transitioning to this state and use its parameters.
  select any sm_evtdi related by sm_state->SM_TXN[R506]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532];
  if ( empty sm_evtdi )	// if there are no state to state transitions to this state, it may be a creation
  						// state. Check the path to an event through a creation transition
    select any sm_evtdi related by sm_state->SM_TXN[R506]->SM_CRTXN[R507]->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525]->SM_EVTDI[R532];
    if ( empty sm_evtdi )
      select any sm_evtdi related by sm_state->SM_TXN[R506]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]->SM_EVTDI[R532];
    end if;
  end if;
  // Get first parameter.
  first_sm_evtdi = sm_evtdi;
  while ( not_empty sm_evtdi )
    first_sm_evtdi = sm_evtdi;
    select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
  end while;
  ::parameterSM_EVTDI2parameter( sm_evtdi:first_sm_evtdi );
  
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  // Populate the action langauge body.
  ::body2code_block( name:"", text:STRING::unescapetics(s:sm_act.Action_Semantics_internal) );
  
  // Populate pragmas
  ::mark2pragma( markable:"Action", pathkey: ::class_get_path( o_obj:o_obj, child:"InstanceStateMachine::" + sm_state.Name + "::State Action" ) );

  // output the description
  ::Descrip2description( Descrip:sm_act.Descrip );
  
  if ( "assigner" == param.type )
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Class State Machine::" + sm_state.Name ) );
  else
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Instance State Machine::" + sm_state.Name ) );
  end if;

  out::populate( element:"state", value:emptyvalue );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("39e07600-0fc3-4419-bea9-f719b03957e9",
	"b22bbb4b-d763-4757-840e-44c5ac1216bd",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"ab128079-dc46-44b1-a1df-f1438a95a38f",
	'');
INSERT INTO S_SPARM
	VALUES ("b4d96123-4ced-4577-9028-1ae0b33e681d",
	"b22bbb4b-d763-4757-840e-44c5ac1216bd",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"39e07600-0fc3-4419-bea9-f719b03957e9",
	'');
INSERT INTO S_SPARM
	VALUES ("ab128079-dc46-44b1-a1df-f1438a95a38f",
	"b22bbb4b-d763-4757-840e-44c5ac1216bd",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("b22bbb4b-d763-4757-840e-44c5ac1216bd",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("45112864-29c1-4db8-9cd5-3121f843a9ff",
	"00000000-0000-0000-0000-000000000000",
	'parameterSM_EVTDI2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

sm_evtdi = param.sm_evtdi;
if ( not_empty sm_evtdi )
  value[0] = sm_evtdi.Name;
  value[1] = "in";
  out::populate( element:"parameter", value:value );
  select one s_dt related by sm_evtdi->S_DT[R524];
  value[0] = s_dt.Name;
  value[1] = "";
  out::populate( element:"typeref", value:value );
  out::populate( element:"typeref", value:emptyvalue );
  select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''precedes''];
  ::parameterSM_EVTDI2parameter( sm_evtdi:sm_evtdi );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("3cc94496-ce2a-4ae7-a208-d9eb28187713",
	"45112864-29c1-4db8-9cd5-3121f843a9ff",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO PE_PE
	VALUES ("45112864-29c1-4db8-9cd5-3121f843a9ff",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4202b26a-3a0c-4d52-93bc-ac44e489e824",
	"00000000-0000-0000-0000-000000000000",
	'associative2associative',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
r_assoc = param.r_assoc;
select one r_aone related by r_assoc->R_AONE[R209];
select one one_o_obj related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 
select one r_aoth related by r_assoc->R_AOTH[R210];
select one oth_o_obj related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 
select one r_assr related by r_assoc->R_ASSR[R211];
select one ass_o_obj related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]; 

onename = one_o_obj.Name;
othname = oth_o_obj.Name;
onephrase = T::underscore( s:r_aone.Txt_Phrs );
othphrase = T::underscore( s:r_aoth.Txt_Phrs );
onecond = "conditionally";
othcond = "conditionally";
onemult = "many";
othmult = "many";
if ( 0 == r_aone.Cond )
  onecond = "unconditionally";
end if;
if ( 0 == r_aoth.Cond )
  othcond = "unconditionally";
end if;
if ( 0 == r_aone.Mult )
  onemult = "one";
end if;
if ( 0 == r_aoth.Mult )
  othmult = "one";
end if;

if ( ( "" == onephrase ) or ( "" == othphrase ) )
  TRACE::log( flavor:"failure", id:11, message:"no role phrase for:  " + onename + " to " + othname );
end if;

value[0] = c_c.Name;
value[1] = onename;
value[2] = othphrase;
value[3] = othcond;
value[4] = othmult;
value[5] = c_c.Name;
value[6] = othname;
out::populate( element:"participation", value:value );

value[0] = c_c.Name;
value[1] = othname;
value[2] = onephrase;
value[3] = onecond;
value[4] = onemult;
value[5] = c_c.Name;
value[6] = onename;
out::populate( element:"participation", value:value );

out::populate( element:"participation", value:emptyvalue );

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("82f62d53-ef7e-4045-a8b7-e0fd0eeceec7",
	"4202b26a-3a0c-4d52-93bc-ac44e489e824",
	'r_assoc',
	"7f02c6dd-ea5d-4892-801e-a1515764350f",
	0,
	'',
	"aee17374-71d3-47b6-b6f6-e063904f4a3c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7f02c6dd-ea5d-4892-801e-a1515764350f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Linked Association>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("aee17374-71d3-47b6-b6f6-e063904f4a3c",
	"4202b26a-3a0c-4d52-93bc-ac44e489e824",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("4202b26a-3a0c-4d52-93bc-ac44e489e824",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	"00000000-0000-0000-0000-000000000000",
	'subsuper2subsuper',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
r_subsup = param.r_subsup;
select one o_obj related by r_subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 

value[0] = "";	// c_c.Name;
value[1] = o_obj.Name;
value[2] = "";	// "is_a";
value[3] = "";	// "unconditionally";
value[4] = "";	// "one";
value[5] = "";	// c_c.Name;
value[6] = "";
out::populate( element:"participation", value:value );

value[6] = o_obj.Name;
select many o_objs related by r_subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]; 
for each o_obj in o_objs
  value[1] = o_obj.Name;
  out::populate( element:"participation", value:value );
end for;

out::populate( element:"participation", value:emptyvalue );

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("cf4ea895-58ef-476c-837b-8dfa3a918c5a",
	"470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	'r_subsup',
	"8f3b0ab8-e566-4e03-9159-7047140c04a7",
	0,
	'',
	"91396840-1014-44dd-9a98-a0b61d9ce38c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8f3b0ab8-e566-4e03-9159-7047140c04a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Subtype Supertype Association>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("91396840-1014-44dd-9a98-a0b61d9ce38c",
	"470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	"00000000-0000-0000-0000-000000000000",
	'classop2objectop',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
o_obj = param.o_obj;
value[0] = c_c.Name;
value[1] = o_obj.Name;
select many o_tfrs related by o_obj->O_TFR[R115];
for each o_tfr in o_tfrs

  value[2] = "public"; // All class operations are public
  value[3] = o_tfr.Name;
  value[4] = "";
  if ( Scope::Instance == o_tfr.Instance_Based )
    value[4] = "instance";
  end if;
  value[5] = "";
  
  // check for deferral -- if there is no action language or the dialect is none and subtypes have an operation with matching signature
  deferred = false;
  if ( "" == o_tfr.Action_Semantics_internal or ActionDialect::none == o_tfr.Dialect )
    // select all supsuper relationships of which o_tfr belongs to the supertype
    select many subsuper_rels related by o_tfr->O_OBJ[R115]->R_OIR[R201]->R_RTO[R203]->R_SUPER[R204]->R_SUBSUP[R212]->R_REL[R206];
    for each subsuper_rel in subsuper_rels
      select many subtypes related by subsuper_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->O_OBJ[R201];
      i = 0;
      for each subtype in subtypes // check all the operations of each subtype
        select many sub_o_tfrs related by subtype->O_TFR[R115];
        for each sub_o_tfr in sub_o_tfrs
          if ( ::operation_getsignature( flavor:1, o_tfr:o_tfr ) == ::operation_getsignature( flavor:1, o_tfr:sub_o_tfr ) )
            i = i + 1; // if the subtype has a matching operation, add it to the count
            break;
          end if;
        end for;
      end for;
      if ( i == cardinality subtypes ) // every subtype has a matching operation (this is the deferral relationship)
        value[5] = "R" + STRING::itoa( i:subsuper_rel.Numb );  // itoa to form relationship name
        deferred = true;
        break;
      end if;
    end for;
  end if;

  // Get the first parameter.
  select any o_tparm related by o_tfr->O_TPARM[R117];
  first_o_tparm = o_tparm;
  while ( not_empty o_tparm )
    first_o_tparm = o_tparm;
    select one o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
  end while;
  
  out::populate( element:"operation", value:value );
  ::parameterO_TPARM2parameter( o_tparm:first_o_tparm );
  // find return type if exists
  select one s_dt related by o_tfr->S_DT[R116];
  if ( "void" != s_dt.Name )
    // Do not send a void typeref.  No typeref equals void in MASL.
    value[0] = s_dt.Name;
    out::populate( element:"typeref", value:value );
    out::populate( element:"typeref", value:emptyvalue );
  end if;
  
  // Populate the action langauge body.
  if ( not deferred )	// do not populate a codeblock if this is a deferred operation
    ::body2code_block( name:"", text:STRING::unescapetics(s:o_tfr.Action_Semantics_internal) );
  end if;
  
  // Populate pragmas
  ::mark2pragma( markable:"Operation", pathkey: ::class_get_path( o_obj:o_obj, child: ::operation_getsignature( flavor:1, o_tfr:o_tfr ) ) );

  // output the description
  ::Descrip2description( Descrip:o_tfr.Descrip );
  
  out::populate( element:"operation", value:emptyvalue );
  
end for;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("b20d9889-4d3c-4f25-a8db-c0753f2d6cac",
	"32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"693ec31b-49ac-47ed-811a-066443a909ce",
	'');
INSERT INTO S_SPARM
	VALUES ("693ec31b-49ac-47ed-811a-066443a909ce",
	"32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	"00000000-0000-0000-0000-000000000000",
	'parameterO_TPARM2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_tparm = param.o_tparm;
if ( not_empty o_tparm )
  value[0] = o_tparm.Name;
  if ( 0 == o_tparm.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by o_tparm->S_DT[R118];
  value[0] = s_dt.Name;
  value[1] = "";
  out::populate( element:"typeref", value:value );
  out::populate( element:"typeref", value:emptyvalue );
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
  ::parameterO_TPARM2parameter( o_tparm:o_tparm );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("79a8a289-1d1d-4dd0-8a5c-769e1ea19030",
	"1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9feb3491-f835-4302-9628-50c776b209ed",
	"00000000-0000-0000-0000-000000000000",
	'body2code_block',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

select any model from instances of model where ( selected.name == "maslout" );
if ( empty model or ( not_empty model and "true" == model.getoption( name:"outputcodeblocks" ) ) )

  //value[0] = param.name + ".masl";
  value[0] = param.text;
  out::populate( element:"codeblock", value:value );
  out::populate( element:"codeblock", value:emptyvalue );

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("8dd08552-fe99-4071-95f5-32ada1023ceb",
	"9feb3491-f835-4302-9628-50c776b209ed",
	'text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"66dfda05-05dc-4065-bbdc-476aa9f06535",
	'');
INSERT INTO S_SPARM
	VALUES ("66dfda05-05dc-4065-bbdc-476aa9f06535",
	"9feb3491-f835-4302-9628-50c776b209ed",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("9feb3491-f835-4302-9628-50c776b209ed",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2f459c99-3c8c-4b98-8898-5661cf9e0fbe",
	"00000000-0000-0000-0000-000000000000",
	'class2objectdeclaration',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
select many o_objs related by c_c->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->O_OBJ[R8001];
for each o_obj in o_objs
  value[0] = o_obj.Name;
  out::populate( element:"object", value:value );
  // Note:  No marking occurs on the declaration, even though the grammar allows it.
  out::populate( element:"object", value:emptyvalue );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e7e87814-1a70-4e6e-a9fd-7725a64e6126",
	"2f459c99-3c8c-4b98-8898-5661cf9e0fbe",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("2f459c99-3c8c-4b98-8898-5661cf9e0fbe",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("13a97136-92e4-4982-967e-3a8919a4ecbf",
	"00000000-0000-0000-0000-000000000000",
	'Descrip2description',
	'',
	'value[7]=""; value[6]=""; value[5]=""; value[4]=""; value[3]=""; value[2]=""; value[1]=""; value[0]="";
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

// output the description
if ( "" != STRING::trim( s:param.Descrip ) )
  value[0] = STRING::unescapetics(s:param.Descrip);
  out::populate( element:"description", value:value );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("f2aa1161-9f0e-499c-8a7d-df804ac3f56a",
	"13a97136-92e4-4982-967e-3a8919a4ecbf",
	'Descrip',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("13a97136-92e4-4982-967e-3a8919a4ecbf",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	"00000000-0000-0000-0000-000000000000",
	'function_getsignature',
	'',
	'/**
 *  Return a string representation of this functions signature
 *  with the specified flavor
 *  0 = named parameters
 *  1 = positional parameters
 *  named signature = return_type function(param1:type, param2:type, param3:type)
 *  parameters for the named flavor are sorted alphanumerically
 *  positional signature = return_type function(param1_type, param2_type, param3_type)
 */
 
s_sync = param.s_sync;
 
signature = "";

// Get return type
select one returntype related by s_sync->S_DT[R25];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + s_sync.Name;

// Get parameters

if ( 1 == param.flavor )

  // Get the first parameter.
  select any parameter related by s_sync->S_SPARM[R24];
  first_param = parameter;
  while ( not_empty parameter )
	first_param = parameter;
	select one parameter related by parameter->S_SPARM[R54.''succeeds''];
  end while;

  if( not_empty first_param )
	signature = signature + "(";
  end if;
  separator = "";
  parameter = first_param;
  while ( not_empty parameter )
	select one type related by parameter->S_DT[R26];
	signature = signature + separator + type.Name;
	separator = " ";
	select one parameter related by parameter->S_SPARM[R54.''precedes''];
  end while;
  if( not_empty first_param )
	signature = signature + ")";
  end if;

elif ( 0 == param.flavor )

  // get the parameters in sorted order
  separator = "";
  select many parameters related by s_sync->S_SPARM[R24];
  num_params = cardinality parameters; 
  if ( num_params > 0 )
	signature = signature + "(";
  end if;

  // the following time complexity is n^2
  count = 0;
  select any last_param from instances of S_SPARM where false;
  select any curr_param from instances of S_SPARM where false;
  while ( count < num_params )
    for each parameter in parameters
      if ( ( empty curr_param and empty last_param )
           or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
           or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
           or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
        curr_param = parameter;
      end if;
    end for;
    
    select one type related by curr_param->S_DT[R26];
    signature = signature + separator + curr_param.Name + ":" + type.Name;
    separator = " ";

    last_param = curr_param;
    select any curr_param from instances of S_SPARM where false;
    count = count + 1;
  end while;

  if ( num_params > 0 )
	signature = signature + ")";
  end if;
  
end if;

return signature;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("64bdae58-a63d-4347-9a1f-1157732b8fdb",
	"9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("113b1990-9cd4-45f5-ae9b-33c37ec738d1",
	"9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"64bdae58-a63d-4347-9a1f-1157732b8fdb",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("97479412-7ded-48c7-8a35-887be07c15e4",
	"00000000-0000-0000-0000-000000000000",
	'message_getsignature',
	'',
	'c_ep = param.c_ep;

select one c_io related by c_ep->C_IO[R4004];
if ( not_empty c_io )
  /**
   *  Return a string representation of this operations signature
   *  with the specified flavor
   *  0 = named parameters
   *  1 = positional parameters
   *  named signature = return_type operation(param1:type, param2:type, param3:type)
   *  parameters for the named flavor are sorted alphanumerically
   *  positional signature = return_type operation(param1_type, param2_type, param3_type)
   */
   
  signature = "";

  // Get return type
  select one returntype related by c_io->S_DT[R4008];
  signature = signature + returntype.Name + " ";
   
  // Get name
  signature = signature + c_io.Name;

  // Get parameters

  if ( 1 == param.flavor )

	// Get the first parameter.
	select any parameter related by c_io->C_EP[R4004]->C_PP[R4006];
	first_param = parameter;
	while ( not_empty parameter )
	  first_param = parameter;
	  select one parameter related by parameter->C_PP[R4021.''succeeds''];
	end while;

	if( not_empty first_param )
	  signature = signature + "(";
	end if;
	separator = "";
	parameter = first_param;
	while ( not_empty parameter )
	  select one type related by parameter->S_DT[R4007];
	  signature = signature + separator + type.Name;
	  separator = " ";
	  select one parameter related by parameter->C_PP[R4021.''precedes''];
	end while;
	if( not_empty first_param )
	  signature = signature + ")";
	end if;

  elif ( 0 == param.flavor )

	// get the parameters in sorted order
	separator = "";
	select many parameters related by c_io->C_EP[R4004]->C_PP[R4006];
	num_params = cardinality parameters; 
	if ( num_params > 0 )
	  signature = signature + "(";
	end if;

	// the following time complexity is n^2
	count = 0;
	select any last_param from instances of C_PP where false;
	select any curr_param from instances of C_PP where false;
	while ( count < num_params )
	  for each parameter in parameters
		if ( ( empty curr_param and empty last_param )
			 or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
			 or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
			 or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
		  curr_param = parameter;
		end if;
	  end for;
	  
	  select one type related by curr_param->S_DT[R4007];
	  signature = signature + separator + curr_param.Name + ":" + type.Name;
	  separator = ", ";

	  last_param = curr_param;
	  select any curr_param from instances of C_PP where false;
	  count = count + 1;
	end while;

	if ( num_params > 0 )
	  signature = signature + ")";
	end if;
	
  end if;

  return signature;
else
  select one c_as related by c_ep->C_AS[R4004];
  /**
   *  Return a string representation of this signals signature
   *  with the specified flavor
   *  0 = named parameters
   *  1 = positional parameters
   *  named signature = signal(param1:type, param2:type, param3:type)
   *  parameters for the named flavor are sorted alphanumerically
   *  positional signature = signal(param1_type, param2_type, param3_type)
   */
   
  signature = "";

  // Get name
  signature = signature + c_as.Name;

  // Get parameters

  if ( 1 == param.flavor )

	// Get the first parameter.
	select any parameter related by c_as->C_EP[R4004]->C_PP[R4006];
	first_param = parameter;
	while ( not_empty parameter )
	  first_param = parameter;
	  select one parameter related by parameter->C_PP[R4021.''succeeds''];
	end while;

	if( not_empty first_param )
	  signature = signature + "(";
	end if;
	separator = "";
	parameter = first_param;
	while ( not_empty parameter )
	  select one type related by parameter->S_DT[R4007];
	  signature = signature + separator + type.Name;
	  separator = ", ";
	  select one parameter related by parameter->C_PP[R4021.''precedes''];
	end while;
	if( not_empty first_param )
	  signature = signature + ")";
	end if;

  elif ( 0 == param.flavor )

	// get the parameters in sorted order
	separator = "";
	select many parameters related by c_as->C_EP[R4004]->C_PP[R4006];
	num_params = cardinality parameters; 
	if ( num_params > 0 )
	  signature = signature + "(";
	end if;

	// the following time complexity is n^2
	count = 0;
	select any last_param from instances of C_PP where false;
	select any curr_param from instances of C_PP where false;
	while ( count < num_params )
	  for each parameter in parameters
		if ( ( empty curr_param and empty last_param )
			 or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
			 or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
			 or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
		  curr_param = parameter;
		end if;
	  end for;
	  
	  select one type related by curr_param->S_DT[R4007];
	  signature = signature + separator + curr_param.Name + ":" + type.Name;
	  separator = ", ";

	  last_param = curr_param;
	  select any curr_param from instances of C_PP where false;
	  count = count + 1;
	end while;

	if ( num_params > 0 )
	  signature = signature + ")";
	end if;
	
  end if;

  return signature;
end if;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("70ae1d69-d2bf-4e80-84f5-ab2c1c7c9814",
	"97479412-7ded-48c7-8a35-887be07c15e4",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("9510c62c-c3b3-4a07-8e60-b8a3e0e6dac1",
	"97479412-7ded-48c7-8a35-887be07c15e4",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"70ae1d69-d2bf-4e80-84f5-ab2c1c7c9814",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("97479412-7ded-48c7-8a35-887be07c15e4",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	"00000000-0000-0000-0000-000000000000",
	'operation_getsignature',
	'',
	'/**
 *  Return a string representation of this operations signature
 *  with the specified flavor
 *  0 = named parameters
 *  1 = positional parameters
 *  named signature = return_type operation(param1:type, param2:type, param3:type)
 *  parameters for the named flavor are sorted alphanumerically
 *  positional signature = return_type operation(param1_type, param2_type, param3_type)
 */
o_tfr = param.o_tfr;
 
signature = "";

// Get return type
select one returntype related by o_tfr->S_DT[R116];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + o_tfr.Name;

// Get parameters

if ( 1 == param.flavor )

  // Get the first parameter.
  select any parameter related by o_tfr->O_TPARM[R117];
  first_param = parameter;
  while ( not_empty parameter )
	first_param = parameter;
	select one parameter related by parameter->O_TPARM[R124.''succeeds''];
  end while;

  if( not_empty first_param )
	signature = signature + "(";
  end if;
  separator = "";
  parameter = first_param;
  while ( not_empty parameter )
	select one type related by parameter->S_DT[R118];
	signature = signature + separator + type.Name;
	separator = ", ";
	select one parameter related by parameter->O_TPARM[R124.''precedes''];
  end while;
  if( not_empty first_param )
	signature = signature + ")";
  end if;

elif ( 0 == param.flavor )

  // get the parameters in sorted order
  separator = "";
  select many parameters related by o_tfr->O_TPARM[R117];
  num_params = cardinality parameters; 
  if ( num_params > 0 )
	signature = signature + "(";
  end if;

  // the following time complexity is n^2
  count = 0;
  select any last_param from instances of O_TPARM where false;
  select any curr_param from instances of O_TPARM where false;
  while ( count < num_params )
    for each parameter in parameters
      if ( ( empty curr_param and empty last_param )
           or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
           or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
           or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
        curr_param = parameter;
      end if;
    end for;
    
    select one type related by curr_param->S_DT[R118];
    signature = signature + separator + curr_param.Name + ":" + type.Name;
    separator = ", ";

    last_param = curr_param;
    select any curr_param from instances of O_TPARM where false;
    count = count + 1;
  end while;

  if ( num_params > 0 )
	signature = signature + ")";
  end if;
  
end if;

return signature;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("561b683a-9821-4ef9-b121-5aae212d3c53",
	"e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("42219095-be3f-434f-9522-0de0ede86b72",
	"e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"561b683a-9821-4ef9-b121-5aae212d3c53",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bef2c4c8-46d5-4c5e-b08c-26e39f7b0a3c",
	"00000000-0000-0000-0000-000000000000",
	'exception2exception',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";
c_c = param.c_c;

// Exceptions in packages inside the component are considered private.
select many s_exps related by c_c->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_EXP[R8001];
for each s_exp in s_exps
  value[0] = s_exp.Name;
  value[1] = "private";
  out::populate( element:"exception", value:value );
  select one ep_pkg related by s_exp->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Exception", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:s_exp.Name ) );
  out::populate( element:"exception", value:emptyvalue );
end for;

// Exceptions in packages directly off of the system are considered public.
select many ep_pkgs related by c_c->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1401] where ( selected.Name != "types" );
select many s_exps related by ep_pkgs->PE_PE[R8000]->S_EXP[R8001];
for each s_exp in s_exps
  value[0] = s_exp.Name;
  value[1] = "public";
  out::populate( element:"exception", value:value );
  select one ep_pkg related by s_exp->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Exception", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:s_exp.Name ) );
  out::populate( element:"exception", value:emptyvalue );
end for;

// Exceptions in subpackages of the system packages are also considered public
select many sub_pkgs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001];
while ( not_empty sub_pkgs )
  select many s_exps related by sub_pkgs->PE_PE[R8000]->S_EXP[R8001];
  for each s_exp in s_exps
    value[0] = s_exp.Name;
    value[1] = "public";
    out::populate( element:"exception", value:value );
    select one ep_pkg related by s_exp->PE_PE[R8001]->EP_PKG[R8000];
    ::mark2pragma( markable:"Exception", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:s_exp.Name ) );
    out::populate( element:"exception", value:emptyvalue );
  end for;
  select many sub_pkgs related by sub_pkgs->PE_PE[R8000]->EP_PKG[R8001];
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("308fb1dc-110d-445b-a5de-a7d62bff457d",
	"bef2c4c8-46d5-4c5e-b08c-26e39f7b0a3c",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("bef2c4c8-46d5-4c5e-b08c-26e39f7b0a3c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1d772117-8637-4071-8966-b5fffae70670",
	"00000000-0000-0000-0000-000000000000",
	'remove_kl',
	'',
	'string = param.s;

start_index = STRING::indexof( haystack:string, needle:"pragma key_letter" );
while ( -1 != start_index )
  substr_begin = STRING::substr( s:string, begin:0, end:start_index );
  temp_str = STRING::substr( s:string, begin:start_index, end:-1 );
  end_index = STRING::indexof( haystack:temp_str, needle:";" );
  if ( -1 != end_index )
    substr_end = STRING::substr( s:temp_str, begin:end_index+1, end:-1 );
    string = substr_begin + substr_end;
    start_index = STRING::indexof( haystack:string, needle:"pragma key_letter" );
  else
    start_index = -1;
  end if;
end while;

return string;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("de5a1558-1109-424e-9d38-e853780dbfea",
	"1d772117-8637-4071-8966-b5fffae70670",
	's',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("1d772117-8637-4071-8966-b5fffae70670",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4f7faf8b-f0da-4aae-80e2-2018ff927926",
	"00000000-0000-0000-0000-000000000000",
	'mark2pragma',
	'',
	'// Look up the mark and convert it to a pragma.

value[7]=""; value[6]=""; value[5]=""; value[4]=""; value[3]=""; value[2]=""; value[1]=""; value[0]="";
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

select any markable from instances of Markable where ( selected.name == param.markable );
if ( not_empty markable ) // CDS - this protecting if statement can go away after mcmc is built again
select many marks related by markable->Mark[R2821] where ( selected.path == param.pathkey );
for each mark in marks
  
  value[0] = mark.feature_name;
  value[1] = "";
  out::populate( element:"pragma", value:value );

  value[0] = mark.value;
  out::populate( element:"pragmaitem", value:value );
  out::populate( element:"pragmaitem", value:emptyvalue );

  out::populate( element:"pragma", value:emptyvalue );

end for;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("568d603f-636d-4311-910f-ef57c6a92bcb",
	"4f7faf8b-f0da-4aae-80e2-2018ff927926",
	'pathkey',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"38afae16-9fdc-48bc-852d-4bbe7e60127d",
	'');
INSERT INTO S_SPARM
	VALUES ("38afae16-9fdc-48bc-852d-4bbe7e60127d",
	"4f7faf8b-f0da-4aae-80e2-2018ff927926",
	'markable',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("4f7faf8b-f0da-4aae-80e2-2018ff927926",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("12b0e811-e469-45bb-93a9-70c47457f5d8",
	"00000000-0000-0000-0000-000000000000",
	'load_marking_data',
	'',
	'/*
Load features and markable elements from the features.mark marking file.
Load marks from application.mark in the gen/ folder.
*/
select any model from instances of model where ( selected.name == "maslout" );
if ( not_empty model )
  i = 0; values[7] = "";
  while ( i < 8 )
    values[i] = "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ";
    i = i + 1;
  end while;
  TRACE::log( flavor:"info", id:103, message:"Loading marking data." );
  Feature::load( filename:model.getoption( name:"projectroot" ) + "/gen/features.mark", values:values );
  Mark::load( filename: model.getoption( name:"projectroot" ) + "/gen/application.mark", values:values );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("12b0e811-e469-45bb-93a9-70c47457f5d8",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	1,
	"00000000-0000-0000-0000-000000000000",
	"22a3ee25-8b8c-4f5d-b9eb-0420268865dc",
	7);
INSERT INTO C_C_PROXY
	VALUES ("22a3ee25-8b8c-4f5d-b9eb-0420268865dc",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	'xtuml2masl',
	'',
	0,
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'../xtuml2masl.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("53107551-b0b9-4155-a13f-41b410f63a54",
	'maslout',
	1,
	'../../../maslout.xtuml');
