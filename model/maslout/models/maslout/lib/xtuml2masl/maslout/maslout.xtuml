-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	"53107551-b0b9-4155-a13f-41b410f63a54",
	'maslout',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("77fe7d4d-51d6-4276-af06-63cebf5e0482",
	112,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'4.1.17',
	'maslout::lib::xtuml2masl::maslout');
INSERT INTO DIM_DIA
	VALUES ("77fe7d4d-51d6-4276-af06-63cebf5e0482",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	"00000000-0000-0000-0000-000000000000",
	'masl_domain',
	'',
	'TRACE::log( flavor:"info", id:103, message:"Starting domain." );

domain = param.domain;

// Query and Populate
// Query the xtUML meta-model and populate the MASL meta-model.

select many c_cs from instances of C_C where ( false );
if ( ( "" == domain ) or ( "*" == domain ) )
  select many c_cs from instances of C_C;
else
  select many c_cs from instances of C_C where ( ( selected.Name == domain ) or ( selected.Key_Lett == domain ) );
end if;
if ( empty c_cs )
  TRACE::log( flavor:"failure", id:1, message:"ERROR:  Component/domain not found in model:  " + domain );
else
  ::component2domain( c_cs:c_cs, project:false, kl:param.kl );
  for each c_c in c_cs
    //gen::render( element:"domain", name:c_c.Name );
  end for;
end if;

TRACE::log( flavor:"info", id:104, message:"Done." );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9c8d9c3a-c0a1-4d32-81e0-b96654392cc0",
	"0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("865858ba-af92-4a81-a049-10fec802f1e0",
	"0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"9c8d9c3a-c0a1-4d32-81e0-b96654392cc0",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("0c6d00ab-17d3-41f1-8a7a-cb0fdfc9c315",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	"00000000-0000-0000-0000-000000000000",
	'masl_project',
	'',
	'TRACE::log( flavor:"info", id:101, message:"Starting Project" );

project = param.project;
// Query and Populate
// Query the xtUML meta-model and populate the MASL meta-model.

select many d_depls from instances of D_DEPL where ( selected.Name == project );
if ( not_empty d_depls )
  ::depl2project( d_depls:d_depls );
else
  select many ep_pkgs from instances of EP_PKG where ( false );
  if ( ( "" == project ) or ( "*" == project ) )
    // CDS - temporary for marking the project
    select many ep_pkgs from instances of EP_PKG where ( selected.Descrip == project );
  else
    select many ep_pkgs from instances of EP_PKG where ( selected.Name == project );
  end if;
  if ( not_empty ep_pkgs )
    ::package2project( ep_pkgs:ep_pkgs, kl:param.kl );
  else
    TRACE::log( flavor:"failure", id:1, message:"ERROR:  project package was not found:" + project );
  end if;
end if;

TRACE::log( flavor:"info", id:102, message:"Done" );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("df408732-1e8c-4be3-bbf2-6c34377e1afe",
	"9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	'project',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("16407558-fde5-45f4-8d1c-43d813bf8d28",
	"9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"df408732-1e8c-4be3-bbf2-6c34377e1afe",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("9a5ac824-671b-4cb6-9d93-37b700ffd92c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("84687e5f-e288-4907-9432-62372e5f265f",
	"00000000-0000-0000-0000-000000000000",
	'component2domain',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_cs = param.c_cs;
for each c_c in c_cs;
  value[0] = c_c.Name;
  value[1] = c_c.Key_Lett;
  out::populate( element:"domain", value:value );
  
  if ( param.project )
    ::port2terminator( c_c:c_c, project:param.project, kl:param.kl );
  else
    ::class2objectdeclaration( c_c:c_c );
    ::types2types( c_c:c_c );
    ::exception2exception( c_c:c_c );
    ::function2routine( c_c:c_c );
    ::port2terminator( c_c:c_c, project:param.project, kl:param.kl );
    ::association2relationship( c_c:c_c );
    ::class2object( c_c:c_c, kl:param.kl );
  end if;
  
  if ( param.project )
    // Populate pragmas
    select any cl_ic related by c_c->CL_IC[R4201];
    if ( not_empty cl_ic )
      select one ep_pkg related by cl_ic->PE_PE[R8001]->EP_PKG[R8000];
      ::mark2pragma( markable:"Component Reference", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:cl_ic.Name ) );
    end if;

    // output the description
    ::Descrip2description( Descrip:cl_ic.Descrip );
  else
    // Populate pragmas
    ::mark2pragma( markable:"Component", pathkey: ::component_get_path( c_c:c_c, child:"" ) );

    // output the description
    ::Descrip2description( Descrip:c_c.Descrip );
  end if;
  
  out::populate( element:"domain", value:emptyvalue );
end for;
      ',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("cf4db11c-a368-4494-9f14-382c45cdc747",
	"84687e5f-e288-4907-9432-62372e5f265f",
	'c_cs',
	"5228eeb5-5532-4f4d-8d56-d20e0a1a6189",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5228eeb5-5532-4f4d-8d56-d20e0a1a6189",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Component>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("75a907fb-78de-49b0-b748-176ee43e0b29",
	"84687e5f-e288-4907-9432-62372e5f265f",
	'project',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"cf4db11c-a368-4494-9f14-382c45cdc747",
	'');
INSERT INTO S_SPARM
	VALUES ("b4e0ed8b-05be-4594-a8cb-8fd66101c957",
	"84687e5f-e288-4907-9432-62372e5f265f",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"75a907fb-78de-49b0-b748-176ee43e0b29",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("84687e5f-e288-4907-9432-62372e5f265f",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bbd421d2-e67f-41ea-be98-398a6baf075d",
	"00000000-0000-0000-0000-000000000000",
	'package2project',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

ep_pkgs = param.ep_pkgs;
for each ep_pkg in ep_pkgs

  select any project_c_c related by ep_pkg->PE_PE[R8000]->C_C[R8001];
  if ( not_empty project_c_c )

    value[0] = ep_pkg.Name;
    out::populate( element:"project", value:value );

    select many referred_c_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201];
    ::component2domain( c_cs:referred_c_cs, project:true, kl:param.kl );

    // Populate pragmas
    ::mark2pragma( markable:"Component", pathkey: ::component_get_path( c_c:project_c_c, child:"" ) );

    // output the description
    ::Descrip2description( Descrip:project_c_c.Descrip );

    // end project
    out::populate( element:"project", value:emptyvalue );
  
  end if;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e1434ed1-bb84-419d-aa6a-b3a6dcaae855",
	"bbd421d2-e67f-41ea-be98-398a6baf075d",
	'ep_pkgs',
	"2dfbba0c-72a2-4c76-8486-8613e7ea4b99",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2dfbba0c-72a2-4c76-8486-8613e7ea4b99",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Package>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO S_SPARM
	VALUES ("d0cb0012-0c1e-466f-b03e-ee5aa15dc4ca",
	"bbd421d2-e67f-41ea-be98-398a6baf075d",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e1434ed1-bb84-419d-aa6a-b3a6dcaae855",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("bbd421d2-e67f-41ea-be98-398a6baf075d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	"00000000-0000-0000-0000-000000000000",
	'port2terminator',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
// (outbound) port -> terminator
select many c_pos related by c_c->C_PO[R4010]->C_IR[R4016]->C_R[R4009]->C_IR[R4009]->C_PO[R4016];
for each c_po in c_pos
  // if we are processing a project, make sure that there is a provision. If not, this terminator was not
  // defined in the project file and should not be emitted with the project
  select any provision related by c_po->C_IR[R4016]->C_I[R4012]->C_IR[R4012]->C_P[R4009];
  if ( not param.project or ( param.project and not_empty provision ) )

    value[0] = c_po.Name;
    value[1] = c_po.Key_Lett;
    // See if there is a mark for the key_letter.
    select any markable from instances of Markable where ( selected.name == "Port" );
    pathkey = ::component_get_path( c_c:c_c, child:c_po.Name );
    select any mark related by markable->Mark[R2821] where ( ( selected.path == pathkey ) and ( selected.feature_name == "key_letter" ) );
    if ( not_empty mark )
      // Strip the double-quotes off.
      i = STRING::strlen( s:mark.value );
      value[1] = STRING::substr( s:mark.value, begin:1, end:i-1 );
    end if;
    out::populate( element:"terminator", value:value );
    ::message2routine( c_c:c_c, c_po:c_po, project:param.project );

    // Populate pragmas
    if ( param.project )
      select any c_p related by c_po->C_IR[R4016]->C_I[R4012]->C_IR[R4012]->C_P[R4009];
      if ( not_empty c_p )
        if ( not param.kl )
          c_p.Descrip = ::remove_kl( s:c_p.Descrip );
        end if;
        ::mark2pragma( markable:"Provision", pathkey: ::component_get_path( c_c:c_c, child:c_p.Name ) );

        // output the description
        ::Descrip2description( Descrip:c_p.Descrip );
      end if;
    else
      select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
      if ( not_empty c_r )
        if ( not param.kl )
          c_r.Descrip = ::remove_kl( s:c_r.Descrip );
        end if;
        ::mark2pragma( markable:"Requirement", pathkey: ::component_get_path( c_c:c_c, child:c_r.Name ) );

        // output the description
        ::Descrip2description( Descrip:c_r.Descrip );
      end if;
    end if;

    ::mark2pragma( markable:"Port", pathkey:pathkey );
    // end terminator
    out::populate( element:"terminator", value:emptyvalue );

  end if;

end for;

  
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e557817d-dd43-43a1-b7c1-a522bda54d2a",
	"3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("0df5f9f2-ee02-4900-9478-2ee36ce46c1d",
	"3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	'project',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e557817d-dd43-43a1-b7c1-a522bda54d2a",
	'');
INSERT INTO S_SPARM
	VALUES ("86f1e636-f893-4b66-9d8c-eb882fb3568f",
	"3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"0df5f9f2-ee02-4900-9478-2ee36ce46c1d",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("3ddfd9b1-d62f-4fa1-9e31-b48931032ee9",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	"00000000-0000-0000-0000-000000000000",
	'message2routine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
c_po = param.c_po;
// message -> function/service
value[0] = c_c.Name;
value[1] = "";

select many c_eps related by c_po->C_IR[R4016]->C_I[R4012]->C_EP[R4003];
for each c_ep in c_eps
    
  if ( param.project )
    select any spr_po related by c_ep->SPR_PEP[R4501]->SPR_PO[R4503];
    if ( not_empty spr_po )
      if ( ActionDialect::none == spr_po.Dialect )
        // A project can skip supplying a terminator service.  A dialect
        // of ActionDialect::none means no terminator service was provided.
        continue;
      end if;
    end if;
  end if;

  value[2] = "public"; // Outbound messages are considered public.
  value[3] = c_ep.Name;
  value[4] = STRING::itoa( i:c_ep.Numb );
  select any spr_ro related by c_ep->SPR_REP[R4500]->SPR_RO[R4502];
  if ( ( not_empty spr_ro ) and ( spr_ro.Numb != c_ep.Numb ) )
    // If the message operation number from the port is different than
    // the one in the interface, use the one from the port (12273).
    value[4] = STRING::itoa( i:spr_ro.Numb );
  end if;

  out::populate( element:"routine", value:value );
  
  select any c_pp related by c_ep->C_PP[R4006];
  first_c_pp = c_pp;
  while ( not_empty c_pp )
    first_c_pp = c_pp;
    select one c_pp related by c_pp->C_PP[R4021.''succeeds''];
  end while;
  if ( param.project )
    select any project_c_c related by c_po->C_IR[R4016]->C_I[R4012]->C_IR[R4012]->C_P[R4009]->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
    select one domain_pkg related by project_c_c->PE_PE[R8001]->EP_PKG[R8000];
    ::parameterC_PP2parameter( c_pp:first_c_pp, domain_pkg:domain_pkg );
    select one s_dt related by c_ep->C_IO[R4004]->S_DT[R4008];
    ::type2typeref( s_dt:s_dt, domain_pkg:domain_pkg );
  else
    select one domain_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
    ::parameterC_PP2parameter( c_pp:first_c_pp, domain_pkg:domain_pkg );
    select one s_dt related by c_ep->C_IO[R4004]->S_DT[R4008];
    ::type2typeref( s_dt:s_dt, domain_pkg:domain_pkg );
  end if;
  
  // Populate the action langauge body.
  select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
  if ( param.project )
    select any spr_po related by c_ep->SPR_PEP[R4501]->SPR_PO[R4503];
    ::body2code_block( name:"", text:STRING::unescapetics(s:spr_po.Action_Semantics_internal) );

    // Populate pragmas
    child = c_po.Name + "::" + c_i.Name + "::" + c_ep.Name;
    ::mark2pragma( markable:"Provided Operation", pathkey: ::component_get_path( c_c:c_c, child:child ) );

    // output the description
    ::Descrip2description( Descrip:spr_po.Descrip );
  else
    select any spr_ro related by c_ep->SPR_REP[R4500]->SPR_RO[R4502];
    ::body2code_block( name:"", text:STRING::unescapetics(s:spr_ro.Action_Semantics_internal) );

    // Populate pragmas
    child = c_po.Name + "::" + c_i.Name + "::" + c_ep.Name;
    ::mark2pragma( markable:"Required Operation", pathkey: ::component_get_path( c_c:c_c, child:child ) );

    // output the description
    ::Descrip2description( Descrip:spr_ro.Descrip );
  end if;

  out::populate( element:"routine", value:emptyvalue );
  
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("8898a959-9ae1-44df-90ff-dcc22215a9db",
	"d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"4b7d90b1-ba1a-44db-b40b-6ee2f036eea4",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("4b7d90b1-ba1a-44db-b40b-6ee2f036eea4",
	"d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("bd5f6378-3914-4e0b-98f4-b339368ec422",
	"d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	'project',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"8898a959-9ae1-44df-90ff-dcc22215a9db",
	'');
INSERT INTO PE_PE
	VALUES ("d9c8ef77-73d8-4253-978c-d7cbf7b9b520",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	"00000000-0000-0000-0000-000000000000",
	'parameterC_PP2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_pp = param.c_pp;
if ( not_empty c_pp )
  value[0] = c_pp.Name;
  if ( 0 == c_pp.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by c_pp->S_DT[R4007];
  ::type2typeref( s_dt:s_dt, domain_pkg:param.domain_pkg );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
  ::parameterC_PP2parameter( c_pp:c_pp, domain_pkg:param.domain_pkg );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("a476bde7-fb21-4a1f-b22b-46b5fe763364",
	"dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("8ce46f97-6f97-4d53-927a-6fdffa966af1",
	"dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	'domain_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"a476bde7-fb21-4a1f-b22b-46b5fe763364",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO PE_PE
	VALUES ("dce601c3-b3f2-4e01-8fbd-cb588f25eb5b",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	"00000000-0000-0000-0000-000000000000",
	'class2object',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
select many pkg_o_objs related by ep_pkgs->PE_PE[R8000]->O_OBJ[R8001];
select many pkgref_o_objs related by ep_pkgs->EP_PKGREF[R1402.''refers to'']->EP_PKG[R1402.''refers to'']->PE_PE[R8000]->O_OBJ[R8001];
o_objs = pkg_o_objs + pkgref_o_objs;
for each o_obj in o_objs
  value[0] = o_obj.Name;
  value[1] = o_obj.Key_Lett;
  value[2] = STRING::itoa( i:o_obj.Numb );
  out::populate( element:"object", value:value );
  
  // Link the attributes to each object. 
  ::attribute2attribute( c_c:c_c, o_obj:o_obj );
  
  // Set up the identifiers for this object.
  ::identifier2identifier( o_obj:o_obj );
  
  // class operations
  ::classop2objectop( c_c:c_c, o_obj:o_obj );
  
  select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
  if ( not_empty sm_sm )
    // blank type is normal
    ::state2state( o_obj:o_obj, sm_sm:sm_sm, type:"" );
    ::event2event( o_obj:o_obj, sm_sm:sm_sm, type:"" );
    ::statemachine2statemachine( o_obj:o_obj, sm_sm:sm_sm, type:"" );
  end if;
  
  select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
  if ( not_empty sm_sm )
    ::state2state( o_obj:o_obj, sm_sm:sm_sm, type:"assigner" );
    ::event2event( o_obj:o_obj, sm_sm:sm_sm, type:"assigner" );
    ::statemachine2statemachine( o_obj:o_obj, sm_sm:sm_sm, type:"assigner" );
  end if;
  
  // insert the key letters as a pragma
  if ( param.kl )
    value[0] = "key_letter";
    out::populate( element:"pragma", value:value );
    quote = STRING::quote();
    value[0] = quote + o_obj.Key_Lett + quote;
    out::populate( element:"pragmaitem", value:value );
    out::populate( element:"pragma", value:emptyvalue );
  end if;
  
  // output pragmas
  ::mark2pragma( markable:"Model Class", pathkey: ::class_get_path( o_obj:o_obj, child:"" ) );

  // output the description
  ::Descrip2description( Descrip:o_obj.Descrip );
  
  out::populate( element:"object", value:emptyvalue );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("15b7c710-66b8-4afc-8a74-5728d734391a",
	"5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a8f66f26-bfad-46a6-b434-419f388a91f8",
	"5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	'kl',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"15b7c710-66b8-4afc-8a74-5728d734391a",
	'Flag for outputting class key letters. If set to "true", key letters will be output as pragmas on the object definition
If set to "false", no pragmas will be generated for key letters');
INSERT INTO PE_PE
	VALUES ("5139df0f-0bdf-49e5-a6c0-bf87d5a4ee4d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("636cf3d3-f72d-4072-b665-cde360ef7edb",
	"00000000-0000-0000-0000-000000000000",
	'attribute2attribute',
	'',
	'/*
  Attribute (O_ATTR) -> attribute
  primary identifier (O_OIDA == 1) -> preferred
  Attribute type of unique_id (O_ATTR->S_DT) -> unique
*/
  
value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
c_c = param.c_c;
// Get first attribute.
select any o_attr related by o_obj->O_ATTR[R102];
while ( not_empty o_attr )
  select one prev_o_attr related by o_attr->O_ATTR[R103.''succeeds''];
  if ( empty prev_o_attr )
    break;
  end if;
  assign o_attr = prev_o_attr;
end while;
// Iterate through attributes in model order.
previous_attr_name = ""; // for ordering
while ( not_empty o_attr )
  select one s_dt related by o_attr->S_DT[R114];
  // if it is a referential attribute, get the datatype of the base attribute
  select one o_rattr related by o_attr->O_RATTR[R106];
  if ( not_empty o_rattr )
    select one base_o_attr related by o_rattr->O_BATTR[R113]->O_ATTR[R106];
    if ( not_empty base_o_attr )
      select one s_dt related by base_o_attr->S_DT[R114];
      if ( "unique_id" == s_dt.Name or "MASLunique" == s_dt.Name )
        // referentials referring to a "MASLunique" type should not propagate
        // "unique"-ness ot the referential
        select any s_dt from instances of S_DT where ( selected.Name == "integer" );
      end if;
    end if;
  end if;

  if ( ( "current_state" == o_attr.Name ) and ( "state<State_Model>" == s_dt.Name ) )
    // Do not populate a current_state attribute with type state<State_Model>.
  else
    // Detect an attribute with the same name as another.  This happens easily but needs to produce an error.
    select any duplicate_o_attr related by o_attr->O_OBJ[R102]->O_ATTR[R102]
      where ( selected.Name == o_attr.Name and selected.Attr_ID != o_attr.Attr_ID );
    if ( not_empty duplicate_o_attr )
      TRACE::log( flavor:"failure", id:63, message:"ERROR:  Duplicate attribute found:  " + o_obj.Name + "." + o_attr.Name );
      value[0] = o_attr.Name + "DUPLICATE";
    else
      value[0] = o_attr.Name;
    end if;
    value[1] = "";
    // See if this attribute is in the primary identifier.
    select any o_oida related by o_attr->O_OIDA[R105] where ( selected.Oid_ID == 0 );
    if ( not_empty o_oida )
      value[1] = "preferred";
    end if;
    value[2] = "";
    // See if the type of this attribute is unique_id or MASLunique.
    // ''unique'' is dropped when this is a referential attribute
    if ( "unique_id" == s_dt.Name or "MASLunique" == s_dt.Name )
      select any o_oida related by o_attr->O_OIDA[R105];
      if ( ( empty o_rattr ) or ( not_empty o_oida ) )
        // unless it is part of an identifier
        value[2] = "unique";
      end if;
    end if;
    // CDS - Coerce inst_ref<Timer>
    if ( "inst_ref<Timer>" == value[2] )
      value[2] = "inst_refTimer";
    end if;
    value[3] = previous_attr_name;
    out::populate( element:"attribute", value:value );
    value[1] = "";
    value[2] = "";
    value[3] = "";
    previous_attr_name = o_attr.Name;
  
    // The default value comes first from the attribute then from its type.
    value[0] = o_attr.DefaultValue;
    if ( "" == o_attr.DefaultValue )
      value[0] = s_dt.DefaultValue;
    end if;
    if ( "" != value[0] )
      // Do not populate expression unless we have something useful.
      out::populate( element:"expression", value:value );
    end if;
  
    // Populate the type referred to by this attribute as a type reference.
    select one domain_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
    ::type2typeref( s_dt:s_dt, domain_pkg:domain_pkg );
    
    // See if this attribute is a referential.
    select many o_refs related by o_attr->O_RATTR[R106]->O_REF[R108];
    for each o_ref in o_refs

      select one rto related by o_ref->O_RTIDA[R111]->R_RTO[R110];
      select one rel related by rto->R_OIR[R203]->R_REL[R201];
      select one rto_obj related by rto->R_OIR[R203]->O_OBJ[R201];
      select one ref_o_attr related by o_ref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105];

      value[0] = "R" + STRING::itoa( i:rel.Numb );	// relationship number
      value[1] = ""; //value[1] = c_c.Name; // domain name
      
      // see if there is a role phrase. if so, include it
      textphrase = "";
      select one r_part related by rto->R_PART[R204];
      if ( not_empty r_part )
        textphrase = r_part.Txt_Phrs;
      else
        select one r_aone related by rto->R_AONE[R204];
        if ( not_empty r_aone )
          textphrase = r_aone.Txt_Phrs;
        else
          select one r_aoth related by rto->R_AOTH[R204];
          if ( not_empty r_aoth )
            textphrase = r_aoth.Txt_Phrs;
          end if;
        end if;
      end if;
      
      if ( "" == textphrase )
        select one r_sup related by rto->R_SUPER[R204];
        if ( not_empty r_sup )	   // if this is a subsuper relationship, exclude the object name
          value[2] = "";
        else
          value[2] = rto_obj.Name; // if there is no text phrase, use the object name
        end if;
        value[3] = "";
      else
        value[2] = textphrase; // use the phrase and the object name
        value[3] = rto_obj.Name; // referred to object name object
      end if;

      value[4] = ref_o_attr.Name; // referred to attribute name
      out::populate( element:"referential", value:value );
      value[1] = "";
      value[2] = "";
      value[3] = "";
      value[4] = "";
      out::populate( element:"referential", value:emptyvalue );
    end for;
    
    // Populate pragmas
    ::mark2pragma( markable:"Attribute", pathkey: ::class_get_path( o_obj:o_obj, child:o_attr.Name ) );

    // output the description
    ::Descrip2description( Descrip:o_attr.Descrip );
  
    out::populate( element:"attribute", value:emptyvalue );
  end if;
  
  select one o_attr related by o_attr->O_ATTR[R103.''precedes''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("4488e70f-8f35-4b8b-9c0b-8f144d9acacf",
	"636cf3d3-f72d-4072-b665-cde360ef7edb",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"44cd8d5d-9f12-4f3a-b2bf-016ed0e68b7f",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("44cd8d5d-9f12-4f3a-b2bf-016ed0e68b7f",
	"636cf3d3-f72d-4072-b665-cde360ef7edb",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("636cf3d3-f72d-4072-b665-cde360ef7edb",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2f0e3a99-9a8b-44dc-9428-f75cfbd83fdd",
	"00000000-0000-0000-0000-000000000000",
	'types2types',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";
c_c = param.c_c;

// - If the UDT is based on MASLtype and there is no definition, treat as a
//   typeref and do not output it.
// - If the UDT is based on MASLtype and there is a definition, output it as a
//   type definition
// - If the UDT is not based on MASLtype, treat as a type definition and output
//   it as a typedef using the name of the underlying type (i.e. type myUDT is a
//   string)

// Data types in packages inside the component are considered private.
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
select many pkg_s_dts related by ep_pkgs->PE_PE[R8000]->S_DT[R8001];
select many pkgref_s_dts related by ep_pkgs->EP_PKGREF[R1402.''refers to'']->EP_PKG[R1402.''refers to'']->PE_PE[R8000]->S_DT[R8001];
private_s_dts = pkg_s_dts + pkgref_s_dts;

// Data types in packages and sub-packages directly off of the system are considered public.
select many public_s_dts from instances of S_DT where ( false );
select many ep_pkgs related by c_c->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1401] where ( selected.Name != "types" );
while ( not_empty ep_pkgs )
  select many pkg_s_dts related by ep_pkgs->PE_PE[R8000]->S_DT[R8001];
  public_s_dts = public_s_dts | pkg_s_dts;
  select many sub_ep_pkgs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001];
  ep_pkgs = sub_ep_pkgs; // MC-3020 weakness
end while;

// Iterate twice to loop through private and public types.
i = 0;
while ( i <= 1 )
  s_dts = private_s_dts;
  if ( 1 == i )
    s_dts = public_s_dts;
  end if;
  for each s_dt in s_dts
    ::type2type( s_dt:s_dt, i:i );
  end for;
  i = i + 1;
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("07c30bd2-62a1-4290-9717-fc84fa995641",
	"2f0e3a99-9a8b-44dc-9428-f75cfbd83fdd",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("2f0e3a99-9a8b-44dc-9428-f75cfbd83fdd",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("59846fd7-dd0d-4c7a-b24d-c8bad6617b7c",
	"00000000-0000-0000-0000-000000000000",
	'association2relationship',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
select many pkg_r_rels related by ep_pkgs->PE_PE[R8000]->R_REL[R8001];
select many pkgref_r_rels related by ep_pkgs->EP_PKGREF[R1402.''refers to'']->EP_PKG[R1402.''refers to'']->PE_PE[R8000]->R_REL[R8001];
r_rels = pkg_r_rels + pkgref_r_rels;
for each r_rel in r_rels
  value[0] = ""; value[1] = ""; value[2] = ""; value[3] = "";
  value[4] = ""; value[5] = ""; value[6] = ""; value[7] = "";
  value[0] = "R" + STRING::itoa( i:r_rel.Numb );  // itoa to form relationship name
  select one ep_pkg related by r_rel->PE_PE[R8001]->EP_PKG[R8000];
  select one r_simp related by r_rel->R_SIMP[R206];
  if ( not_empty r_simp )
    out::populate( element:"regularrel", value:value );
    ::simpleass2regularrel( c_c:c_c, r_simp:r_simp );
    ::mark2pragma( markable:"Association", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: "R" + STRING::itoa( i:r_rel.Numb ) ) );
    // output the description
    ::Descrip2description( Descrip:r_rel.Descrip );
    out::populate( element:"regularrel", value:emptyvalue );
  end if;
  
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    // Get the name of the associator.
    select one o_obj related by r_assoc->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
    value[1] = c_c.Name;
    value[2] = o_obj.Name;
    out::populate( element:"associative", value:value );
    ::associative2associative( c_c:c_c, r_assoc:r_assoc );
    out::populate( element:"associative", value:value ); // 2nd call for using
    ::mark2pragma( markable:"Association", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: "R" + STRING::itoa( i:r_rel.Numb ) ) );
    // output the description
    ::Descrip2description( Descrip:r_rel.Descrip );
    out::populate( element:"associative", value:emptyvalue );
  end if;
  
  select one r_subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty r_subsup )
    out::populate( element:"subsuper", value:value );
    ::subsuper2subsuper( c_c:c_c, r_subsup:r_subsup );
    ::mark2pragma( markable:"Association", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: "R" + STRING::itoa( i:r_rel.Numb ) ) );
    // output the description
    ::Descrip2description( Descrip:r_rel.Descrip );
    out::populate( element:"subsuper", value:emptyvalue );
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("51c46f46-bc0f-4bf0-8fe4-af7d3be1667e",
	"59846fd7-dd0d-4c7a-b24d-c8bad6617b7c",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("59846fd7-dd0d-4c7a-b24d-c8bad6617b7c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("09d28e26-8c9d-40c0-b89a-276922023942",
	"00000000-0000-0000-0000-000000000000",
	'identifier2identifier',
	'',
	'/*
  Assuming 8 or less identifier attributes.
*/
value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
// Select the non-primary identifiers.  The primary identifier will be marked as preferred.
select many o_ids related by o_obj->O_ID[R104] where ( selected.Oid_ID != 0 );
for each o_id in o_ids
  value[7] = ""; value[6] = ""; value[5] = ""; value[4] = "";
  value[3] = ""; value[2] = ""; value[1] = ""; value[0] = "";
  select many o_attrs related by o_id->O_ATTR[R105];
  if ( not_empty o_attrs )
    value[0] = "symbolic"; // non-empty string to indicate start of identifier
    out::populate( element:"identifier", value:value );
    for each o_attr in o_attrs
      value[0] = o_attr.Name;
      out::populate( element:"attribute", value:value );
      out::populate( element:"attribute", value:emptyvalue );
    end for;

    // CDS - identifiers are not actually selectable from the marking editor
    ::mark2pragma( markable:"Class Identifier", pathkey: ::class_get_path( o_obj:o_obj, child: T::s( i:o_id.Oid_ID ) ) );

    out::populate( element:"identifier", value:emptyvalue );
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("a84bec3f-93e6-496d-aa58-e382e6c4e593",
	"09d28e26-8c9d-40c0-b89a-276922023942",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("09d28e26-8c9d-40c0-b89a-276922023942",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	"00000000-0000-0000-0000-000000000000",
	'simpleass2regularrel',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
r_simp = param.r_simp;
select many r_parts related by r_simp->R_PART[R207];
name[7] = ""; phrase[7] = ""; cond[7] = ""; mult[7]= ""; toname[7] = "";
i = 0;
for each r_part in r_parts
  select one o_obj related by r_part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 
  name[i] = o_obj.Name;
  phrase[i] = T::underscore( s:r_part.Txt_Phrs );
  if ( 0 == r_part.Cond )
    cond[i] = "unconditionally";
  else
    cond[i] = "conditionally";
  end if;
  if ( 0 == r_part.Mult )
    mult[i] = "one";
  else
    mult[i] = "many";
  end if;
  toname[i] = ""; // CDS - get toname
  i = i + 1;
end for;

if ( 1 == i )
  // only one participant, go get the formalizer
  select one r_form related by r_simp->R_FORM[R208];
  select one o_obj related by r_form->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]; 
  name[1] = o_obj.Name;
  phrase[1] = T::underscore( s:r_form.Txt_Phrs );
  if ( 0 == r_form.Cond )
    cond[1] = "unconditionally";
  else
    cond[1] = "conditionally";
  end if;
  if ( 0 == r_form.Mult )
    mult[1] = "one";
  else
    mult[1] = "many";
  end if;
  toname[1] = ""; // CDS - get toname
end if;

if ( ( "" == phrase[0] ) or ( "" == phrase[1] ) )
  TRACE::log( flavor:"failure", id:12, message:"no role phrase for:  " + name[0] + " to " + name[1] );
end if;

value[0] = c_c.Name;
value[1] = name[0];
value[2] = phrase[1];
value[3] = cond[1];
value[4] = mult[1];
value[5] = c_c.Name;
value[6] = name[1];
out::populate( element:"participation", value:value );

value[0] = c_c.Name;
value[1] = name[1];
value[2] = phrase[0];
value[3] = cond[0];
value[4] = mult[0];
value[5] = c_c.Name;
value[6] = name[0];
out::populate( element:"participation", value:value );

out::populate( element:"participation", value:emptyvalue );

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("11a9addd-1ac4-4fa9-abbd-0ff170d8e031",
	"844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	'r_simp',
	"322c65da-132b-421a-a1b1-f757cb0acff7",
	0,
	'',
	"4ebc7b0a-e6f4-4dcf-aab8-955aeb9c0826",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("322c65da-132b-421a-a1b1-f757cb0acff7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Simple Association>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("4ebc7b0a-e6f4-4dcf-aab8-955aeb9c0826",
	"844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("844ea9b2-b764-49f9-b6c3-b594fc02b28e",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ca010eda-543b-4971-abfb-32b006d6d31c",
	"00000000-0000-0000-0000-000000000000",
	'function2routine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
value[0] = c_c.Name;
value[1] = "";
select many c_eps related by c_c->C_PO[R4010]->C_IR[R4016]->C_P[R4009]->C_IR[R4009]->C_I[R4012]->C_EP[R4003];
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
select many pkg_s_syncs related by ep_pkgs->PE_PE[R8000]->S_SYNC[R8001];
select many pkgref_s_syncs related by ep_pkgs->EP_PKGREF[R1402.''refers to'']->EP_PKG[R1402.''refers to'']->PE_PE[R8000]->S_SYNC[R8001];
s_syncs = pkg_s_syncs + pkgref_s_syncs;
for each s_sync in s_syncs

  value[2] = "private";
  // Find a provided port message with this same name.  If found, mark public.
  for each c_ep in c_eps
    if ( ( c_ep.Name == s_sync.Name ) and ( c_ep.Numb == s_sync.Numb ) )
      value[2] = "public";
      break;
    end if;
  end for;
  value[3] = s_sync.Name;
  value[4] = STRING::itoa( i:s_sync.Numb );
  
  // Get the first parameter.
  select any s_sparm related by s_sync->S_SPARM[R24];
  first_s_sparm = s_sparm;
  while ( not_empty s_sparm )
    first_s_sparm = s_sparm;
    select one s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
  end while;
  
  out::populate( element:"routine", value:value );
  select one domain_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
  ::parameterS_SPARM2parameter( s_sparm:first_s_sparm, domain_pkg:domain_pkg );
  // find return type if exists
  select one s_dt related by s_sync->S_DT[R25];
  ::type2typeref( s_dt:s_dt, domain_pkg:domain_pkg );
  
  if ( ( ActionDialect::masl == s_sync.Dialect ) or ( ActionDialect::asl == s_sync.Dialect ) )
    // Populate the action langauge body.
    ::body2code_block( name:"", text:STRING::unescapetics(s:s_sync.Action_Semantics_internal) );
  end if;
  
  // Populate pragmas
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Function", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: ::function_getsignature( flavor:1, s_sync:s_sync ) ) );
  if ( ( "externals" == ep_pkg.Name ) and ( ActionDialect::masl != s_sync.Dialect ) )
    // functions in externals package get a manufactured pragma for ASL
    value[0] = "external";
    value[1] = ""; value[2] = ""; value[3] = ""; value[4] = "";
    out::populate( element:"pragma", value:value );
    value[0] = STRING::itoa( i:s_sync.Numb );
    out::populate( element:"pragmaitem", value:value );
    out::populate( element:"pragmaitem", value:emptyvalue );
    out::populate( element:"pragma", value:emptyvalue );
  end if;

  // output the description
  ::Descrip2description( Descrip:s_sync.Descrip );
  
  out::populate( element:"routine", value:emptyvalue );
  
end for;
  

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("6f121837-e5ec-493f-a1f1-f42c2bc5c711",
	"ca010eda-543b-4971-abfb-32b006d6d31c",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ca010eda-543b-4971-abfb-32b006d6d31c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	"00000000-0000-0000-0000-000000000000",
	'parameterS_SPARM2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

s_sparm = param.s_sparm;
if ( not_empty s_sparm )
  value[0] = s_sparm.Name;
  if ( 0 == s_sparm.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by s_sparm->S_DT[R26];
  ::type2typeref( s_dt:s_dt, domain_pkg:param.domain_pkg );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
  ::parameterS_SPARM2parameter( s_sparm:s_sparm, domain_pkg:param.domain_pkg );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("60fb8b97-7f20-4095-b943-e08c3a8e2e31",
	"be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a01a1995-8ff8-44fe-abb1-b11213d98016",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("14cb0301-1895-4534-94b1-a5dc724415ff",
	"be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	'domain_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"60fb8b97-7f20-4095-b943-e08c3a8e2e31",
	'');
INSERT INTO PE_PE
	VALUES ("be1ccb4a-cb4a-474d-b0b2-ed38f9f68441",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("78002803-6c30-4367-95a3-30a4b7969a69",
	"00000000-0000-0000-0000-000000000000",
	'statemachine2statemachine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
sm_sm = param.sm_sm;
value[0] = param.type;

select many sm_states related by sm_sm->SM_STATE[R501];
select any sm_evt related by sm_sm->SM_EVT[R502];
// We must have at least one state and one event to have a table.
if ( ( not_empty sm_states ) and ( not_empty sm_evt ) )

out::populate( element:"transitiontable", value:value );

// only output the Non_Existent row for ISMs
if ( "assigner" != param.type )
  // Get all the transitions starting with "Non_Existent" state.
  value[0] = "Non_Existent";
  select many sm_evts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_EVT[R525];
  // also collect creation events from the supertypes
  select many supertype_isms related by sm_sm->SM_ISM[R517]->O_OBJ[R518]->R_OIR[R201]->R_RGO[R203]
                                         ->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]
                                         ->R_OIR[R203]->O_OBJ[R201]->SM_ISM[R518]->SM_SM[R517];
  while ( not_empty supertype_isms )
    select many cr_evts related by supertype_isms->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509]
                                     ->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
    sm_evts = sm_evts | cr_evts;
    select many supertype_isms related by supertype_isms->SM_ISM[R517]->O_OBJ[R518]->R_OIR[R201]->R_RGO[R203]
                                           ->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]
                                           ->R_OIR[R203]->O_OBJ[R201]->SM_ISM[R518]->SM_SM[R517];
  end while;
  for each sm_evt in sm_evts
	value[1] = ""; // domain
	value[2] = ""; // object
	value[3] = sm_evt.Mning;
	value[4] = "Cannot_Happen";		// Non_Existent defaults to Cannot_Happen because this is required
										// for creation, terminal, and instance events (see section 8.3.2
										// of MASL reference manual)
	// if a creation transition exists, use the state name as the destination
	select one sm_crtxn related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
	if ( not_empty sm_crtxn )
      if ( sm_evt.SM_ID == sm_sm.SM_ID ) // creation events from supertype state machines must always go to ''Cannot_Happen''
        select one sm_state related by sm_crtxn->SM_TXN[R507]->SM_STATE[R506];
        value[4] = sm_state.Name;
      else
        // creation events from supertype state machines must always go to ''Cannot_Happen''
        select one poly_o_obj related by sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
        value[2] = poly_o_obj.Name;
      end if;
	end if;
	// If event is non-local, then get the name of the supertype.
	select one poly_o_obj related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    if ( not_empty poly_o_obj and poly_o_obj.Obj_ID != o_obj.Obj_ID )
      value[2] = poly_o_obj.Name;
    end if;
	out::populate( element:"transition", value:value );
	out::populate( element:"transition", value:emptyvalue );
  end for;
	
  // output transition row pragmas
  ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Instance State Machine::Non_Existent" ) );

end if;

for each sm_state in sm_states
  value[0] = sm_state.Name;
  value[1] = ""; // domain
  select many sm_evts related by sm_state->SM_SEME[R503]->SM_SEVT[R503]->SM_EVT[R525];
  // also collect creation events from the supertypes
  select many supertype_isms related by sm_sm->SM_ISM[R517]->O_OBJ[R518]->R_OIR[R201]->R_RGO[R203]
                                         ->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]
                                         ->R_OIR[R203]->O_OBJ[R201]->SM_ISM[R518]->SM_SM[R517];
  while ( not_empty supertype_isms )
    select many cr_evts related by supertype_isms->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509]
                                     ->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
    sm_evts = sm_evts | cr_evts;
    select many supertype_isms related by supertype_isms->SM_ISM[R517]->O_OBJ[R518]->R_OIR[R201]->R_RGO[R203]
                                           ->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]
                                           ->R_OIR[R203]->O_OBJ[R201]->SM_ISM[R518]->SM_SM[R517];
  end while;
  for each sm_evt in sm_evts
    value[2] = ""; // object
    value[3] = ""; value[4] = "";
    value[3] = sm_evt.Mning;
    select one poly_o_obj related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    if ( not_empty poly_o_obj and poly_o_obj.Obj_ID != o_obj.Obj_ID )
      value[2] = poly_o_obj.Name;
    end if;
    if ( sm_evt.SM_ID != sm_sm.SM_ID )
      // creation events from supertype state machines must always go to ''Cannot_Happen''
      select one poly_o_obj related by sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
      value[2] = poly_o_obj.Name;
      value[4] = "Cannot_Happen";
    else
      select any sm_seme related by sm_evt->SM_SEVT[R525]->SM_SEME[R503] where ( selected.SMstt_ID == sm_state.SMstt_ID );
      select one next_sm_state related by sm_seme->SM_NSTXN[R504]->SM_TXN[R507]->SM_STATE[R506];
      if ( not_empty next_sm_state )
        value[4] = next_sm_state.Name;
      else
        select one sm_eign related by sm_seme->SM_EIGN[R504];
        if ( not_empty sm_eign )
          value[4] = "Ignore";
        else
          select one sm_ch related by sm_seme->SM_CH[R504];
          if ( not_empty sm_ch )
            value[4] = "Cannot_Happen";
          else
            TRACE::log( flavor:"failure", id:102, message:"invalid state machine" );
          end if;
        end if;
      end if;
    end if;
    out::populate( element:"transition", value:value );
    out::populate( element:"transition", value:emptyvalue );
  end for;
	
  // output transition row pragmas
  if ( "assigner" == param.type )
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Class State Machine::" + sm_state.Name ) );
  else
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Instance State Machine::" + sm_state.Name ) );
  end if;
	
end for;

// Populate pragmas
if ( "assigner" == param.type )
  ::mark2pragma( markable:"State Machine", pathkey: ::class_get_path( o_obj:o_obj, child:"Class State Machine" ) );
else
  ::mark2pragma( markable:"State Machine", pathkey: ::class_get_path( o_obj:o_obj, child:"Instance State Machine" ) );
end if;

out::populate( element:"transitiontable", value:emptyvalue );

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("5276c784-1f5f-4e92-a593-1c486c8cf8af",
	"78002803-6c30-4367-95a3-30a4b7969a69",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"fac936f0-5fff-4023-b8c2-2c33c854b8ed",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6562655-0940-4f4f-a1ae-7094b79949a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("3072f139-aa6e-4401-8f4d-6ab4cfd561fe",
	"78002803-6c30-4367-95a3-30a4b7969a69",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5276c784-1f5f-4e92-a593-1c486c8cf8af",
	'');
INSERT INTO S_SPARM
	VALUES ("fac936f0-5fff-4023-b8c2-2c33c854b8ed",
	"78002803-6c30-4367-95a3-30a4b7969a69",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("78002803-6c30-4367-95a3-30a4b7969a69",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7b593c09-c6aa-4291-b5ae-af8401687cb2",
	"00000000-0000-0000-0000-000000000000",
	'event2event',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
sm_sm = param.sm_sm;
select one pe related by o_obj->PE_PE[R8001];
select any containing_c_c from instances of C_C where false;
while ( empty containing_c_c and not_empty pe )
  select one containing_c_c related by pe->C_C[R8003];
  if ( empty containing_c_c )
    select one pe_pe related by pe->EP_PKG[R8000]->PE_PE[R8001];
    if ( empty pe_pe )
      select any pe_pe related by pe->EP_PKG[R8001]->EP_PKGREF[R1402.''is referenced by'']->EP_PKG[R1402.''is referenced by'']->PE_PE[R8001];
    end if;
    pe = pe_pe;
    // If pe is empty, we break out to avoid an infinite loop.
    // This is when the top level system is reached without
    // finding a containing component.
  end if;
end while;
// Get the events for this class, and filter out polys.
select many sm_evts related by sm_sm->SM_EVT[R502];
for each sm_evt in sm_evts

  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    continue; // skip to the next event in the iteration
  end if;

  value[0] = sm_evt.Mning;
  value[2] = STRING::itoa( i:sm_evt.Numb );
  
  // set event type
  value[1] = param.type;
  // check for any creation transition associated with this event
  select one sm_crtxn related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
  if ( not_empty sm_crtxn )
    value[1] = "creation";
  end if;

  out::populate( element:"event", value:value );
  
  // Get first parameter.
  select any sm_evtdi related by sm_evt->SM_EVTDI[R532];
  first_sm_evtdi = sm_evtdi;
  while ( not_empty sm_evtdi )
    first_sm_evtdi = sm_evtdi;
    select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
  end while;
  select one domain_pkg related by containing_c_c->PE_PE[R8001]->EP_PKG[R8000];
  ::parameterSM_EVTDI2parameter( sm_evtdi:first_sm_evtdi, domain_pkg:domain_pkg );
  
  // Populate pragmas
  if ( "assigner" == param.type )
    ::mark2pragma( markable:"State Machine Event", pathkey: ::class_get_path( o_obj:o_obj, child:"Class State Machine::" + sm_evt.Drv_Lbl + ":" + sm_evt.Mning ) );
  else
    ::mark2pragma( markable:"State Machine Event", pathkey: ::class_get_path( o_obj:o_obj, child:"Instance State Machine::" + sm_evt.Drv_Lbl + ":" + sm_evt.Mning ) );
  end if;

  // output the description
  ::Descrip2description( Descrip:sm_evt.Descrip );
  
  out::populate( element:"event", value:emptyvalue );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9d4415e3-ad34-4d40-883c-8f8647a5f282",
	"7b593c09-c6aa-4291-b5ae-af8401687cb2",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"d1a4cfaf-538b-4560-bfef-2d391a79d4d6",
	'');
INSERT INTO S_SPARM
	VALUES ("7d621c7d-0fca-4ab6-9aa2-647b9c85918e",
	"7b593c09-c6aa-4291-b5ae-af8401687cb2",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9d4415e3-ad34-4d40-883c-8f8647a5f282",
	'');
INSERT INTO S_SPARM
	VALUES ("d1a4cfaf-538b-4560-bfef-2d391a79d4d6",
	"7b593c09-c6aa-4291-b5ae-af8401687cb2",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("7b593c09-c6aa-4291-b5ae-af8401687cb2",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b22bbb4b-d763-4757-840e-44c5ac1216bd",
	"00000000-0000-0000-0000-000000000000",
	'state2state',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_obj = param.o_obj;
sm_sm = param.sm_sm;
select one pe related by o_obj->PE_PE[R8001];
select any containing_c_c from instances of C_C where false;
while ( empty containing_c_c and not_empty pe )
  select one containing_c_c related by pe->C_C[R8003];
  if ( empty containing_c_c )
    select one pe_pe related by pe->EP_PKG[R8000]->PE_PE[R8001];
    if ( empty pe_pe )
      select any pe_pe related by pe->EP_PKG[R8001]->EP_PKGREF[R1402.''is referenced by'']->EP_PKG[R1402.''is referenced by'']->PE_PE[R8001];
    end if;
    pe = pe_pe;
    // If pe is empty, we break out to avoid an infinite loop.
    // This is when the top level system is reached without
    // finding a containing component.
  end if;
end while;
select many sm_states related by sm_sm->SM_STATE[R501];
select any sm_state related by sm_sm->SM_STATE[R501];
lowest = 7777;
if ( not_empty sm_state )
  lowest = sm_state.Numb; // any random state number
end if;

if ( "assigner" == param.type )
  // Find the lowest numbered state to be ASSIGNER START.
  for each sm_state in sm_states
    if ( sm_state.Numb < lowest )
      lowest = sm_state.Numb;
    end if;
  end for;
else
  //
end if;

value[0] = ""; // domain, grammar allows this but we are not using it
value[1] = o_obj.Name;
for each sm_state in sm_states
  value[2] = sm_state.Name;
  value[4] = STRING::itoa( i:sm_state.Numb );
  
  // set state type
  value[3] = "";
  if ( ( "assigner" == param.type ) and ( lowest == sm_state.Numb ) )
    value[3] = "assigner start";
  elif ( "assigner" == param.type )
    value[3] = "assigner";
  elif ( 1 == sm_state.Final )
    value[3] = "terminal";
  else
    // check for any creation transition destined to this state
    select any sm_crtxn related by sm_state->SM_TXN[R506]->SM_CRTXN[R507];
    if ( not_empty sm_crtxn )
      value[3] = "creation";
    end if;
  end if;

  out::populate( element:"state", value:value );

  // MASL states declare their parameter signatures.
  // Traverse to any event transitioning to this state and use its parameters.
  select any sm_evtdi related by sm_state->SM_TXN[R506]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532];
  if ( empty sm_evtdi )	// if there are no state to state transitions to this state, it may be a creation
  						// state. Check the path to an event through a creation transition
    select any sm_evtdi related by sm_state->SM_TXN[R506]->SM_CRTXN[R507]->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525]->SM_EVTDI[R532];
    if ( empty sm_evtdi )
      select any sm_evtdi related by sm_state->SM_TXN[R506]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]->SM_EVTDI[R532];
    end if;
  end if;
  // Get first parameter.
  first_sm_evtdi = sm_evtdi;
  while ( not_empty sm_evtdi )
    first_sm_evtdi = sm_evtdi;
    select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
  end while;
  select one domain_pkg related by containing_c_c->PE_PE[R8001]->EP_PKG[R8000];
  ::parameterSM_EVTDI2parameter( sm_evtdi:first_sm_evtdi, domain_pkg:domain_pkg );
  
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  // Populate the action langauge body.
  ::body2code_block( name:"", text:STRING::unescapetics(s:sm_act.Action_Semantics_internal) );
  
  // Populate pragmas
  ::mark2pragma( markable:"Action", pathkey: ::class_get_path( o_obj:o_obj, child:"InstanceStateMachine::" + sm_state.Name + "::State Action" ) );

  // output the description
  ::Descrip2description( Descrip:sm_act.Descrip );
  
  if ( "assigner" == param.type )
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Class State Machine::" + sm_state.Name ) );
  else
    ::mark2pragma( markable:"State Machine State", pathkey: ::class_get_path( o_obj:o_obj, child: "::Instance State Machine::" + sm_state.Name ) );
  end if;

  out::populate( element:"state", value:emptyvalue );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("39e07600-0fc3-4419-bea9-f719b03957e9",
	"b22bbb4b-d763-4757-840e-44c5ac1216bd",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"ab128079-dc46-44b1-a1df-f1438a95a38f",
	'');
INSERT INTO S_SPARM
	VALUES ("b4d96123-4ced-4577-9028-1ae0b33e681d",
	"b22bbb4b-d763-4757-840e-44c5ac1216bd",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"39e07600-0fc3-4419-bea9-f719b03957e9",
	'');
INSERT INTO S_SPARM
	VALUES ("ab128079-dc46-44b1-a1df-f1438a95a38f",
	"b22bbb4b-d763-4757-840e-44c5ac1216bd",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("b22bbb4b-d763-4757-840e-44c5ac1216bd",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("45112864-29c1-4db8-9cd5-3121f843a9ff",
	"00000000-0000-0000-0000-000000000000",
	'parameterSM_EVTDI2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

sm_evtdi = param.sm_evtdi;
if ( not_empty sm_evtdi )
  value[0] = sm_evtdi.Name;
  value[1] = "in";
  out::populate( element:"parameter", value:value );
  select one s_dt related by sm_evtdi->S_DT[R524];
  ::type2typeref( s_dt:s_dt, domain_pkg:param.domain_pkg );
  select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''precedes''];
  ::parameterSM_EVTDI2parameter( sm_evtdi:sm_evtdi, domain_pkg:param.domain_pkg );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("3cc94496-ce2a-4ae7-a208-d9eb28187713",
	"45112864-29c1-4db8-9cd5-3121f843a9ff",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("77c854a3-ee65-431a-9cb0-137e08ad0d1b",
	"45112864-29c1-4db8-9cd5-3121f843a9ff",
	'domain_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"3cc94496-ce2a-4ae7-a208-d9eb28187713",
	'');
INSERT INTO PE_PE
	VALUES ("45112864-29c1-4db8-9cd5-3121f843a9ff",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4202b26a-3a0c-4d52-93bc-ac44e489e824",
	"00000000-0000-0000-0000-000000000000",
	'associative2associative',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
r_assoc = param.r_assoc;
select one r_aone related by r_assoc->R_AONE[R209];
select one one_o_obj related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 
select one r_aoth related by r_assoc->R_AOTH[R210];
select one oth_o_obj related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 
select one r_assr related by r_assoc->R_ASSR[R211];
select one ass_o_obj related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]; 

onename = one_o_obj.Name;
othname = oth_o_obj.Name;
onephrase = T::underscore( s:r_aone.Txt_Phrs );
othphrase = T::underscore( s:r_aoth.Txt_Phrs );
onecond = "conditionally";
othcond = "conditionally";
onemult = "many";
othmult = "many";
if ( 0 == r_aone.Cond )
  onecond = "unconditionally";
end if;
if ( 0 == r_aoth.Cond )
  othcond = "unconditionally";
end if;
if ( 0 == r_aone.Mult )
  onemult = "one";
end if;
if ( 0 == r_aoth.Mult )
  othmult = "one";
end if;

if ( ( "" == onephrase ) or ( "" == othphrase ) )
  TRACE::log( flavor:"failure", id:11, message:"no role phrase for:  " + onename + " to " + othname );
end if;

value[0] = c_c.Name;
value[1] = onename;
value[2] = othphrase;
value[3] = othcond;
value[4] = othmult;
value[5] = c_c.Name;
value[6] = othname;
out::populate( element:"participation", value:value );

value[0] = c_c.Name;
value[1] = othname;
value[2] = onephrase;
value[3] = onecond;
value[4] = onemult;
value[5] = c_c.Name;
value[6] = onename;
out::populate( element:"participation", value:value );

out::populate( element:"participation", value:emptyvalue );

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("82f62d53-ef7e-4045-a8b7-e0fd0eeceec7",
	"4202b26a-3a0c-4d52-93bc-ac44e489e824",
	'r_assoc',
	"7f02c6dd-ea5d-4892-801e-a1515764350f",
	0,
	'',
	"aee17374-71d3-47b6-b6f6-e063904f4a3c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7f02c6dd-ea5d-4892-801e-a1515764350f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Linked Association>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("aee17374-71d3-47b6-b6f6-e063904f4a3c",
	"4202b26a-3a0c-4d52-93bc-ac44e489e824",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("4202b26a-3a0c-4d52-93bc-ac44e489e824",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	"00000000-0000-0000-0000-000000000000",
	'subsuper2subsuper',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
r_subsup = param.r_subsup;
select one o_obj related by r_subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]; 

value[0] = "";	// c_c.Name;
value[1] = o_obj.Name;
value[2] = "";	// "is_a";
value[3] = "";	// "unconditionally";
value[4] = "";	// "one";
value[5] = "";	// c_c.Name;
value[6] = "";
out::populate( element:"participation", value:value );

value[6] = o_obj.Name;
select many o_objs related by r_subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]; 
for each o_obj in o_objs
  value[1] = o_obj.Name;
  out::populate( element:"participation", value:value );
end for;

out::populate( element:"participation", value:emptyvalue );

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("cf4ea895-58ef-476c-837b-8dfa3a918c5a",
	"470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	'r_subsup',
	"8f3b0ab8-e566-4e03-9159-7047140c04a7",
	0,
	'',
	"91396840-1014-44dd-9a98-a0b61d9ce38c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8f3b0ab8-e566-4e03-9159-7047140c04a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Subtype Supertype Association>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("91396840-1014-44dd-9a98-a0b61d9ce38c",
	"470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("470c92fd-02d6-42c6-89f5-2309dd2c79e0",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	"00000000-0000-0000-0000-000000000000",
	'classop2objectop',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
o_obj = param.o_obj;
value[0] = c_c.Name;
value[1] = o_obj.Name;
select many o_tfrs related by o_obj->O_TFR[R115];
for each o_tfr in o_tfrs

  value[2] = "public"; // All class operations are public
  value[3] = o_tfr.Name;
  value[4] = "";
  if ( Scope::Instance == o_tfr.Instance_Based )
    value[4] = "instance";
  end if;
  value[5] = "";
  value[6] = STRING::itoa( i:o_tfr.Numb );
  
  // check for deferral -- if there is no action language or the dialect is none and subtypes have an operation with matching signature
  deferred = false;
  if ( "" == o_tfr.Action_Semantics_internal or ActionDialect::none == o_tfr.Dialect )
    // select all supsuper relationships of which o_tfr belongs to the supertype
    select many subsuper_rels related by o_tfr->O_OBJ[R115]->R_OIR[R201]->R_RTO[R203]->R_SUPER[R204]->R_SUBSUP[R212]->R_REL[R206];
    for each subsuper_rel in subsuper_rels
      select many subtypes related by subsuper_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->O_OBJ[R201];
      i = 0;
      for each subtype in subtypes // check all the operations of each subtype
        select many sub_o_tfrs related by subtype->O_TFR[R115];
        for each sub_o_tfr in sub_o_tfrs
          if ( ::operation_getsignature( flavor:1, o_tfr:o_tfr ) == ::operation_getsignature( flavor:1, o_tfr:sub_o_tfr ) )
            i = i + 1; // if the subtype has a matching operation, add it to the count
            break;
          end if;
        end for;
      end for;
      if ( i == cardinality subtypes ) // every subtype has a matching operation (this is the deferral relationship)
        value[5] = "R" + STRING::itoa( i:subsuper_rel.Numb );  // itoa to form relationship name
        deferred = true;
        break;
      end if;
    end for;
  end if;

  // Get the first parameter.
  select any o_tparm related by o_tfr->O_TPARM[R117];
  first_o_tparm = o_tparm;
  while ( not_empty o_tparm )
    first_o_tparm = o_tparm;
    select one o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
  end while;
  
  out::populate( element:"operation", value:value );
  select one domain_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
  ::parameterO_TPARM2parameter( o_tparm:first_o_tparm, domain_pkg:domain_pkg );
  // find return type if exists
  select one s_dt related by o_tfr->S_DT[R116];
  ::type2typeref( s_dt:s_dt, domain_pkg:domain_pkg );
  
  // Populate the action langauge body.
  if ( not deferred )	// do not populate a codeblock if this is a deferred operation
    ::body2code_block( name:"", text:STRING::unescapetics(s:o_tfr.Action_Semantics_internal) );
  end if;
  
  // Populate pragmas
  ::mark2pragma( markable:"Operation", pathkey: ::class_get_path( o_obj:o_obj, child: ::operation_getsignature( flavor:1, o_tfr:o_tfr ) ) );

  // output the description
  ::Descrip2description( Descrip:o_tfr.Descrip );
  
  out::populate( element:"operation", value:emptyvalue );
  
end for;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("b20d9889-4d3c-4f25-a8db-c0753f2d6cac",
	"32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"693ec31b-49ac-47ed-811a-066443a909ce",
	'');
INSERT INTO S_SPARM
	VALUES ("693ec31b-49ac-47ed-811a-066443a909ce",
	"32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("32848e1b-5a26-4dcf-96a2-9d5ca948d31a",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	"00000000-0000-0000-0000-000000000000",
	'parameterO_TPARM2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

o_tparm = param.o_tparm;
if ( not_empty o_tparm )
  value[0] = o_tparm.Name;
  if ( 0 == o_tparm.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by o_tparm->S_DT[R118];
  ::type2typeref( s_dt:s_dt, domain_pkg:param.domain_pkg );
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
  ::parameterO_TPARM2parameter( o_tparm:o_tparm, domain_pkg:param.domain_pkg );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("79a8a289-1d1d-4dd0-8a5c-769e1ea19030",
	"1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("9487b2e5-565b-42e7-a2a2-70528fab743b",
	"1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	'domain_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"79a8a289-1d1d-4dd0-8a5c-769e1ea19030",
	'');
INSERT INTO PE_PE
	VALUES ("1ec46b81-5ac9-470b-8a41-cb1d6fad4f3f",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9feb3491-f835-4302-9628-50c776b209ed",
	"00000000-0000-0000-0000-000000000000",
	'body2code_block',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

select any model from instances of model where ( selected.name == "maslout" );
if ( empty model or ( not_empty model and "true" == model.getoption( name:"outputcodeblocks" ) ) )

  if ( "" != param.text )
    value[0] = param.text;
    out::populate( element:"codeblock", value:value );
    out::populate( element:"codeblock", value:emptyvalue );
  end if;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("8dd08552-fe99-4071-95f5-32ada1023ceb",
	"9feb3491-f835-4302-9628-50c776b209ed",
	'text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"66dfda05-05dc-4065-bbdc-476aa9f06535",
	'');
INSERT INTO S_SPARM
	VALUES ("66dfda05-05dc-4065-bbdc-476aa9f06535",
	"9feb3491-f835-4302-9628-50c776b209ed",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("9feb3491-f835-4302-9628-50c776b209ed",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2f459c99-3c8c-4b98-8898-5661cf9e0fbe",
	"00000000-0000-0000-0000-000000000000",
	'class2objectdeclaration',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

c_c = param.c_c;
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
select many pkg_o_objs related by ep_pkgs->PE_PE[R8000]->O_OBJ[R8001];
select many pkgref_o_objs related by ep_pkgs->EP_PKGREF[R1402.''refers to'']->EP_PKG[R1402.''refers to'']->PE_PE[R8000]->O_OBJ[R8001];
o_objs = pkg_o_objs + pkgref_o_objs;
for each o_obj in o_objs
  value[0] = o_obj.Name;
  out::populate( element:"object", value:value );
  // Note:  No marking occurs on the declaration, even though the grammar allows it.
  out::populate( element:"object", value:emptyvalue );
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e7e87814-1a70-4e6e-a9fd-7725a64e6126",
	"2f459c99-3c8c-4b98-8898-5661cf9e0fbe",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("2f459c99-3c8c-4b98-8898-5661cf9e0fbe",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("13a97136-92e4-4982-967e-3a8919a4ecbf",
	"00000000-0000-0000-0000-000000000000",
	'Descrip2description',
	'',
	'value[7]=""; value[6]=""; value[5]=""; value[4]=""; value[3]=""; value[2]=""; value[1]=""; value[0]="";
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

// output the description
if ( "" != STRING::trim( s:param.Descrip ) )
  value[0] = STRING::unescapetics(s:param.Descrip);
  out::populate( element:"description", value:value );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("f2aa1161-9f0e-499c-8a7d-df804ac3f56a",
	"13a97136-92e4-4982-967e-3a8919a4ecbf",
	'Descrip',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("13a97136-92e4-4982-967e-3a8919a4ecbf",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	"00000000-0000-0000-0000-000000000000",
	'function_getsignature',
	'',
	'/**
 *  Return a string representation of this functions signature
 *  with the specified flavor
 *  0 = named parameters
 *  1 = positional parameters
 *  named signature = return_type function(param1:type, param2:type, param3:type)
 *  parameters for the named flavor are sorted alphanumerically
 *  positional signature = return_type function(param1_type, param2_type, param3_type)
 */
 
s_sync = param.s_sync;
 
signature = "";

// Get return type
select one returntype related by s_sync->S_DT[R25];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + s_sync.Name;

// Get parameters

if ( 1 == param.flavor )

  // Get the first parameter.
  select any parameter related by s_sync->S_SPARM[R24];
  first_param = parameter;
  while ( not_empty parameter )
	first_param = parameter;
	select one parameter related by parameter->S_SPARM[R54.''succeeds''];
  end while;

  if( not_empty first_param )
	signature = signature + "(";
  end if;
  separator = "";
  parameter = first_param;
  while ( not_empty parameter )
	select one type related by parameter->S_DT[R26];
	signature = signature + separator + type.Name;
	separator = " ";
	select one parameter related by parameter->S_SPARM[R54.''precedes''];
  end while;
  if( not_empty first_param )
	signature = signature + ")";
  end if;

elif ( 0 == param.flavor )

  // get the parameters in sorted order
  separator = "";
  select many parameters related by s_sync->S_SPARM[R24];
  num_params = cardinality parameters; 
  if ( num_params > 0 )
	signature = signature + "(";
  end if;

  // the following time complexity is n^2
  count = 0;
  select any last_param from instances of S_SPARM where false;
  select any curr_param from instances of S_SPARM where false;
  while ( count < num_params )
    for each parameter in parameters
      if ( ( empty curr_param and empty last_param )
           or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
           or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
           or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
        curr_param = parameter;
      end if;
    end for;
    
    select one type related by curr_param->S_DT[R26];
    signature = signature + separator + curr_param.Name + ":" + type.Name;
    separator = " ";

    last_param = curr_param;
    select any curr_param from instances of S_SPARM where false;
    count = count + 1;
  end while;

  if ( num_params > 0 )
	signature = signature + ")";
  end if;
  
end if;

return signature;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("64bdae58-a63d-4347-9a1f-1157732b8fdb",
	"9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("113b1990-9cd4-45f5-ae9b-33c37ec738d1",
	"9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"64bdae58-a63d-4347-9a1f-1157732b8fdb",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("9d4cc9c5-e05c-4c57-bc22-220ce1b0492d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("97479412-7ded-48c7-8a35-887be07c15e4",
	"00000000-0000-0000-0000-000000000000",
	'message_getsignature',
	'',
	'c_ep = param.c_ep;

select one c_io related by c_ep->C_IO[R4004];
if ( not_empty c_io )
  /**
   *  Return a string representation of this operations signature
   *  with the specified flavor
   *  0 = named parameters
   *  1 = positional parameters
   *  named signature = return_type operation(param1:type, param2:type, param3:type)
   *  parameters for the named flavor are sorted alphanumerically
   *  positional signature = return_type operation(param1_type, param2_type, param3_type)
   */
   
  signature = "";

  // Get return type
  select one returntype related by c_io->S_DT[R4008];
  signature = signature + returntype.Name + " ";
   
  // Get name
  signature = signature + c_io.Name;

  // Get parameters

  if ( 1 == param.flavor )

	// Get the first parameter.
	select any parameter related by c_io->C_EP[R4004]->C_PP[R4006];
	first_param = parameter;
	while ( not_empty parameter )
	  first_param = parameter;
	  select one parameter related by parameter->C_PP[R4021.''succeeds''];
	end while;

	if( not_empty first_param )
	  signature = signature + "(";
	end if;
	separator = "";
	parameter = first_param;
	while ( not_empty parameter )
	  select one type related by parameter->S_DT[R4007];
	  signature = signature + separator + type.Name;
	  separator = " ";
	  select one parameter related by parameter->C_PP[R4021.''precedes''];
	end while;
	if( not_empty first_param )
	  signature = signature + ")";
	end if;

  elif ( 0 == param.flavor )

	// get the parameters in sorted order
	separator = "";
	select many parameters related by c_io->C_EP[R4004]->C_PP[R4006];
	num_params = cardinality parameters; 
	if ( num_params > 0 )
	  signature = signature + "(";
	end if;

	// the following time complexity is n^2
	count = 0;
	select any last_param from instances of C_PP where false;
	select any curr_param from instances of C_PP where false;
	while ( count < num_params )
	  for each parameter in parameters
		if ( ( empty curr_param and empty last_param )
			 or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
			 or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
			 or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
		  curr_param = parameter;
		end if;
	  end for;
	  
	  select one type related by curr_param->S_DT[R4007];
	  signature = signature + separator + curr_param.Name + ":" + type.Name;
	  separator = ", ";

	  last_param = curr_param;
	  select any curr_param from instances of C_PP where false;
	  count = count + 1;
	end while;

	if ( num_params > 0 )
	  signature = signature + ")";
	end if;
	
  end if;

  return signature;
else
  select one c_as related by c_ep->C_AS[R4004];
  /**
   *  Return a string representation of this signals signature
   *  with the specified flavor
   *  0 = named parameters
   *  1 = positional parameters
   *  named signature = signal(param1:type, param2:type, param3:type)
   *  parameters for the named flavor are sorted alphanumerically
   *  positional signature = signal(param1_type, param2_type, param3_type)
   */
   
  signature = "";

  // Get name
  signature = signature + c_as.Name;

  // Get parameters

  if ( 1 == param.flavor )

	// Get the first parameter.
	select any parameter related by c_as->C_EP[R4004]->C_PP[R4006];
	first_param = parameter;
	while ( not_empty parameter )
	  first_param = parameter;
	  select one parameter related by parameter->C_PP[R4021.''succeeds''];
	end while;

	if( not_empty first_param )
	  signature = signature + "(";
	end if;
	separator = "";
	parameter = first_param;
	while ( not_empty parameter )
	  select one type related by parameter->S_DT[R4007];
	  signature = signature + separator + type.Name;
	  separator = ", ";
	  select one parameter related by parameter->C_PP[R4021.''precedes''];
	end while;
	if( not_empty first_param )
	  signature = signature + ")";
	end if;

  elif ( 0 == param.flavor )

	// get the parameters in sorted order
	separator = "";
	select many parameters related by c_as->C_EP[R4004]->C_PP[R4006];
	num_params = cardinality parameters; 
	if ( num_params > 0 )
	  signature = signature + "(";
	end if;

	// the following time complexity is n^2
	count = 0;
	select any last_param from instances of C_PP where false;
	select any curr_param from instances of C_PP where false;
	while ( count < num_params )
	  for each parameter in parameters
		if ( ( empty curr_param and empty last_param )
			 or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
			 or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
			 or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
		  curr_param = parameter;
		end if;
	  end for;
	  
	  select one type related by curr_param->S_DT[R4007];
	  signature = signature + separator + curr_param.Name + ":" + type.Name;
	  separator = ", ";

	  last_param = curr_param;
	  select any curr_param from instances of C_PP where false;
	  count = count + 1;
	end while;

	if ( num_params > 0 )
	  signature = signature + ")";
	end if;
	
  end if;

  return signature;
end if;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("70ae1d69-d2bf-4e80-84f5-ab2c1c7c9814",
	"97479412-7ded-48c7-8a35-887be07c15e4",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("9510c62c-c3b3-4a07-8e60-b8a3e0e6dac1",
	"97479412-7ded-48c7-8a35-887be07c15e4",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"70ae1d69-d2bf-4e80-84f5-ab2c1c7c9814",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("97479412-7ded-48c7-8a35-887be07c15e4",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	"00000000-0000-0000-0000-000000000000",
	'operation_getsignature',
	'',
	'/**
 *  Return a string representation of this operations signature
 *  with the specified flavor
 *  0 = named parameters
 *  1 = positional parameters
 *  named signature = return_type operation(param1:type, param2:type, param3:type)
 *  parameters for the named flavor are sorted alphanumerically
 *  positional signature = return_type operation(param1_type, param2_type, param3_type)
 */
o_tfr = param.o_tfr;
 
signature = "";

// Get return type
select one returntype related by o_tfr->S_DT[R116];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + o_tfr.Name;

// Get parameters

if ( 1 == param.flavor )

  // Get the first parameter.
  select any parameter related by o_tfr->O_TPARM[R117];
  first_param = parameter;
  while ( not_empty parameter )
	first_param = parameter;
	select one parameter related by parameter->O_TPARM[R124.''succeeds''];
  end while;

  if( not_empty first_param )
	signature = signature + "(";
  end if;
  separator = "";
  parameter = first_param;
  while ( not_empty parameter )
	  select one type related by parameter->S_DT[R118];
	  signature = signature + separator + type.Name;
	  separator = " ";
	  select one parameter related by parameter->O_TPARM[R124.''precedes''];
  end while;
  if( not_empty first_param )
	signature = signature + ")";
  end if;

elif ( 0 == param.flavor )

  // get the parameters in sorted order
  separator = "";
  select many parameters related by o_tfr->O_TPARM[R117];
  num_params = cardinality parameters; 
  if ( num_params > 0 )
	signature = signature + "(";
  end if;

  // the following time complexity is n^2
  count = 0;
  select any last_param from instances of O_TPARM where false;
  select any curr_param from instances of O_TPARM where false;
  while ( count < num_params )
    for each parameter in parameters
      if ( ( empty curr_param and empty last_param )
           or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
           or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
           or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
        curr_param = parameter;
      end if;
    end for;
    
    select one type related by curr_param->S_DT[R118];
    signature = signature + separator + curr_param.Name + ":" + type.Name;
    separator = ", ";

    last_param = curr_param;
    select any curr_param from instances of O_TPARM where false;
    count = count + 1;
  end while;

  if ( num_params > 0 )
	signature = signature + ")";
  end if;
  
end if;

return signature;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("561b683a-9821-4ef9-b121-5aae212d3c53",
	"e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("42219095-be3f-434f-9522-0de0ede86b72",
	"e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"561b683a-9821-4ef9-b121-5aae212d3c53",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("e766fc2b-8613-441d-8c05-c1b286dbaa1e",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bef2c4c8-46d5-4c5e-b08c-26e39f7b0a3c",
	"00000000-0000-0000-0000-000000000000",
	'exception2exception',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";
c_c = param.c_c;

// Exceptions in packages inside the component are considered private.
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
select many pkg_s_exps related by ep_pkgs->PE_PE[R8000]->S_EXP[R8001];
select many pkgref_s_exps related by ep_pkgs->EP_PKGREF[R1402.''refers to'']->EP_PKG[R1402.''refers to'']->PE_PE[R8000]->S_EXP[R8001];
s_exps = pkg_s_exps + pkgref_s_exps;
for each s_exp in s_exps
  value[0] = s_exp.Name;
  value[1] = "private";
  out::populate( element:"exception", value:value );
  select one ep_pkg related by s_exp->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Exception", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:s_exp.Name ) );
  out::populate( element:"exception", value:emptyvalue );
end for;

// Exceptions in packages directly off of the system are considered public.
select many ep_pkgs related by c_c->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1401] where ( selected.Name != "types" );
select many s_exps related by ep_pkgs->PE_PE[R8000]->S_EXP[R8001];
for each s_exp in s_exps
  value[0] = s_exp.Name;
  value[1] = "public";
  out::populate( element:"exception", value:value );
  select one ep_pkg related by s_exp->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Exception", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:s_exp.Name ) );
  out::populate( element:"exception", value:emptyvalue );
end for;

// Exceptions in subpackages of the system packages are also considered public
select many sub_pkgs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001];
while ( not_empty sub_pkgs )
  select many s_exps related by sub_pkgs->PE_PE[R8000]->S_EXP[R8001];
  for each s_exp in s_exps
    value[0] = s_exp.Name;
    value[1] = "public";
    out::populate( element:"exception", value:value );
    select one ep_pkg related by s_exp->PE_PE[R8001]->EP_PKG[R8000];
    ::mark2pragma( markable:"Exception", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:s_exp.Name ) );
    out::populate( element:"exception", value:emptyvalue );
  end for;
  select many sub_pkgs related by sub_pkgs->PE_PE[R8000]->EP_PKG[R8001];
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("308fb1dc-110d-445b-a5de-a7d62bff457d",
	"bef2c4c8-46d5-4c5e-b08c-26e39f7b0a3c",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("bef2c4c8-46d5-4c5e-b08c-26e39f7b0a3c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1d772117-8637-4071-8966-b5fffae70670",
	"00000000-0000-0000-0000-000000000000",
	'remove_kl',
	'',
	'string = param.s;

start_index = STRING::indexof( haystack:string, needle:"pragma key_letter" );
while ( -1 != start_index )
  substr_begin = STRING::substr( s:string, begin:0, end:start_index );
  temp_str = STRING::substr( s:string, begin:start_index, end:-1 );
  end_index = STRING::indexof( haystack:temp_str, needle:";" );
  if ( -1 != end_index )
    substr_end = STRING::substr( s:temp_str, begin:end_index+1, end:-1 );
    string = substr_begin + substr_end;
    start_index = STRING::indexof( haystack:string, needle:"pragma key_letter" );
  else
    start_index = -1;
  end if;
end while;

return string;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("de5a1558-1109-424e-9d38-e853780dbfea",
	"1d772117-8637-4071-8966-b5fffae70670",
	's',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("1d772117-8637-4071-8966-b5fffae70670",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4f7faf8b-f0da-4aae-80e2-2018ff927926",
	"00000000-0000-0000-0000-000000000000",
	'mark2pragma',
	'',
	'// Look up the mark and convert it to a pragma.

value[7]=""; value[6]=""; value[5]=""; value[4]=""; value[3]=""; value[2]=""; value[1]=""; value[0]="";
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

select any markable from instances of Markable where ( selected.name == param.markable );
select many marks related by markable->Mark[R2821] where ( selected.path == param.pathkey );
for each mark in marks
  
  value[0] = mark.feature_name;
  value[1] = "";
  out::populate( element:"pragma", value:value );

  value[0] = mark.value;
  out::populate( element:"pragmaitem", value:value );
  out::populate( element:"pragmaitem", value:emptyvalue );

  out::populate( element:"pragma", value:emptyvalue );

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("568d603f-636d-4311-910f-ef57c6a92bcb",
	"4f7faf8b-f0da-4aae-80e2-2018ff927926",
	'pathkey',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"38afae16-9fdc-48bc-852d-4bbe7e60127d",
	'');
INSERT INTO S_SPARM
	VALUES ("38afae16-9fdc-48bc-852d-4bbe7e60127d",
	"4f7faf8b-f0da-4aae-80e2-2018ff927926",
	'markable',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("4f7faf8b-f0da-4aae-80e2-2018ff927926",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("12b0e811-e469-45bb-93a9-70c47457f5d8",
	"00000000-0000-0000-0000-000000000000",
	'load_marking_data',
	'',
	'/*
Load features and markable elements from the features.mark marking file.
Load marks from application.mark in the gen/ folder.
*/
select any model from instances of model where ( selected.name == "maslout" );
if ( not_empty model )
  i = 0; values[7] = "";
  while ( i < 8 )
    values[i] = "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ";
    i = i + 1;
  end while;
  TRACE::log( flavor:"info", id:103, message:"Loading marking data." );
  Feature::load( filename:model.getoption( name:"projectroot" ) + "/gen/features.mark", values:values );
  Mark::load( filename: model.getoption( name:"projectroot" ) + "/gen/application.mark", values:values );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("12b0e811-e469-45bb-93a9-70c47457f5d8",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6c0ff46e-0f2b-48a5-98c2-644ae0cee595",
	"00000000-0000-0000-0000-000000000000",
	'type2typeref',
	'',
	'value[7]=""; value[6]=""; value[5]=""; value[4]=""; value[3]=""; value[2]=""; value[1]=""; value[0]="";
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";
s_dt = param.s_dt;
domain_ep_pkg = param.domain_pkg;
if ( not_empty s_dt )
   // Do not send a void typeref.  No typeref equals void in MASL.
  if ( "void" != s_dt.Name )
    value[0] = s_dt.Name;  // typref is the name of the type
    select one core_dt related by s_dt->S_UDT[R17]->S_DT[R18];
    // if the type is already qualified with a domain name, or if it is a UDT based on MASLtype (type reference type), no need to qualify it again
    if ( -1 == STRING::indexof( haystack:s_dt.Name, needle:"::" ) and not ( not_empty core_dt and "MASLtype" == core_dt.Name ) )
      // If type is inside a component, it is local.
      select one parent_ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
      select one parent_c_c related by parent_ep_pkg->PE_PE[R8001]->C_C[R8003];
      while ( not_empty parent_ep_pkg and empty parent_c_c )
        select one parent_ep_pkg related by parent_ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
        select one parent_c_c related by parent_ep_pkg->PE_PE[R8001]->C_C[R8003];
      end while;
      if ( empty parent_c_c ) // not in a component, so keep looking
        // check if this type is defined in the same domain
        // Do this by traversing up from the type to see if ever we hit the domain package (containing the domain component).
        select one dt_ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
        same_domain = false;
        while ( not_empty dt_ep_pkg )
          if ( dt_ep_pkg == domain_ep_pkg )
            same_domain = true;
            break;
          end if;
          select one dt_ep_pkg related by dt_ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
        end while;
        if ( not same_domain ) // foreign type, find owner
          // Otherwise, foreign.  Find owning domain.
          select any domain_c_c from instances of C_C where false;
          select one containing_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
          // if containing_pkg is empty, we are either directly under a system or inside a component.
          // if inside a component, this type is private anyway (and cannot be referenced from another domain).
          // if under the system we need to break out to avoid an infinite loop scenario.
          select one sys related by containing_pkg->S_SYS[R1401];
          if ( empty sys )
            while ( empty domain_c_c and not_empty containing_pkg )
              // find the nearest sibling component. if there are more than one, show an error
              select many domain_c_cs related by containing_pkg->PE_PE[R8000]->C_C[R8001];
              if ( cardinality domain_c_cs > 1 )
                TRACE::log( id:76, flavor:"warning", message:"Multiple domain components found for type: " + s_dt.Name );
                break;
              else
                for each c_c in domain_c_cs
                  domain_c_c = c_c; // because of the above check, this only gets executed once
                end for;
              end if;
              select one containing_pkg related by containing_pkg->PE_PE[R8001]->EP_PKG[R8000];
              if ( empty containing_pkg and empty domain_c_c )
                TRACE::log( id:75, flavor:"warning", message:"No domain component found for type: " + s_dt.Name );
              end if;
            end while;
            // qualify the type name with the name of the domain
            if ( not_empty domain_c_c )
              value[0] = domain_c_c.Name + "::" + value[0];
            end if;
          else
            // type lives in package directly off the system. here we assume the user knows that these types are not part of
            // a domain and their reference is left unqualified
          end if;
        else
          // local to domain, no qualification needed
        end if;
      else
        // private, inside a component
      end if;
    else
      // already has qualifier
    end if;
    // special mappings
    if ( s_dt.Name == "MASLunique" or s_dt.Name == "unique_id" )  // MASLunique is always an integer
      value[0] = "integer";
    elif ( s_dt.Name == "inst_ref<Timer>" ) // inst_ref<Timer> maps to MASL timer
      value[0] = "timer";
    elif ( STRING::indexof( haystack:s_dt.Name, needle:"inst_ref<" ) > -1 )
      // Convert inst_ref<class> to instance of class.
      value[0] = "instance of " + STRING::substr( s:s_dt.Name, begin:9, end: STRING::strlen( s:s_dt.Name ) - 1 );
    else
      //
    end if;
    out::populate( element:"typeref", value:value );
    out::populate( element:"typeref", value:emptyvalue );
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("a8ee1b9b-1d34-4718-b0d2-e06eaee133c2",
	"6c0ff46e-0f2b-48a5-98c2-644ae0cee595",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("dc29636c-1d46-4544-a9e9-ced44060790e",
	"6c0ff46e-0f2b-48a5-98c2-644ae0cee595",
	'domain_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"a8ee1b9b-1d34-4718-b0d2-e06eaee133c2",
	'');
INSERT INTO PE_PE
	VALUES ("6c0ff46e-0f2b-48a5-98c2-644ae0cee595",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("37b8e256-4792-4a44-a210-bed61e765a1d",
	"00000000-0000-0000-0000-000000000000",
	'depl2project',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

d_depls = param.d_depls;
for each d_depl in d_depls

  value[0] = d_depl.Name;
  value[1] = d_depl.Key_Lett;
  out::populate( element:"project", value:value );
  
  select many d_terms related by d_depl->D_TERM[R1650];
  select many sequenced_d_terms related by d_depl->D_TERM[R1650]->D_TSS[R1658]->D_TERM[R1658];
  d_terms = d_terms - sequenced_d_terms;
  ::terminator2terminator( d_terms:d_terms );
  ::sequencedterminator2terminator( d_terms: sequenced_d_terms );

  // Populate pragmas
  select one ep_pkg related by d_depl->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"Proc", pathkey: ::package_get_path( ep_pkg:ep_pkg, child:d_depl.Name ) );

  // output the description
  ::Descrip2description( Descrip:d_depl.Descrip );

  // end project
  out::populate( element:"project", value:emptyvalue );

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("bdc9f917-fcb4-4d54-98e3-b54cff84fe28",
	"37b8e256-4792-4a44-a210-bed61e765a1d",
	'd_depls',
	"50c73587-c41b-4b83-a659-320537f9dba1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("50c73587-c41b-4b83-a659-320537f9dba1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Deployment>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Deployment/Deployment.xtuml');
INSERT INTO PE_PE
	VALUES ("37b8e256-4792-4a44-a210-bed61e765a1d",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("43983355-f611-4bf0-9d00-99e26fa8f9a1",
	"00000000-0000-0000-0000-000000000000",
	'terminator2terminator',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

d_terms = param.d_terms;

while ( not_empty d_terms )

  // get any terminator
  select any any_term from instances of D_TERM where false;
  for each d_term in d_terms
    any_term = d_term;
    break;
  end for;

  select one d_depl related by any_term->D_DEPL[R1650];
  
  // populate the domain
  value[0] = any_term.Domain_Name;
  // key letters not present in Terminator
  value[1] = "";
  value[2] = any_term.Implementation_System;
  out::populate( element:"domain", value:value );
  
  // get all terminators with the same domain
  select many domain_terms related by d_terms->D_DEPL[R1650]->D_TERM[R1650] where ( selected.Domain_Name == any_term.Domain_Name );
  for each d_term in domain_terms
    if (not d_term.Provider)
      value[0] = d_term.Terminator_Name;
      value[1] = d_term.Key_Lett;
      out::populate( element:"terminator", value:value );
      ::terminatorservice2routine( d_term:d_term );
      ::mark2pragma( markable:"Terminator", pathkey: ::deployment_get_path( d_depl:d_depl, child:d_term.Name ) );
      // output the description
      ::Descrip2description( Descrip:d_term.Descrip );
      // end terminator
      out::populate( element:"terminator", value:emptyvalue );
    end if;
  end for;
  d_terms = d_terms - domain_terms;

  out::populate( element:"domain", value:emptyvalue );

end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("08d56b2b-9f8c-4589-8f5e-a20426a170c6",
	"43983355-f611-4bf0-9d00-99e26fa8f9a1",
	'd_terms',
	"3421e149-5a7b-4178-b56c-361b79b9cb7a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3421e149-5a7b-4178-b56c-361b79b9cb7a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Terminator>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Deployment/Deployment.xtuml');
INSERT INTO PE_PE
	VALUES ("43983355-f611-4bf0-9d00-99e26fa8f9a1",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("abbb4c9f-65a5-4b3c-b1a7-e28880ce5e9f",
	"00000000-0000-0000-0000-000000000000",
	'terminatorservice2routine',
	'',
	'd_term = param.d_term;

/* handle sequenced services in order */
select one d_tss related by d_term->D_TSS[R1658];
if(not_empty d_tss)
  select any d_sis related by d_tss->D_SIS[R1659];
  first_d_sis = d_sis;
  while(not_empty d_sis)
    first_d_sis = d_sis;
    select one d_sis related by d_sis->D_SIS[R1661.''succeeds''];
  end while;
  next_d_sis = first_d_sis;
  while(not_empty next_d_sis)
    select one d_tsvc related by next_d_sis->D_TSVC[R1660];
    ::populate_routine(d_tsvc: d_tsvc);
    select one next_d_sis related by next_d_sis->D_SIS[R1661.''precedes''];
  end while;
else
  select many d_tsvcs related by d_term->D_TSVC[R1651];
  for each d_tsvc in d_tsvcs
    ::populate_routine(d_tsvc: d_tsvc);
  end for;
end if;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("78fa69cc-b4a3-4096-8c8e-dfd3bfec570e",
	"abbb4c9f-65a5-4b3c-b1a7-e28880ce5e9f",
	'd_term',
	"1785e8e9-592a-437e-8ef6-2e2790ae5c07",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1785e8e9-592a-437e-8ef6-2e2790ae5c07",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Terminator>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Deployment/Deployment.xtuml');
INSERT INTO PE_PE
	VALUES ("abbb4c9f-65a5-4b3c-b1a7-e28880ce5e9f",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fdee5632-9f8b-49e6-9e3f-6cefdb66a6c1",
	"00000000-0000-0000-0000-000000000000",
	'parameterD_TSPARM2parameter',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

d_tsparm = param.d_tsparm;
if ( not_empty d_tsparm )
  value[0] = d_tsparm.Name;
  if ( 0 == d_tsparm.By_Ref )
    value[1] = "in";
  else
    value[1] = "out";
  end if;
  out::populate( element:"parameter", value:value );
  select one s_dt related by d_tsparm->S_DT[R1653];
  ::type2typeref( s_dt:s_dt, domain_pkg:param.domain_pkg );
  select one d_tsparm related by d_tsparm->D_TSPARM[R1654.''precedes''];
  ::parameterD_TSPARM2parameter( d_tsparm:d_tsparm, domain_pkg:param.domain_pkg );
  out::populate( element:"parameter", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e292df87-7c25-4bee-a4ca-508560143c19",
	"fdee5632-9f8b-49e6-9e3f-6cefdb66a6c1",
	'd_tsparm',
	"9b37fe9c-016a-4d0b-9d4f-2f9c00c4fdf1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9b37fe9c-016a-4d0b-9d4f-2f9c00c4fdf1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Terminator Service Parameter>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Deployment/Deployment.xtuml');
INSERT INTO S_SPARM
	VALUES ("50d7a834-8a77-4fac-b726-d4458f240124",
	"fdee5632-9f8b-49e6-9e3f-6cefdb66a6c1",
	'domain_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"e292df87-7c25-4bee-a4ca-508560143c19",
	'');
INSERT INTO PE_PE
	VALUES ("fdee5632-9f8b-49e6-9e3f-6cefdb66a6c1",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0c3443f0-4c27-4e4b-bdf3-8aeed98c603c",
	"00000000-0000-0000-0000-000000000000",
	'terminatorservice_getsignature',
	'',
	'd_tsvc = param.d_tsvc;

/**
 *  Return a string representation of this functions signature
 *  with the specified flavor
 *  0 = named parameters
 *  1 = positional parameters
 *  2 = signature with labels for content assist
 *  3 = signature without parameters for content assist
 *  named signature = return_type function(param1:type, param2:type, param3:type)
 *  parameters for the named flavor are sorted alphanumerically
 *  positional signature = return_type function(param1_type, param2_type, param3_type)
 */
 
signature = "";

if ( 2 != param.flavor and 3 != param.flavor )
  // Get return type
  select one returntype related by d_tsvc->S_DT[R1656];
  signature = signature + returntype.Name + " ";
end if;
 
// Get name
signature = signature + d_tsvc.Name;

// Get parameters

if ( 1 == param.flavor )

  // Get the first parameter.
  select any parameter related by d_tsvc->D_TSPARM[R1652];
  first_param = parameter;
  while ( not_empty parameter )
	first_param = parameter;
	select one parameter related by parameter->D_TSPARM[R1654.''succeeds''];
  end while;

  if( not_empty first_param )
	signature = signature + "(";
  end if;
  separator = "";
  parameter = first_param;
  while ( not_empty parameter )
	select one type related by parameter->S_DT[R1653];
	signature = signature + separator + type.Name;
	separator = " ";
	select one parameter related by parameter->D_TSPARM[R1654.''precedes''];
  end while;
  if( not_empty first_param )
	signature = signature + ")";
  end if;

elif ( 0 == param.flavor )

  // get the parameters in sorted order
  separator = "";
  select many parameters related by d_tsvc->D_TSPARM[R1652];
  num_params = cardinality parameters; 
  if ( num_params > 0 )
	signature = signature + "(";
  end if;

  // the following time complexity is n^2
  count = 0;
  select any last_param from instances of D_TSPARM where false;
  select any curr_param from instances of D_TSPARM where false;
  while ( count < num_params )
    for each parameter in parameters
      if ( ( empty curr_param and empty last_param )
           or ( empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name )
           or ( not_empty curr_param and empty last_param and parameter.Name < curr_param.Name )
           or ( not_empty curr_param and not_empty last_param and parameter != last_param and parameter.Name >= last_param.Name and parameter.Name < curr_param.Name ) )
        curr_param = parameter;
      end if;
    end for;
    
    select one type related by curr_param->S_DT[R1653];
    signature = signature + separator + curr_param.Name + ":" + type.Name;
    separator = " ";

    last_param = curr_param;
    select any curr_param from instances of D_TSPARM where false;
    count = count + 1;
  end while;

  if ( num_params > 0 )
	signature = signature + ")";
  end if;
  
elif ( 2 == param.flavor )

  // Get the first parameter.
  select any parameter related by d_tsvc->D_TSPARM[R1652];
  first_param = parameter;
  while ( not_empty parameter )
	first_param = parameter;
	select one parameter related by parameter->D_TSPARM[R1654.''succeeds''];
  end while;

  signature = signature + "(";
  separator = " ";
  parameter = first_param;
  while ( not_empty parameter )
    signature = signature + separator + parameter.Name + ":";
	separator = " ";
	select one parameter related by parameter->D_TSPARM[R1654.''precedes''];
  end while;
  if( not_empty first_param )
    signature = signature + " ";
  end if;
  signature = signature + ")";

elif ( 3 == param.flavor )

  signature = signature + "()";
  
end if;

return signature;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("41b34502-adf3-452e-9741-f72b77e44013",
	"0c3443f0-4c27-4e4b-bdf3-8aeed98c603c",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("4f4709ff-ffbe-4cb5-b24d-2688094acb3e",
	"0c3443f0-4c27-4e4b-bdf3-8aeed98c603c",
	'd_tsvc',
	"778a889a-58a1-43f7-bc1f-f3de2990fbf0",
	0,
	'',
	"41b34502-adf3-452e-9741-f72b77e44013",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("778a889a-58a1-43f7-bc1f-f3de2990fbf0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Terminator Service>',
	'',
	'',
	'../../../../../../mcooa/models/mcooa/ooaofooa/Deployment/Deployment.xtuml');
INSERT INTO PE_PE
	VALUES ("0c3443f0-4c27-4e4b-bdf3-8aeed98c603c",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("02e6a7fc-6fe8-4556-b24a-2b5b09c4940a",
	"00000000-0000-0000-0000-000000000000",
	'populate_routine',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

d_tsvc = param.d_tsvc;
select one d_term related by d_tsvc->D_TERM[R1651];

value[0] = d_term.Domain_Name;
value[1] = "";

select one d_depl related by d_term->D_DEPL[R1650];
if ( ImplementationScope::Domain == d_tsvc.Implementation_Scope )
  // A project can skip supplying a terminator service.''Domain'' scope means
  // the implementation was provided in the domain implementation
  //
  // If the terminator is sequenced we do not want to skip.
  // Implementation will be provided in the domain, but we
  // need reference to terminator signatures
  select one tss related by d_term->D_TSS[R1658];
  if(empty tss)
    return;
  end if;
end if;

value[2] = "public"; // Outbound messages are considered public.
value[3] = d_tsvc.Name;
value[4] = STRING::itoa(i:d_tsvc.Numb);
out::populate( element:"routine", value:value );

select any d_tsparm related by d_tsvc->D_TSPARM[R1652];
first_d_tsparm = d_tsparm;
while ( not_empty d_tsparm )
first_d_tsparm = d_tsparm;
select one d_tsparm related by d_tsparm->D_TSPARM[R1654.''succeeds''];
end while;
select one domain_package related by d_term->D_DEPL[R1650]->PE_PE[R8001]->EP_PKG[R8000];
::parameterD_TSPARM2parameter( d_tsparm:first_d_tsparm, domain_pkg:domain_package );
select one s_dt related by d_tsvc->S_DT[R1656];
::type2typeref( s_dt:s_dt, domain_pkg:domain_package );

// Populate the action langauge body.
if ( ( ActionDialect::masl == d_tsvc.Dialect ) or ( ActionDialect::asl == d_tsvc.Dialect ) )
::body2code_block( name:"", text:STRING::unescapetics(s:d_tsvc.Action_Semantics_internal) );
end if;

// Populate pragmas
child = d_term.Name + "::" + ::terminatorservice_getsignature( flavor:1, d_tsvc:d_tsvc );
::mark2pragma( markable:"Terminator Service", pathkey: ::deployment_get_path( d_depl:d_depl, child:child ) );

// output the description
::Descrip2description( Descrip:d_tsvc.Descrip );

out::populate( element:"routine", value:emptyvalue );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("d7a3564d-1580-46e9-aec6-3453c4050ce3",
	"02e6a7fc-6fe8-4556-b24a-2b5b09c4940a",
	'd_tsvc',
	"778a889a-58a1-43f7-bc1f-f3de2990fbf0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("02e6a7fc-6fe8-4556-b24a-2b5b09c4940a",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6e00d49c-26d3-4105-b7c0-d4014d4648bc",
	"00000000-0000-0000-0000-000000000000",
	'sequencedterminator2terminator',
	'',
	'/* sequenced terminators will be output in the proper order */
value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";

d_terms = param.d_terms;
if ( not_empty d_terms )

  // get any terminator
  select any any_term from instances of D_TERM where false;
  for each d_term in d_terms
    any_term = d_term;
    break;
  end for;

  select one d_depl related by any_term->D_DEPL[R1650];

  // populate the domain
  value[0] = any_term.Domain_Name;
  out::populate( element:"domain", value:value );
  
  for each d_term in d_terms
    select one d_depl related by d_term->D_DEPL[R1650];
    value[0] = d_term.Terminator_Name;
    out::populate( element:"terminator", value:value );
    ::terminatorservice2routine( d_term:d_term );
    ::mark2pragma( markable:"Terminator", pathkey: ::deployment_get_path( d_depl:d_depl, child:d_term.Name ) );
    // output the description
    ::Descrip2description( Descrip:d_term.Descrip );
    // end terminator
    out::populate( element:"terminator", value:emptyvalue );
  end for;

  out::populate( element:"domain", value:emptyvalue );

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("03aab62d-0f6a-4731-8047-32f72b931f8c",
	"6e00d49c-26d3-4105-b7c0-d4014d4648bc",
	'd_terms',
	"3421e149-5a7b-4178-b56c-361b79b9cb7a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("6e00d49c-26d3-4105-b7c0-d4014d4648bc",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b4884fcd-0aa8-4416-aae8-23e4556d99ad",
	"00000000-0000-0000-0000-000000000000",
	'type2type',
	'',
	'value[7] = ""; // initialize length
emptyvalue[7]=""; emptyvalue[6]=""; emptyvalue[5]=""; emptyvalue[4]=""; emptyvalue[3]=""; emptyvalue[2]=""; emptyvalue[1]=""; emptyvalue[0]="";
s_dt = param.s_dt;
i = param.i;

select one s_irdt related by s_dt->S_IRDT[R17];
// Do not output type definitions for instance reference data types.
if ( empty s_irdt )
  select one s_udt related by s_dt->S_UDT[R17];
  select one s_edt related by s_dt->S_EDT[R17];
  select one s_sdt related by s_dt->S_SDT[R17];

  value[0] = s_dt.Name;
  value[1] = "private";
  if ( 1 == i )
    value[1] = "public";
  end if;
  value[2] = "";
  
  if ( not_empty s_udt )
    // see what type the UDT is based on
    select one base_s_dt related by s_udt->S_DT[R18];
  
    // get body of type
    if ( s_udt.Definition != "" )
      // handle case where there is a definition
      value[2] = s_udt.Definition;
    else
      // There is no definition, use the underlying type.  If the underlying type
      // is MASLtype, treat this as a typeref and do not output it.  Otherwise
      // output using the underlying type as the definition.
      if not_empty base_s_dt
        if ( (base_s_dt.Name == "MASLtype") or (s_dt.Name == "MASLtype") )
          return;
        elif ( -1 < STRING::indexof( haystack:s_dt.Name, needle:" of " ) ) // blank-of-blank
          return;

        elif ( -1 < STRING::indexof( haystack:s_dt.Name, needle:"::" ) ) // domain scoped type reference
          ::type2type( s_dt:base_s_dt, i:i );
          return;

        else
          value[2] = base_s_dt.Name;
        end if;
      else
        TRACE::log( flavor:"warning", id:91, message:"No base type found for ''" + s_dt.Name + "''. Check that IPRs are allowed and prebuild is enabled." );
        return;
      end if;
    end if;
    out::populate( element:"type", value:value );
    select one s_range related by s_udt->S_RANGE[R57];
    if ( not_empty s_range )
      value[0] = s_range.Min;
      value[1] = s_range.Max;
      value[2] = "";
      out::populate( element:"range", value:value );
      out::populate( element:"range", value:emptyvalue );
    end if;
  elif ( not_empty s_edt )
    out::populate( element:"type", value:value );
    value[1] = "";
    value[2] = "";
    out::populate( element:"enumeration", value:value );
    select any s_enum from instances of S_ENUM where (false);
    // get to the first entry
    select any prev_s_enum related by s_edt->S_ENUM[R27];
    while (not_empty prev_s_enum)
      assign s_enum = prev_s_enum;
      select one prev_s_enum related by s_enum->S_ENUM[R56.''succeeds''];
    end while;
    // now iterate over the enumerators
    while (not_empty s_enum)
      value[0] = s_enum.Name;
      value[1] = "";
      value[2] = "";
      out::populate( element:"enumerator", value:value );
      out::populate( element:"enumerator", value:emptyvalue );
      select one s_enum related by s_enum->S_ENUM[R56.''precedes''];
    end while;
    out::populate( element:"enumeration", value:emptyvalue );
  elif ( not_empty s_sdt )
    out::populate( element:"type", value:value );
    value[1] = "";
    value[2] = "";
    out::populate( element:"structure", value:value );
    select any s_mbr from instances of S_MBR where (false);
    // get to the first entry
    select any prev_s_mbr related by s_sdt->S_MBR[R44];
    while (not_empty prev_s_mbr)
      assign s_mbr = prev_s_mbr;
      select one prev_s_mbr related by s_mbr->S_MBR[R46.''succeeds''];
    end while;
    // now iterate over the members
    while (not_empty s_mbr)
      value[0] = s_mbr.Name;
      value[1] = "";
      value[2] = "";
      out::populate( element:"member", value:value );
      select one mbr_s_dt related by s_mbr->S_DT[R45];
      select one ep_pkg related by mbr_s_dt->PE_PE[R8001]->EP_PKG[R8000];
      ::type2typeref( s_dt:mbr_s_dt, domain_pkg:ep_pkg );
      out::populate( element:"member", value:emptyvalue );
      select one s_mbr related by s_mbr->S_MBR[R46.''precedes''];
    end while;
    out::populate( element:"structure", value:emptyvalue );
  else
    return;
  end if;

  select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
  ::mark2pragma( markable:"User Data Type", pathkey: ::package_get_path( ep_pkg:ep_pkg, child: s_dt.Name ) );

  ::Descrip2description( Descrip:s_dt.Descrip );
  out::populate( element:"type", value:emptyvalue );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1b919e2e-918c-4f81-aee9-49b08e83b36a",
	"b4884fcd-0aa8-4416-aae8-23e4556d99ad",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5e8d4d18-9eb2-4a8e-a840-01aa7a238b03",
	"b4884fcd-0aa8-4416-aae8-23e4556d99ad",
	'i',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"1b919e2e-918c-4f81-aee9-49b08e83b36a",
	'');
INSERT INTO PE_PE
	VALUES ("b4884fcd-0aa8-4416-aae8-23e4556d99ad",
	1,
	"19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("19c98ca5-62e6-4d7e-957f-7c3645360e4e",
	1,
	"00000000-0000-0000-0000-000000000000",
	"22a3ee25-8b8c-4f5d-b9eb-0420268865dc",
	7);
INSERT INTO C_C_PROXY
	VALUES ("22a3ee25-8b8c-4f5d-b9eb-0420268865dc",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	'xtuml2masl',
	'',
	0,
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'',
	'../xtuml2masl.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("53107551-b0b9-4155-a13f-41b410f63a54",
	'maslout',
	1,
	'../../../maslout.xtuml');
