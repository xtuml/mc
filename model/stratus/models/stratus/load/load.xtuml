-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	"e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	'load',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	112,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'4.1.17',
	'stratus::load');
INSERT INTO GD_GE
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"d253fd26-846d-41fa-866d-36f9d01a0fa1",
	108,
	0,
	'stratus::load::selectors');
INSERT INTO GD_SHP
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO GD_NCS
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO DIM_GE
	VALUES (0.000000,
	0.000000,
	"434c8733-cf38-4a4d-b980-5478813c08be",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"cf20d32f-ee33-4e4b-856b-a86d23675ef0",
	108,
	0,
	'stratus::load::marking');
INSERT INTO GD_SHP
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO GD_NCS
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO DIM_GE
	VALUES (220.000000,
	0.000000,
	"c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"f2c7a380-21fe-4c0d-9f05-1bf86680e190",
	108,
	0,
	'stratus::load::ASL2MASL');
INSERT INTO GD_SHP
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12");
INSERT INTO GD_NCS
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12");
INSERT INTO DIM_ND
	VALUES (181.000000,
	97.000000,
	"cfd38096-8232-4756-8641-7c67eb94ea12");
INSERT INTO DIM_GE
	VALUES (12.000000,
	180.000000,
	"cfd38096-8232-4756-8641-7c67eb94ea12",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_DIA
	VALUES ("2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("2fa13145-0c97-4f52-b60b-01b9250b2b55",
	"00000000-0000-0000-0000-000000000000",
	'BuiltinType_populate',
	'',
	'create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "instance";
create object instance any_instance_type of AnyInstanceType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to any_instance_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "boolean";
create object instance boolean_type of BooleanType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to boolean_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "character";
create object instance character_type of CharacterType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to character_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "device";
create object instance device_type of DeviceType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to device_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "duration";
create object instance duration_type of DurationType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to duration_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "event";
create object instance event_type of MaslEventType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to event_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "string";
create object instance string_type of StringType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to string_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "timer";
create object instance timer_type of TimerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to timer_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "timestamp";
create object instance timestamp_type of TimestampType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to timestamp_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "wcharacter";
create object instance wcharacter_type of WCharacterType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to wcharacter_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "wstring";
create object instance wstring_type of WStringType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to wstring_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "real";
create object instance numeric_type of NumericType;
numeric_type.bits = 64;
numeric_type.signed = true;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance real_type of RealType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to real_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "long_integer";
create object instance numeric_type of NumericType;
numeric_type.bits = 64;
numeric_type.signed = true;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance integer_type of IntegerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to integer_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "byte";
create object instance numeric_type of NumericType;
numeric_type.bits = 8;
numeric_type.signed = false;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 255; // 2 ^ 8 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 0;
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance byte_type of ByteType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to byte_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "integer";
create object instance numeric_type of NumericType;
numeric_type.bits = 32;
numeric_type.signed = false;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 31 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // - 2 ^ 31 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance small_type of SmallIntegerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to small_type across R6221;

/* Comment out the logging if not desired.
 */
select many builtin_types from instances of BuiltinType where ( SORT::ascending( attr:"name" ) );
message = "builtin types:  ";
for each builtin_type in builtin_types
  message = message + builtin_type.name + " ";
end for;
LOG::LogInfo( message:message );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("2fa13145-0c97-4f52-b60b-01b9250b2b55",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	"00000000-0000-0000-0000-000000000000",
	'create_DotExpression',
	'',
	'lhs = param.lhs;
create object instance expression of MaslExpression;

select one lhs_basic_type related by lhs->BasicType[R5570];
if (empty lhs_basic_type)
  LOG::LogInfo(message:"create_DotExpression:  lhs has no type - " + param.name);
end if;

// TODO - provide subtyping maybe from DotExpression <- SelectedAttributeExpression, SelectedComponentExpression, TypeNameExpression, ObjectNameExpresion

// Look for class based operation access.
select one object_reference related by lhs->ObjectNameExpression[R5517];
if (not_empty object_reference)
  select many object_services related by object_reference->ObjectDeclaration[R5533]->ObjectService[R5808] where (not selected.isInstance);
  select any service related by object_services->Service[R5203] where (selected.name == param.name);
  if (not_empty service)
    create object instance call_expr of CallExpression;
    relate call_expr to expression across R5517;
		create object instance service_invocation of ServiceInvocation;
		relate service_invocation to call_expr across R5500;
		create object instance object_service_invocation of ObjectServiceInvocation;
		relate object_service_invocation to service_invocation across R5610;
		select one object_service related by service->ObjectService[R5203];
		relate object_service to object_service_invocation across R5613;
		select one basic_type related by service->BasicType[R5205];
		if (not_empty basic_type)
      relate basic_type to expression across R5570;
    end if;
    LOG::LogInfo(message:"create_DotExpression:  object service invocation:  " + param.name);
    return expression;
  end if;
end if;

// Look for attribute access.
select one instance_type related by lhs_basic_type->InstanceType[R6205];
if (not_empty instance_type)
  select any attribute_declaration related by instance_type->ObjectDeclaration[R6220]->AttributeDeclaration[R5802] where (selected.name == param.name);
  if (not_empty attribute_declaration)
    // create selected attribute expression
    create object instance selected_attribute_expression of SelectedAttributeExpression;
    relate lhs to selected_attribute_expression across R5569;
    relate selected_attribute_expression to expression across R5517;
    relate selected_attribute_expression to attribute_declaration across R5541;
    select one basic_type related by attribute_declaration->BasicType[R5803];
    relate basic_type to expression across R5570;
    LOG::LogInfo(message:"create_DotExpression:  attribute:  " + param.name);
    return expression;
  end if;
  // Look for instance operation access.
  select any service related by instance_type->ObjectDeclaration[R6220]->ObjectService[R5808]->Service[R5203] where (selected.name == param.name);
  if (not_empty service)
    create object instance call_expr of CallExpression;
    relate call_expr to expression across R5517;
		create object instance service_invocation of ServiceInvocation;
		relate service_invocation to call_expr across R5500;
		create object instance instance_service_invocation of InstanceServiceInvocation;
		relate instance_service_invocation to service_invocation across R5610;
		relate lhs to instance_service_invocation across R5615;
		select one object_service related by service->ObjectService[R5203];
		relate object_service to instance_service_invocation across R5614;
		select one basic_type related by service->BasicType[R5205];
		if (not_empty basic_type)
      relate basic_type to expression across R5570;
    end if;
    LOG::LogInfo(message:"create_DotExpression:  instance service invocation:  " + param.name);
    return expression;
  end if;
end if;
 
// Look for structure element.
select one structure_type related by lhs_basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
if (not_empty structure_type)
  select one structure_element related by structure_type->StructureElement[R6244];
  while (not_empty structure_element)
    if (param.name == structure_element.name)
      // create selected component expression
      create object instance selected_component_expression of SelectedComponentExpression;
      relate lhs to selected_component_expression across R5544;
      relate selected_component_expression to expression across R5517;
      relate selected_component_expression to structure_element across R5543;
      select one basic_type related by structure_element->BasicType[R6230];
      relate basic_type to expression across R5570;
      LOG::LogInfo(message:"create_DotExpression:  structure element:  " + param.name);
      return expression;
    end if;
    select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
  end while;
else
end if;

LOG::LogFailure(message:"create_DotExpression: failed to resolve dot expression: " + param.name);
return expression;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("8497859e-df75-4e8f-8b56-feeeb63e620c",
	"8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"45edb3d8-f5bc-43e5-ba45-c0fc8b5f3cdb",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	"00000000-0000-0000-0000-000000000000",
	'Name',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/Shared/Shared.xtuml');
INSERT INTO S_SPARM
	VALUES ("45edb3d8-f5bc-43e5-ba45-c0fc8b5f3cdb",
	"8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Expression>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	"00000000-0000-0000-0000-000000000000",
	'create_RelationshipSpecification',
	'',
	'relationship_declaration = param.relationship_declaration;
from_object_declaration = param.from_object_declaration;
to_object_declaration = param.to_object_declaration;
object_or_role = param.object_or_role;

// remove object_or_role if it is redundant
if (not_empty to_object_declaration and "" + to_object_declaration.name == object_or_role)
  object_or_role = "";
end if;

spec = "" + from_object_declaration.name + "->" + relationship_declaration.name;
if (object_or_role != "")
  spec = spec + "." + object_or_role;
end if;
if (not_empty to_object_declaration)
  spec = spec + "." + to_object_declaration.name;
end if;
LOG::LogInfo(message:"creating relationship spec: " + spec);

// Create the relationship specification
create object instance relationship_specification of RelationshipSpecification;
relate relationship_specification to relationship_declaration across R6015;
relate relationship_specification to from_object_declaration across R6014;


// Resolve when all information is provided.
if (not_empty to_object_declaration and object_or_role != "")
  
  // Fill out "to" object and role phrase
  relate relationship_specification to to_object_declaration across R6011;
  relationship_specification.role = object_or_role;

  // Find applicable half-relationship for binary and associative relationships.
  // Binary
	select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
	select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
	if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name and half_rel_1.role == object_or_role)
		LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
	select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
	if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name and half_rel_2.role == object_or_role)
		LOG::LogInfo(message: "normal rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;
	
	// Assoc
	select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
	select one from_object_1 related by half_rel_1->ObjectDeclaration[R6006];
	if (not_empty from_object_1 and from_object_1.name == from_object_declaration.name and half_rel_1.role == object_or_role)
		LOG::LogInfo(message: "assoc ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
	select one from_object_2 related by half_rel_2->ObjectDeclaration[R6006];
	if (not_empty from_object_2 and from_object_2.name == from_object_declaration.name and half_rel_2.role == object_or_role)
		LOG::LogInfo(message: "assoc rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;
	select one link_obj related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]
	  ->ObjectDeclaration[R6001] where selected.name == from_object_declaration.name;
	if (not_empty link_obj)  // from the associator to the one or other
		select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
		select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
		if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name and half_rel_1.role == object_or_role)
			LOG::LogInfo(message: "assoc ltr from " + to_object_declaration.name + "->" + to_object_declaration.name);
			relate relationship_specification to half_rel_1 across R6013;
			relationship_specification.multiplicity = half_rel_1.multiplicity;
			relationship_specification.conditional = half_rel_1.isconditional;
			return relationship_specification;
		end if;
		select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
		select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
		if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name and half_rel_2.role == object_or_role)
			LOG::LogInfo(message: "assoc rtl from " + to_object_declaration.name + "->" + to_object_declaration.name);
			relate relationship_specification to half_rel_2 across R6013;
			relationship_specification.multiplicity = half_rel_2.multiplicity;
			relationship_specification.conditional = half_rel_2.isconditional;
			return relationship_specification;
		end if;
	end if;
	
	// sub-super
  select one subsup related by relationship_declaration->SubtypeRelationshipDeclaration[R6010];
  if (not_empty subsup)
		relationship_specification.multiplicity = MaslMultiplicity::one;
		relationship_specification.conditional = false;
		return relationship_specification;
  end if;

// Resolve when the relationship name and either the object name or role phrase
// is provided but not both.
elif ((empty to_object_declaration and object_or_role != "") or
      (not_empty to_object_declaration and object_or_role == ""))
  if (empty to_object_declaration)
		select any to_object_declaration related by relationship_declaration->Domain[R6003]
			->ObjectDeclaration[R5805] where "" + selected.name == object_or_role;
  end if;

	// Resolve when only the relationship name and to object name are provided.
	// All non-reflexive binary and associative relationships and sub-super
	// relationships can be resolved with this information.
  if (not_empty to_object_declaration)
    if (to_object_declaration.name != from_object_declaration.name)

			// Fill out "to" object
			relate relationship_specification to to_object_declaration across R6011;

			// Find applicable half-relationship for binary and associative relationships.
			// Binary
			select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
			select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
			if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name)
				LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_1 across R6013;
				relationship_specification.multiplicity = half_rel_1.multiplicity;
				relationship_specification.conditional = half_rel_1.isconditional;
				relationship_specification.role = half_rel_1.role;
				return relationship_specification;
			end if;
			select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
			select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
			if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name)
				LOG::LogInfo(message: "normal rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_2 across R6013;
				relationship_specification.multiplicity = half_rel_2.multiplicity;
				relationship_specification.conditional = half_rel_2.isconditional;
				relationship_specification.role = half_rel_2.role;
				return relationship_specification;
			end if;
			
			// Assoc
			select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
			select one from_object_1 related by half_rel_1->ObjectDeclaration[R6006];
			if (not_empty from_object_1 and from_object_1.name == from_object_declaration.name)
				LOG::LogInfo(message: "assoc ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_1 across R6013;
				relationship_specification.multiplicity = half_rel_1.multiplicity;
				relationship_specification.conditional = half_rel_1.isconditional;
				relationship_specification.role = half_rel_1.role;
				return relationship_specification;
			end if;
			select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
			select one from_object_2 related by half_rel_2->ObjectDeclaration[R6006];
			if (not_empty from_object_2 and from_object_2.name == from_object_declaration.name)
				LOG::LogInfo(message: "assoc rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_2 across R6013;
				relationship_specification.multiplicity = half_rel_2.multiplicity;
				relationship_specification.conditional = half_rel_2.isconditional;
				relationship_specification.role = half_rel_2.role;
				return relationship_specification;
			end if;
			select one link_obj related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]
				->ObjectDeclaration[R6001] where selected.name == from_object_declaration.name;
			if (not_empty link_obj)  // from the associator to the one or other
				select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
				select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
				if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name)
					LOG::LogInfo(message: "assoc ltr from " + to_object_declaration.name + "->" + to_object_declaration.name);
					relate relationship_specification to half_rel_1 across R6013;
					relationship_specification.multiplicity = half_rel_1.multiplicity;
					relationship_specification.conditional = half_rel_1.isconditional;
					relationship_specification.role = half_rel_1.role;
					return relationship_specification;
				end if;
				select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
				select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
				if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name)
					LOG::LogInfo(message: "assoc rtl from " + to_object_declaration.name + "->" + to_object_declaration.name);
					relate relationship_specification to half_rel_2 across R6013;
					relationship_specification.multiplicity = half_rel_2.multiplicity;
					relationship_specification.conditional = half_rel_2.isconditional;
					relationship_specification.role = half_rel_2.role;
					return relationship_specification;
				end if;
			end if;
			
			// sub-super
			select one subsup related by relationship_declaration->SubtypeRelationshipDeclaration[R6010];
			if (not_empty subsup)
				relationship_specification.multiplicity = MaslMultiplicity::one;
				relationship_specification.conditional = false;
				relationship_specification.role = "is_a";
				return relationship_specification;
			end if;

		end if;
    
	// Resolve when only the relationship name and role phrase are provided.
	// Only binary relationships can be resolved with this information.
  else
    
	  relationship_specification.role = object_or_role;

		// normal binary
		select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007]
		  where selected.role == object_or_role;
		select one object_declaration related by half_rel_1->ObjectDeclaration[R6004];
		if (not_empty object_declaration)
			LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + object_declaration.name);
			relate relationship_specification to half_rel_1 across R6013;
			relate relationship_specification to object_declaration across R6011;
			relationship_specification.multiplicity = half_rel_1.multiplicity;
			relationship_specification.conditional = half_rel_1.isconditional;
			return relationship_specification;
		end if;
		select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008]
		  where selected.role == object_or_role;
		select one object_declaration related by half_rel_2->ObjectDeclaration[R6004];
		if (not_empty object_declaration)
			LOG::LogInfo(message: "normal rtl to " + from_object_declaration.name + "->" + object_declaration.name);
			relate relationship_specification to half_rel_2 across R6013;
			relate relationship_specification to object_declaration across R6011;
			relationship_specification.multiplicity = half_rel_2.multiplicity;
			relationship_specification.conditional = half_rel_2.isconditional;
			return relationship_specification;
		end if;
		
		// TODO from link class to one or other

  end if;
  
// Resolve when only relationship name provided.
// Only non-reflexive binary associations and sub->supertype associations can be
// resolved with this little information.
elif (empty to_object_declaration and object_or_role == "")

	// normal binary non-reflexive
	select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
	select one object_declaration related by half_rel_1->ObjectDeclaration[R6004];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
	  relationship_specification.role = half_rel_1.role;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
	select one object_declaration related by half_rel_2->ObjectDeclaration[R6004];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "normal rtl to " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
	  relationship_specification.role = half_rel_2.role;
		return relationship_specification;
	end if;

	// supertype
	select one object_declaration related by relationship_declaration->SubtypeRelationshipDeclaration[R6010]->ObjectDeclaration[R6017];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "sub-super supertype " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = MaslMultiplicity::one;
		relationship_specification.conditional = false;
	  relationship_specification.role = "is_a";
		return relationship_specification;
	end if;

end if;

LOG::LogFailure(message:"Failed to resolve relationship specification");
return relationship_specification;',
	"47e32455-be33-4b7c-9e44-d3b8f4f9ad39",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("01c2ac2c-dccd-4eed-99b4-a6caef76d43c",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'from_object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"08bc443f-7e24-4cb7-8e8d-0e99e8bb8fc9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ccbbc697-c60c-4034-8e31-7a46032151eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ObjectDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("08bc443f-7e24-4cb7-8e8d-0e99e8bb8fc9",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'relationship_declaration',
	"fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("d7a813ed-b8ed-4aa3-afc3-5e9ddec62d42",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'object_or_role',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"01c2ac2c-dccd-4eed-99b4-a6caef76d43c",
	'');
INSERT INTO S_SPARM
	VALUES ("21e7b6d3-c7be-4951-9e8b-1a7ad83d3d2a",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'to_object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"d7a813ed-b8ed-4aa3-afc3-5e9ddec62d42",
	'');
INSERT INTO PE_PE
	VALUES ("090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("47e32455-be33-4b7c-9e44-d3b8f4f9ad39",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipSpecification>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SYNC
	VALUES ("646d0520-59e0-4335-b11f-e59c46fc675c",
	"00000000-0000-0000-0000-000000000000",
	'InternalType_populate',
	'',
	'create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "characteristic";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "enum";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "object";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "service";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "split";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "stream_modifier";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "terminator";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "type";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

/* Comment out the logging if not desired.
 */
select many internal_types from instances of InternalType where ( SORT::ascending( attr:"name" ) );
message = "internal types:  ";
for each internal_type in internal_types
  message = message + internal_type.name + " ";
end for;
LOG::LogInfo( message:message );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("646d0520-59e0-4335-b11f-e59c46fc675c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	"00000000-0000-0000-0000-000000000000",
	'OrderingExpression_initialize',
	'',
	'child_expression = param.child_expression;

create object instance expr of MaslExpression;

create object instance ordering_expression of OrderingExpression;
relate ordering_expression to expr across R5517;
ordering_expression.isreverse = param.isreverse;
relate ordering_expression to child_expression across R5535;

// Determine whether we have structures or instances.
select one child_basic_type related by child_expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
select one instance_type related by child_basic_type->InstanceType[R6205];
if ( not_empty instance_type )
  // We have a collection of instances.
  create object instance instance_ordering_expression of InstanceOrderingExpression;
  relate instance_ordering_expression to ordering_expression across R5534;
else
  // We have a collection of structures
  create object instance structure_ordering_expression of StructureOrderingExpression;
  relate structure_ordering_expression to ordering_expression across R5534;
end if;

// Find or create an anonymous sequence of the same element as the child expression.
select any basic_type related by child_basic_type->CollectionType[R6208]->SequenceType[R6207]->CollectionType[R6207]->BasicType[R6205];
if empty basic_type
  create object instance type_definition of TypeDefinition;
  create object instance basic_type of BasicType;
  basic_type.isanonymous = true;
  create object instance collection_type of CollectionType;
  create object instance sequence_type of SequenceType;
  relate basic_type to type_definition across R6236;
  relate collection_type to basic_type across R6205;
  relate sequence_type to collection_type across R6207;
  relate collection_type to child_basic_type across R6208;
end if;

relate basic_type to expr across R5570;

return expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("88d37daf-bb85-43d0-8d37-5a7979ca6cc0",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'child_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("98ec35b4-1347-4a64-a5a6-e3bc8505da11",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'isreverse',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"88d37daf-bb85-43d0-8d37-5a7979ca6cc0",
	'');
INSERT INTO PE_PE
	VALUES ("ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("20183b0e-40fc-465f-94b7-5494d92bc624",
	"00000000-0000-0000-0000-000000000000",
	'OrderingExpression_sort',
	'',
	'expression = param.expression;

select one child_basic_type related by expression->OrderingExpression[R5517]->MaslExpression[R5535]->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
select one instance_ordering_expression related by expression->OrderingExpression[R5517]->InstanceOrderingExpression[R5534];
if ( not_empty instance_ordering_expression )
  select one instance_type related by child_basic_type->InstanceType[R6205];
  select one object_declaration related by instance_type->ObjectDeclaration[R6220];
  select any attribute_declaration related by object_declaration->AttributeDeclaration[R5802] where ( selected.name == param.name );
  if ( not_empty attribute_declaration )
    create object instance key of AttributeOrderingKey;
    key.order = param.index;
    key.isreverse = param.isreverse;
    relate attribute_declaration to instance_ordering_expression across R5563 using key;
  end if;
else
  select one structure_ordering_expression related by expression->OrderingExpression[R5517]->StructureOrderingExpression[R5534];
  select one structure_type related by child_basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
  select one structure_element related by structure_type->StructureElement[R6244];
  while ( not_empty structure_element )
    if ( structure_element.name == param.name )
      create object instance key of StructureElementOrderingKey;
      key.order = param.index;
      key.isreverse = param.isreverse;
      relate structure_element to structure_ordering_expression across R5564 using key;
      break;
    end if;
    select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
  end while;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("120e9147-178e-45ac-8fb9-475ad8821729",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("df97b1a7-79bb-468e-9dc2-dade0205c464",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"120e9147-178e-45ac-8fb9-475ad8821729",
	'');
INSERT INTO S_SPARM
	VALUES ("616cebf9-3b36-4725-86b0-49abb45c5ede",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'isreverse',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"df97b1a7-79bb-468e-9dc2-dade0205c464",
	'');
INSERT INTO S_SPARM
	VALUES ("c2cf44e3-bdae-4707-a7ae-6edd2394f6aa",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"616cebf9-3b36-4725-86b0-49abb45c5ede",
	'');
INSERT INTO PE_PE
	VALUES ("20183b0e-40fc-465f-94b7-5494d92bc624",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("90e0a8bb-2227-4ea2-a3cd-74317453fb69",
	"00000000-0000-0000-0000-000000000000",
	'ReferentialAttribute_resolve',
	'',
	'// Link up the referential attributes here after all objects and attributes
// are fully defined.  During the first pass, the referentials were linked
// to themselves.

LOG::LogInfo( message:"RerentialAttribute_resolve starting..." );

o_referring = ""; o_referenced = ""; // string UDTs
select many referential_attribute_definitions from instances of ReferentialAttributeDefinition;
for each referential_attribute_definition in referential_attribute_definitions
  select one referring_attribute_declaration related by referential_attribute_definition->AttributeDeclaration[R5800.''is_referenced_by''];
  select one referring_object_declaration related by referring_attribute_declaration->ObjectDeclaration[R5802];
  o_referring = referring_object_declaration.name;
  o_referring = o_referring + "." + referential_attribute_definition.name;
  unrelate referring_attribute_declaration from referring_attribute_declaration across R5800.''refers_to'' using referential_attribute_definition;
  select any referenced_attribute_declaration related by
    referential_attribute_definition->RelationshipSpecification[R5811]->ObjectDeclaration[R6011]->AttributeDeclaration[R5802]
    where ( selected.name == referential_attribute_definition.name );
  if ( empty referenced_attribute_declaration )
    LOG::LogFailure( message:"RerentialAttribute_resolve failed to find referenced attribute:  " + referential_attribute_definition.name );
  else
    select one referenced_object_declaration related by referenced_attribute_declaration->ObjectDeclaration[R5802];
    o_referenced = referenced_object_declaration.name;
    o_referenced = o_referenced + "." + referenced_attribute_declaration.name;
    relate referring_attribute_declaration to referenced_attribute_declaration across R5800.''refers_to'' using referential_attribute_definition;
    LOG::LogInfo( message:"RerentialAttribute_resolve " + o_referring + " to " + o_referenced );
  end if;
end for;

LOG::LogInfo( message:"RerentialAttribute_resolve ...done" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("90e0a8bb-2227-4ea2-a3cd-74317453fb69",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("833efa7d-504f-41aa-86e3-501de92ef97c",
	"00000000-0000-0000-0000-000000000000",
	'relate_ObjectDeclaration_to_Domain',
	'',
	'// relate the two, but not if already related
object_declaration = param.object_declaration;
if not_empty object_declaration
  select one domain related by object_declaration->Domain[R5805];
  if empty domain
    domain = param.domain;
    relate object_declaration to domain across R5805;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	1);
INSERT INTO S_SPARM
	VALUES ("a99c4e53-1924-4627-afe7-b9f6789f1cf7",
	"833efa7d-504f-41aa-86e3-501de92ef97c",
	'object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("154560e5-f3ab-469e-bc56-a2022769b696",
	"833efa7d-504f-41aa-86e3-501de92ef97c",
	'domain',
	"d467079c-c61e-4b05-8498-3fe2f24782a6",
	0,
	'',
	"a99c4e53-1924-4627-afe7-b9f6789f1cf7",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d467079c-c61e-4b05-8498-3fe2f24782a6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Domain>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO PE_PE
	VALUES ("833efa7d-504f-41aa-86e3-501de92ef97c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("183c6254-c6e2-4d4e-a5f3-5011775222ab",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NameExpression',
	'',
	'select any domain from instances of Domain where selected.name == param.domain_name;
root_code_block = ::select_CodeBlock_root( code_block:param.current_block );

::trace(i:0,s:"RESOLVING name: ''" + param.name + "''");
// search for local variable reference
// Notice that ASL has one scope for all local variables.  It is the root CodeBlock of the activity.
select any var related by root_code_block->VariableDefinition[R5151] where (selected.name == param.name);
if (not_empty var)
  // create a new variable reference
  create object instance expr of MaslExpression;
  select one type related by var->BasicType[R5137];
  relate type to expr across R5570;
  create object instance var_ref of VariableNameExpression;
  relate var_ref to expr across R5517;
  relate var_ref to var across R5562;
  ::trace(i:1,s:"resolved name [variable]: ''" + param.name + "''");
  return expr;
end if;

// search for parameter reference
select one current_service related by root_code_block->Service[R5403];
select one current_state related by root_code_block->MaslState[R6115];
select any ref_param from instances of ParameterDefinition where false;
select one service_param related by current_service->ParameterDefinition[R5204];
while (not_empty service_param and empty ref_param)
  if (service_param.name == param.name)
    ref_param = service_param;
  end if;
  select one service_param related by service_param->ParameterDefinition[R5208.''precedes''];
end while;
select one state_param related by current_state->ParameterDefinition[R6104];
while (not_empty state_param and empty ref_param)
  if (state_param.name == param.name)
    ref_param = state_param;
  end if;
  select one state_param related by state_param->ParameterDefinition[R5208.''precedes''];
end while;
if (not_empty ref_param)
  create object instance expr of MaslExpression;
  create object instance param_ref of ParameterNameExpression;
  relate param_ref to expr across R5517;
  relate ref_param to param_ref across R5536;
  select one type related by ref_param->BasicType[R5200];
  relate type to expr across R5570;
  LOG::LogInfo(message:"resolved name [parameter]: ''" + param.name + "''");
  return expr;
end if;

// search for literal enumerators
select any enumer related by domain->MaslUserDefinedType[R6235]->TypeDeclaration[R6241]->TypeDefinition[R6234]
  ->FullTypeDefinition[R6236]->EnumerateType[R6219]->EnumerateItem[R6245] where selected.name == param.name;
if not_empty enumer
  create object instance expr of MaslExpression;
  select any type related by enumer->EnumerateType[R6245]->FullTypeDefinition[R6219]->TypeDefinition[R6236]
    ->TypeDeclaration[R6234]->MaslUserDefinedType[R6241]->BasicType[R6205];
  relate type to expr across R5570;
  create object instance literal_expr of LiteralExpression;
  relate literal_expr to expr across R5517;
  create object instance enum_expr of EnumerateLiteral;
  relate enum_expr to literal_expr across R5700;
  relate enumer to enum_expr across R5701;
  LOG::LogInfo(message:"resolved name [enumerator]: ''" + param.domain_name + "::" + param.name + "''");
  return expr;
end if;

// search for domain service reference
if ( "" != param.scope )
select any service related by domain->DomainService[R5303]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  else
    // ASL-specific, find out parameter to serve as call_expression type
    select one parameter_definition related by service->ParameterDefinition[R5204];
    while (not_empty parameter_definition)
      if ( parameter_definition.mode == ParameterMode::out )
        select one type related by parameter_definition->BasicType[R5200];
        if (not_empty type)
          relate type to expr across R5570;
          break;
        end if;
      end if;
      select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
    end while;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance domain_service_invocation of DomainServiceInvocation;
  relate domain_service_invocation to service_invocation across R5610;
  select one domain_service related by service->DomainService[R5203];
  relate domain_service to domain_service_invocation across R5611;
  LOG::LogInfo(message:"resolved name [domain service]: ''" + param.domain_name + "::" + param.name + "''");
  return expr;
end if;
end if;

// search for objects
select any object_declaration related by domain->ObjectDeclaration[R5805] where selected.name == param.name;
if (not_empty object_declaration)
  create object instance expr of MaslExpression;
  create object instance obj_name_expr of ObjectNameExpression;
  relate obj_name_expr to expr across R5517;
  relate object_declaration to obj_name_expr across R5533;
  type = ::select_create_InstanceType(object_declaration:object_declaration, isset:true);
  relate type to expr across R5570;
  LOG::LogInfo(message:"resolved name [object]: ''" + param.domain_name + "::" + param.name + "''");
  return expr;
end if;

// search for terminator service reference
if ( ":" == param.scope )
select any service related by domain->DomainTerminator[R5304]->DomainTerminatorService[R5306]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  else
    // ASL-specific, find out parameter to serve as call_expression type
    select one parameter_definition related by service->ParameterDefinition[R5204];
    while (not_empty parameter_definition)
      if ( parameter_definition.mode == ParameterMode::out )
        select one type related by parameter_definition->BasicType[R5200];
        if (not_empty type)
          relate type to expr across R5570;
          break;
        end if;
      end if;
      select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
    end while;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance terminator_service_invocation of TerminatorServiceInvocation;
  relate terminator_service_invocation to service_invocation across R5610;
  select one terminator_service related by service->DomainTerminatorService[R5203];
  relate terminator_service to terminator_service_invocation across R5612;
  LOG::LogInfo(message:"resolved name [terminator service]: ''" + param.domain_name + "::" + param.name + "'' with key_letters:" + param.base_name);
  return expr;
end if;
// search for object service reference
select any service related by domain->ObjectDeclaration[R5805]->ObjectService[R5808]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  else
    // ASL-specific, find out parameter to serve as call_expression type
    select one parameter_definition related by service->ParameterDefinition[R5204];
    while (not_empty parameter_definition)
      if ( parameter_definition.mode == ParameterMode::out )
        select one type related by parameter_definition->BasicType[R5200];
        if (not_empty type)
          relate type to expr across R5570;
          break;
        end if;
      end if;
      select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
    end while;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance object_service_invocation of ObjectServiceInvocation;
  relate object_service_invocation to service_invocation across R5610;
  select one object_service related by service->ObjectService[R5203];
  relate object_service to object_service_invocation across R5613;
  LOG::LogInfo(message:"resolved name [object service]: ''" + param.domain_name + "::" + param.name + "'' with key_letters:" + param.base_name);
  return expr;
end if;
end if;

// search for types (for characteristics and type casting)
select any builtin from instances of BuiltinType where selected.name == param.name;
select one basic_type related by builtin->BasicType[R6205];
if empty basic_type
  select any udt related by domain->MaslUserDefinedType[R6235] where selected.name == param.name;
  select one basic_type related by udt->BasicType[R6205];
end if;
if not_empty basic_type
  // create a new type type name expression
  create object instance expr of MaslExpression;
  relate basic_type to expr across R5570;
  create object instance type_name_expr of TypeNameExpression;
  relate type_name_expr to expr across R5517;
  relate basic_type to type_name_expr across R5578;
  log_name = param.name;
  if empty builtin
    log_name = param.domain_name + "::" + log_name;
  end if;
  LOG::LogInfo(message:"resolved name [type reference]: ''" + log_name + "''");
  return expr;
end if;

LOG::LogFailure(message:"Could not resolve name expression: " + param.domain_name + ", " + param.name);
//select any expr from instances of MaslExpression where false;
//return expr;

create object instance var of VariableDefinition;
var.name = param.name;
var.isreadonly = false;
// ASL has a flat scope for activities.  Relate to outer level CodeBlock.
relate var to root_code_block across R5151;
// create a new variable reference
create object instance expr of MaslExpression;
// Relate to a random type for now.  This will get changed in Assignment and LoopSpec.
select any builtin_type from instances of BuiltinType;
select one type related by builtin_type->BasicType[R6205];
relate type to var across R5137;
relate type to expr across R5570;
create object instance var_ref of VariableNameExpression;
relate var_ref to expr across R5517;
relate var_ref to var across R5562;
LOG::LogInfo(message:"created variable and resolved name [variable]: ''" + param.name + "''");
return expr;
',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	2);
INSERT INTO S_SPARM
	VALUES ("fedc6e46-b6f0-48ac-9833-caf14c14d63e",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'domain_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("36951a0f-4c2a-4b7c-b397-52e2fb563a44",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"fedc6e46-b6f0-48ac-9833-caf14c14d63e",
	'');
INSERT INTO S_SPARM
	VALUES ("e71e8b02-8ca0-473b-b978-25e75c6c8e28",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'current_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"36951a0f-4c2a-4b7c-b397-52e2fb563a44",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<CodeBlock>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("0a53e771-8261-4c53-80ee-3a0fc2c4242d",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'scope',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e71e8b02-8ca0-473b-b978-25e75c6c8e28",
	'');
INSERT INTO S_SPARM
	VALUES ("ccd94894-5ff5-4bd2-a57a-d795cb861033",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'base_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0a53e771-8261-4c53-80ee-3a0fc2c4242d",
	'');
INSERT INTO S_SPARM
	VALUES ("4cc1bb9e-271f-4ee3-982a-f35bd469bbcf",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ccd94894-5ff5-4bd2-a57a-d795cb861033",
	'');
INSERT INTO PE_PE
	VALUES ("183c6254-c6e2-4d4e-a5f3-5011775222ab",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	"00000000-0000-0000-0000-000000000000",
	'resolve_BinaryExpression_type',
	'',
	'expression = param.expression;
select one binary related by expression->BinaryExpression[R5517];
lhs = param.lhs;
rhs = param.rhs;

select one l_type related by lhs->BasicType[R5570];
select one r_type related by rhs->BasicType[R5570];
select one l_builtin related by l_type->BuiltinType[R6205];
select one l_numeric related by l_builtin->NumericType[R6206];
select one r_builtin related by r_type->BuiltinType[R6205];
select one r_numeric related by r_builtin->NumericType[R6206];

// default to using the type of the left-hand-side
binary_type = l_type;

// handle numeric types
if (not_empty l_numeric and not_empty r_numeric)
  // if either of the types is real, promot to real otherwise take the left type
  // only need to check the right-hand-side since LHS is the default
  select one r_builtin related by r_numeric->BuiltinType[R6206];
  if ("" + r_builtin.name == "real")
    binary_type = r_type;
  end if;
end if;

// comparison and logical binary expressions are always boolean
select one comp_binary related by expression->BinaryExpression[R5517]->BinaryComparisonExpression[R5000];
select one logical_binary related by expression->BinaryExpression[R5517]->BinaryLogicalExpression[R5000];
if (not_empty comp_binary or not_empty logical_binary)
  select any bool_type from instances of BuiltinType where "" + selected.name == "boolean";
  select one binary_type related by bool_type->BasicType[R6205];
end if;

// Time arithmetic
if not_empty l_builtin and not_empty r_builtin
  select any timestamp_type from instances of BuiltinType where "" + selected.name == "timestamp";
  select any duration_type from instances of BuiltinType where "" + selected.name == "duration";

  if "" + l_builtin.name == "timestamp"
    // timestamp + duration = timestamp
    if binary.operator == Operator::plus and "" + r_builtin.name == "duration"
      select one binary_type related by timestamp_type->BasicType[R6205];
    // timestamp - duration = timestamp
    elif binary.operator == Operator::minus and "" + r_builtin.name == "duration"
      select one binary_type related by timestamp_type->BasicType[R6205];
    // timetamp - timestamp = duration
    elif binary.operator == Operator::minus and "" + r_builtin.name == "timestamp"
      select one binary_type related by duration_type->BasicType[R6205];
    end if;
  end if;
  
  if "" + l_builtin.name == "duration"
    // duration + timestamp = timestamp
    if binary.operator == Operator::plus and "" + r_builtin.name == "timestamp"
      select one binary_type related by timestamp_type->BasicType[R6205];
    // duration + duration = duration
    elif binary.operator == Operator::plus and "" + r_builtin.name == "duration"
      select one binary_type related by duration_type->BasicType[R6205];
    // duration - duration = duration
    elif binary.operator == Operator::minus and "" + r_builtin.name == "duration"
      select one binary_type related by duration_type->BasicType[R6205];
    // duration * numeric = duration
    elif binary.operator == Operator::times
      select one binary_type related by duration_type->BasicType[R6205];
    // duration / numeric = duration
    elif binary.operator == Operator::divide
      select one binary_type related by duration_type->BasicType[R6205];
    end if;
  end if;

end if;

// ASL correlated navigation uses _and_ to combine instances to the associative on the RHS.
select one instance_type related by r_type->InstanceType[R6205];
if ( not_empty instance_type )
  binary_type = r_type;
  select one object_declaration related by instance_type->ObjectDeclaration[R6220.''references''];
else
  select one basic_type related by r_type->CollectionType[R6205]->BasicType[R6208];
  if ( not_empty basic_type )
    binary_type = basic_type;
  end if;
end if;

// type the expression
relate binary_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("7afdb7d5-027f-4100-8b8a-950b3e27acc9",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c56f0b39-1c44-413d-85b5-dbd10fc56088",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"7afdb7d5-027f-4100-8b8a-950b3e27acc9",
	'');
INSERT INTO S_SPARM
	VALUES ("3dd22e06-404d-462b-9415-49dab59f2fb9",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'rhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"c56f0b39-1c44-413d-85b5-dbd10fc56088",
	'');
INSERT INTO PE_PE
	VALUES ("a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	"00000000-0000-0000-0000-000000000000",
	'resolve_Expression_ArgumentList',
	'',
	'expression = param.expression;
first_argument = param.first_argument;
 
select one call_expr related by expression->CallExpression[R5517];

// if this is a type name expression, perform a subtype migration to convert to
// a cast expression
select one type_name_expr related by expression->TypeNameExpression[R5517];
if not_empty type_name_expr
  select one basic_type related by type_name_expr->BasicType[R5578];
  // unhook and dispose the type name expression
  unrelate basic_type from type_name_expr across R5578;
  unrelate type_name_expr from expression across R5517;
  delete object instance type_name_expr;
  // create the cast expression
  create object instance call_expr of CallExpression;
  relate call_expr to expression across R5517;
  create object instance cast of CastExpression;
  relate cast to call_expr across R5500;
  relate basic_type to cast across R5501;
end if;

// link the first argument to the call expression
if not_empty call_expr and not_empty first_argument
  relate first_argument to call_expr across R5575;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	4);
INSERT INTO S_SPARM
	VALUES ("c02182a4-29f3-4906-bd55-fa851fcdcf28",
	"9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("372c7571-e9e3-4168-8e25-633579955a66",
	"9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	'first_argument',
	"55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	0,
	'',
	"c02182a4-29f3-4906-bd55-fa851fcdcf28",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Argument>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("93010171-646f-4498-b423-fab780cdb6fe",
	"00000000-0000-0000-0000-000000000000",
	'resolve_ServiceCall',
	'',
	'service_call = param.service_call;
expression = param.expression;
select one service_invocation related by expression->CallExpression[R5517]->ServiceInvocation[R5500];
if (not_empty service_call and not_empty service_invocation)
  relate service_call to service_invocation across R5161;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	5);
INSERT INTO S_SPARM
	VALUES ("4ef35007-2a43-4084-94b6-4480118d5d51",
	"93010171-646f-4498-b423-fab780cdb6fe",
	'service_call',
	"9e1e8ee5-e6f9-48b8-a8f3-324c684cde30",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9e1e8ee5-e6f9-48b8-a8f3-324c684cde30",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ServiceCall>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("bbbf6b59-e897-4a66-858b-0fb595d578e8",
	"93010171-646f-4498-b423-fab780cdb6fe",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"4ef35007-2a43-4084-94b6-4480118d5d51",
	'');
INSERT INTO PE_PE
	VALUES ("93010171-646f-4498-b423-fab780cdb6fe",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dafc5a91-48fd-4fcd-961a-350711f96eaf",
	"00000000-0000-0000-0000-000000000000",
	'resolve_TerminatorServiceInvocation',
	'',
	'expression = param.terminator_service_expression;
service_name = param.service_name;

// gather info
select one terminator_service_invocation related by expression->CallExpression[R5517]->ServiceInvocation[R5500]->TerminatorServiceInvocation[R5610];
select one existing_terminator_service related by terminator_service_invocation->DomainTerminatorService[R5612];
select any service related by existing_terminator_service->DomainTerminator[R5306]->DomainTerminatorService[R5306]->Service[R5203] where selected.name == service_name;
if (not_empty service)
	select one new_terminator_service related by service->DomainTerminatorService[R5203];

	// unlink and link the terminator service
	if existing_terminator_service != new_terminator_service
		unrelate existing_terminator_service from terminator_service_invocation across R5612;
		relate new_terminator_service to terminator_service_invocation across R5612;
	end if;

	// link the type to the expression
	select one type related by service->BasicType[R5205];
	if (not_empty type)
		relate type to expression across R5570;
	end if;

else
  LOG::LogFailure(message:"Failed to resolve terminator service");
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	6);
INSERT INTO S_SPARM
	VALUES ("5553823a-ad3a-4fec-bdc0-9f7b728f8903",
	"dafc5a91-48fd-4fcd-961a-350711f96eaf",
	'terminator_service_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0cfc70d6-e1ce-4570-b7ed-fadc2bbe88bf",
	"dafc5a91-48fd-4fcd-961a-350711f96eaf",
	'service_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"5553823a-ad3a-4fec-bdc0-9f7b728f8903",
	'');
INSERT INTO PE_PE
	VALUES ("dafc5a91-48fd-4fcd-961a-350711f96eaf",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("52644604-406b-4908-8eec-87492d918120",
	"00000000-0000-0000-0000-000000000000",
	'resolve_FindExpression_type',
	'',
	'expression = param.expression;
select one find_expression related by expression->FindExpression[R5517];
if (not_empty find_expression)
  // for now, assume the root expression is a set
  select one root_type related by find_expression->MaslExpression[R5519]->BasicType[R5570];
  if find_expression.flavor == FindType::find
    relate root_type to expression across R5570;
  elif (find_expression.flavor == FindType::find_one or find_expression.flavor == FindType::find_only)
    select one root_single_type related by root_type->CollectionType[R6205]->BasicType[R6208];
    relate root_single_type to expression across R5570;
  else
    // default to set for ASL find-all
    relate root_type to expression across R5570;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("571e0577-84d0-458a-a437-c456b85fe7f1",
	"52644604-406b-4908-8eec-87492d918120",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("52644604-406b-4908-8eec-87492d918120",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("01643d70-2092-460d-856a-f4ddca302cc7",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NavigationExpression',
	'',
	'expression = param.expression;
select one rel_spec related by expression->NavigationExpression[R5517]->RelationshipSpecification[R5531];
select one lhs_collection related by expression->NavigationExpression[R5517]->MaslExpression[R5532]->BasicType[R5570]->CollectionType[R6205];
select one to_obj_decl related by rel_spec->ObjectDeclaration[R6011];
select one from_obj related by rel_spec->ObjectDeclaration[R6014];
select one using_obj related by rel_spec->RelationshipDeclaration[R6015]->AssociativeRelationshipDeclaration[R6010]->ObjectDeclaration[R6001];

select any nav_type from instances of BasicType where false;

// if the rel spec is a "many" association or the lhs is a collection type,
// assure that the type of the expression is an instance set
if not_empty lhs_collection or ((empty using_obj or using_obj != from_obj) and (rel_spec.multiplicity == MaslMultiplicity::many))
  nav_type = ::select_create_InstanceType(object_declaration:to_obj_decl, isset:true);
else
  nav_type = ::select_create_InstanceType(object_declaration:to_obj_decl, isset:false);
end if;
relate nav_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	7);
INSERT INTO S_SPARM
	VALUES ("da8d8905-9e8b-4627-9a36-e95419bc25d6",
	"01643d70-2092-460d-856a-f4ddca302cc7",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("01643d70-2092-460d-856a-f4ddca302cc7",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	"00000000-0000-0000-0000-000000000000",
	'resolve_UnaryExpression',
	'',
	'operand = param.operand;
op = param.op;

// if the operator is PLUS, it''s a pass through
if op == Operator::plus
  return operand;
end if;

// if the operator is MINUS and this is a numeric literal, simply prepend the literal text
select one numeric_literal related by operand->LiteralExpression[R5517]->NumericLiteral[R5700];
if not_empty numeric_literal and op == Operator::minus
  numeric_literal.text = "-" + numeric_literal.text;
  LOG::LogInfo(message:"Numeric negation applied to literal");
  return operand;
end if;

// create unary operation
create object instance expression of MaslExpression;
select one basic_type related by operand->BasicType[R5570];
relate basic_type to expression across R5570;
create object instance unary_exp of UnaryExpression;
relate unary_exp to expression across R5517;
unary_exp.operator = op;
relate operand to unary_exp across R5561;

return expression;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	8);
INSERT INTO S_SPARM
	VALUES ("39393a9d-52b6-4c26-9721-018e5ecc16ed",
	"fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	'operand',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5ee4b190-786c-4c3f-9e64-3803b49aa2af",
	"fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	'op',
	"766b5d8d-2e60-4295-a0c6-de1ee59cb168",
	0,
	'',
	"39393a9d-52b6-4c26-9721-018e5ecc16ed",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("766b5d8d-2e60-4295-a0c6-de1ee59cb168",
	"00000000-0000-0000-0000-000000000000",
	'Operator',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/Shared/Shared.xtuml');
INSERT INTO PE_PE
	VALUES ("fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	"00000000-0000-0000-0000-000000000000",
	'resolve_CharacteristicExpression',
	'',
	'expression = param.expression;
base_expression = param.base_expression;

// relate the base expression
select one characteristic related by expression->CallExpression[R5517]->CharacteristicExpression[R5500];
relate base_expression to characteristic across R5504;
select one base_type related by base_expression->BasicType[R5570];


// resolve the result type for characteristic

if characteristic.characteristic == "parse"

  // the result type is the type referenced by the base expression
  relate base_type to expression across R5570;
  
elif characteristic.characteristic == "elements"
  
  // the result type is the sequence type of the given collection type
	select one base_collection related by base_type->CollectionType[R6205];
	if not_empty base_collection
		select one base_element_type related by base_collection->BasicType[R6208];
		select any basic_type related by base_element_type->CollectionType[R6208]->SequenceType[R6207]->CollectionType[R6207]->BasicType[R6205];
		if empty basic_type
			create object instance type_definition of TypeDefinition;
			create object instance basic_type of BasicType;
			basic_type.isanonymous = true;
			create object instance collection_type of CollectionType;
			create object instance sequence_type of SequenceType;
			relate basic_type to type_definition across R6236;
			relate collection_type to basic_type across R6205;
			relate sequence_type to collection_type across R6207;
			relate collection_type to base_element_type across R6208;
		end if;
		relate basic_type to expression across R5570;
	end if;

elif characteristic.characteristic == "length"
  
  // the result type is always integer (only valid for collections)
	select one base_collection related by base_type->CollectionType[R6205];
	if not_empty base_collection
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;

elif characteristic.characteristic == "image"

  // the result type is always string (valid for all types)
  select any string_builtin from instances of BuiltinType where "" + selected.name == "string";
  select one string_type related by string_builtin->BasicType[R6205];
  relate string_type to expression across R5570;

elif characteristic.characteristic == "first" or characteristic.characteristic == "last"
  
  // the result type is integer (only valid for sequences, arrays, and strings)
  select one base_builtin related by base_type->BuiltinType[R6205];
  select one base_collection related by base_type->CollectionType[R6205];
  select one base_sequence related by base_collection->SequenceType[R6207];
  select one base_array related by base_collection->ArrayType[R6207];
  if not_empty base_sequence or not_empty base_array or (not_empty base_builtin and "" + base_builtin.name == "string")
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;

elif characteristic.characteristic == "now"
  
  // the result type is a timestamp (only valid for type timestamp)
  select one base_builtin related by base_type->BuiltinType[R6205];
  if not_empty base_builtin and "" + base_builtin.name == "timestamp"
    relate base_type to expression across R5570;
  end if;

elif characteristic.characteristic == "seconds"
  
  // the result type is integer (only valid for timestamp and duration)
  select one base_builtin related by base_type->BuiltinType[R6205];
  if not_empty base_builtin and ("" + base_builtin.name == "timestamp" or "" + base_builtin.name == "duration")
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;

end if;


// timer specific characteristics
select one base_builtin related by base_type->BuiltinType[R6205];
if not_empty base_builtin and "" + base_builtin.name == "timer"
  if characteristic.characteristic == "delta"
    select any duration_builtin from instances of BuiltinType where "" + selected.name == "duration";
    select one duration_type related by duration_builtin->BasicType[R6205];
    relate duration_type to expression across R5570;
  elif characteristic.characteristic == "scheduled_at" or characteristic.characteristic == "expired_at"
    select any timestamp_builtin from instances of BuiltinType where "" + selected.name == "timestamp";
    select one timestamp_type related by timestamp_builtin->BasicType[R6205];
    relate timestamp_type to expression across R5570;
  elif characteristic.characteristic == "scheduled" or characteristic.characteristic == "expired"
    select any boolean_builtin from instances of BuiltinType where "" + selected.name == "boolean";
    select one boolean_type related by boolean_builtin->BasicType[R6205];
    relate boolean_type to expression across R5570;
  elif characteristic.characteristic == "length"
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;
end if;


// TODO fill out for all characteristics',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	6);
INSERT INTO S_SPARM
	VALUES ("4b4444c1-73b2-4a44-b5d0-462af20d03da",
	"d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a45c6504-266a-41e4-aaf9-f5a8a5e7606c",
	"d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	'base_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"4b4444c1-73b2-4a44-b5d0-462af20d03da",
	'');
INSERT INTO PE_PE
	VALUES ("d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	"00000000-0000-0000-0000-000000000000",
	'resolve_LoopSpec',
	'',
	'loop_spec = param.loop_spec;
expression = param.expression;
root_code_block = ::select_CodeBlock_root( code_block:param.current_code_block );

// determine the flavor of loop expression.
// resolve the subtype.
// return the type of the loop variable
LOG::LogInfo(message:"resolve_LoopSpec with LoopVariable:" + loop_spec.loopVariable );

select any basic_type from instances of BasicType where false;

select one min_max_range related by expression->RangeExpression[R5517]->MinMaxRange[R5540];
if not_empty min_max_range
  create object instance from_to_range of FromToRange;
  relate from_to_range to loop_spec across R5123;
  relate min_max_range to from_to_range across R5111;
  // the type of a min/max range expression is the type of the min or max epression
  // (I arbitrarily choose max because that''s what the C++ model compiler does)
  select one basic_type related by min_max_range->MaslExpression[R5528]->BasicType[R5570];
else
  select one characteristic_expression related by expression->CallExpression[R5517]->CharacteristicExpression[R5500];
  if not_empty characteristic_expression and characteristic_expression.characteristic == "elements"
    create object instance variable_elements of VariableElements;
    relate variable_elements to loop_spec across R5123;
    relate expression to variable_elements across R5139;
    // the type of a variable elements expression is the base type of the collection
    select one basic_type related by expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
  elif not_empty characteristic_expression and characteristic_expression.characteristic == "range"
    select one type_name_expression related by characteristic_expression->MaslExpression[R5504] where false; // TODO need to be able to reference types
    if not_empty type_name_expression
      // TODO
    else
      create object instance variable_range of VariableRange;
      relate variable_range to loop_spec across R5123;
      relate expression to variable_range across R5140;
      // the type of a variable range expression is either the range type (if the variable is an array) or integer
      select one basic_type related by expression->BasicType[R5570]->CollectionType[R6205]->ArrayType[R6207]->MaslExpression[R6201]->BasicType[R5570];
      if empty basic_type
        select any integer_type from instances of BuiltinType where "" + selected.name == "integer";
        select one basic_type related by integer_type->BasicType[R6205];
      end if;
    end if;
  else
    select one collection_type related by expression->BasicType[R5570]->CollectionType[R6205];
    if not_empty collection_type
      LOG::LogInfo(message:"resolve_LoopSpec FOUND collection:  " + loop_spec.loopVariable);
      create object instance variable_elements of VariableElements;
      relate variable_elements to loop_spec across R5123;
      relate expression to variable_elements across R5139;
      // The type of a variable elements expression is the base type of the collection.
      select one basic_type related by expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
      // Find the VariableDefinition that was created for the loop variable.
      select any variable_definition related by root_code_block->VariableDefinition[R5151] where ( selected.name == loop_spec.loopVariable );
      if ( not_empty variable_definition )
        LOG::LogInfo(message:"resolve_LoopSpec FOUND existing loopVariable:  " + loop_spec.loopVariable);
      else
        LOG::LogInfo(message:"resolve_LoopSpec DID NOT FIND existing loopVariable:  " + loop_spec.loopVariable);
        create object instance variable_definition of VariableDefinition;
        variable_definition.name = loop_spec.loopVariable;
        variable_definition.isreadonly = true;
        relate basic_type to variable_definition across R5137;
        relate variable_definition to root_code_block across R5151;
      end if;
      relate loop_spec to variable_definition across R5154;
      // ASL does structure unpacking.
      // Check to see if the collection is a set of structures.  If so, we need to unpack it.
      select one structure_type related by basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
      if ( not_empty structure_type )
        // Now, unpack and assign types to the input loop variable tuple.
        LOG::LogInfo(message:"FOUND set of STRUCTURES:  " + loop_spec.loopVariable);
        // Loop through the argument list and the structure members.
        // Assign the types as we go.
        argument_expression = param.argument_list_expression;
        select one structure_element related by structure_type->StructureElement[R6244];
        while ( not_empty structure_element and not_empty argument_expression ) 
          // Unrelate the argument_expression BasicType and link the one found on the structure element.
          select one element_basic_type related by structure_element->BasicType[R6230];
          select one argument_basic_type related by argument_expression->BasicType[R5570];
          unrelate argument_basic_type from argument_expression across R5570;
          relate element_basic_type to argument_expression across R5570;
          ::ASL_basic_type_info( basic_type:element_basic_type, label:"resolve_Loop and checking reassigned type" );
          select one argument_basic_type related by argument_expression->BasicType[R5570];
          ::ASL_basic_type_info( basic_type:argument_basic_type, label:"resolve_Loop and checking if reassigned type actually stuck" );
          select one udt related by element_basic_type->MaslUserDefinedType[R6205];
          if ( not_empty udt )
            LOG::LogInfo(message:"LOOPing and linked type:  " + udt.name);
          end if;
          if ( empty element_basic_type or empty argument_basic_type )
            LOG::LogInfo(message:"LOOPeen EMPTY type:  " );
          end if;
          // Find the name of the tuple member.
          select one variable_definition related by argument_expression->VariableNameExpression[R5517]->VariableDefinition[R5562];
          if ( not_empty variable_definition )
            variable_definition.isreadonly = true;
            LOG::LogInfo(message:"LOOPing and FOUND VariableNameExpression :  " + variable_definition.name);
            relate variable_definition to loop_spec across R5154;
            select one basic_type related by variable_definition->BasicType[R5137];
            unrelate basic_type from variable_definition across R5137;
            relate element_basic_type to variable_definition across R5137;
          end if;
          LOG::LogInfo(message:"LOOPING through argument list and structure members:  " + structure_element.name);
          select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
          select one argument_expression related by argument_expression->Argument[R5577]->Argument[R5576.''precedes'']->MaslExpression[R5577];
        end while;
      else
      end if;
    else
      LOG::LogFailure(message:"Could not determine type of loop spec variable:  " + loop_spec.loopVariable);
    end if;
  end if;
end if;

return basic_type;',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	1,
	'',
	0,
	9);
INSERT INTO S_SPARM
	VALUES ("616cce8b-3e85-4dc9-b80d-a0fa8bf41f36",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'loop_spec',
	"c60f6c86-bba8-4cc5-b3d8-ebf816da1798",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c60f6c86-bba8-4cc5-b3d8-ebf816da1798",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<LoopSpec>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("1fffd28c-693f-4306-9f26-f85f62d96d68",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"616cce8b-3e85-4dc9-b80d-a0fa8bf41f36",
	'');
INSERT INTO S_SPARM
	VALUES ("9baeb8ad-2be3-4704-a381-118b52a779dd",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'argument_list_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"1fffd28c-693f-4306-9f26-f85f62d96d68",
	'');
INSERT INTO S_SPARM
	VALUES ("6373fb09-e558-4dae-b790-632ba705c6b4",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'current_code_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"9baeb8ad-2be3-4704-a381-118b52a779dd",
	'');
INSERT INTO PE_PE
	VALUES ("2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("f2470f88-fc4a-406d-ba1c-54179e448ed4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<BasicType>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/type/type.xtuml');
INSERT INTO S_SYNC
	VALUES ("d7ab00cc-2a6d-4f76-b901-a5820120a218",
	"00000000-0000-0000-0000-000000000000",
	'resolve_Non_Existent',
	'',
	'object_declaration = param.object_declaration;

select any ne_st related by object_declaration->MaslState[R6105] where "" + selected.name == "Non_Existent";
if empty ne_st
  // create the default Non_Existent state if there is at least one instance state
  select any st related by object_declaration->MaslState[R6105]
    where selected.flavor == StateType::creation or selected.flavor == StateType::terminal or selected.flavor == StateType::normal;
  if not_empty st
    create object instance ne_st of MaslState;
    ne_st.name = "Non_Existent";
    ne_st.flavor = StateType::normal;
    relate ne_st to object_declaration across R6105;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	10);
INSERT INTO S_SPARM
	VALUES ("2c774dea-0025-4e68-a193-43521a97e8e2",
	"d7ab00cc-2a6d-4f76-b901-a5820120a218",
	'object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("d7ab00cc-2a6d-4f76-b901-a5820120a218",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c323ddee-0396-411f-aefc-af182b646bd0",
	"00000000-0000-0000-0000-000000000000",
	'resolve_FindNameExpression',
	'',
	'current_object = param.current_object;

// TODO structure components and array elements

// search for find expression attribute reference
select any attr_ref related by current_object->AttributeDeclaration[R5802] where selected.name == param.name;
if not_empty attr_ref
  create object instance expr of MaslExpression;
  create object instance find_attr_ref of FindAttributeNameExpression;
  relate find_attr_ref to expr across R5517;
  relate attr_ref to find_attr_ref across R5518;
  select one basic_type related by attr_ref->BasicType[R5803];
  relate basic_type to expr across R5570;
  LOG::LogInfo(message:"resolved find name [selected attribute reference]: ''" + param.name + "''");
  return expr;
end if;

LOG::LogFailure(message:"Could not resolve find name expression: " + param.name + ", " + param.comp_name);
select any expr from instances of MaslExpression where false;
return expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	2);
INSERT INTO S_SPARM
	VALUES ("a23a4ba1-98db-4823-83b6-a409e1576505",
	"c323ddee-0396-411f-aefc-af182b646bd0",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6c4353eb-d209-43c4-8516-8f5cee805dc6",
	"c323ddee-0396-411f-aefc-af182b646bd0",
	'current_object',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"aeb56ca8-2b1c-431c-a7de-77cb30306d2e",
	'');
INSERT INTO S_SPARM
	VALUES ("aeb56ca8-2b1c-431c-a7de-77cb30306d2e",
	"c323ddee-0396-411f-aefc-af182b646bd0",
	'comp_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"a23a4ba1-98db-4823-83b6-a409e1576505",
	'');
INSERT INTO PE_PE
	VALUES ("c323ddee-0396-411f-aefc-af182b646bd0",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e93ae7d3-47cb-4beb-8d53-ad43ee89cb9a",
	"00000000-0000-0000-0000-000000000000",
	'resolve_CorrelatedNavExpression',
	'',
	'expression = param.expression;
select one rel_spec related by expression->CorrelatedNavExpression[R5517]->RelationshipSpecification[R5507];
select one lhs_collection related by expression->CorrelatedNavExpression[R5517]->MaslExpression[R5506]->BasicType[R5570]->CollectionType[R6205];
select one rhs_collection related by expression->CorrelatedNavExpression[R5517]->MaslExpression[R5508]->BasicType[R5570]->CollectionType[R6205];
select one using_obj_decl related by rel_spec->RelationshipDeclaration[R6015]->AssociativeRelationshipDeclaration[R6010]->ObjectDeclaration[R6001];

select any nav_type from instances of BasicType where false;

// if the rel spec is a "many" association or the lhs is a collection type,
// assure that the type of the expression is an instance set
if not_empty lhs_collection or not_empty rhs_collection
  nav_type = ::select_create_InstanceType(object_declaration:using_obj_decl, isset:true);
else
  nav_type = ::select_create_InstanceType(object_declaration:using_obj_decl, isset:false);
end if;
relate nav_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	7);
INSERT INTO S_SPARM
	VALUES ("e419d58f-f189-4072-81ad-f898450674af",
	"e93ae7d3-47cb-4beb-8d53-ad43ee89cb9a",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("e93ae7d3-47cb-4beb-8d53-ad43ee89cb9a",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	"00000000-0000-0000-0000-000000000000",
	'get_domain_activities',
	'',
	'domain = param.domain;
i = 0;

// TODO consider overloading

// domain services
select many domain_services related by domain->DomainService[R5303]->Service[R5203] where SORT::ascending(attr:"name");
for each domain_service in domain_services
  extension = ".svc";
  select any scenario_mark from instances of Mark where selected.markable_name == "DomainService" and
    selected.feature_name == "scenario" and selected.path == "" + domain.name + "::" + domain_service.name;
  select any external_mark from instances of Mark where selected.markable_name == "DomainService" and
    selected.feature_name == "external" and selected.path == "" + domain.name + "::" + domain_service.name;
  if not_empty scenario_mark
    extension = ".scn";
  elif not_empty external_mark
    extension = ".ext";
  else
  end if;
  param.filenames[i] = "" + domain_service.name + extension;
  i = i + 1;
end for;

// terminator services
select many terminators related by domain->DomainTerminator[R5304] where SORT::ascending(attr:"name");
for each terminator in terminators
  select many terminator_services related by terminator->DomainTerminatorService[R5306]->Service[R5203] where SORT::ascending(attr:"name");
  for each terminator_service in terminator_services
    term_name = "" + terminator.name;
    select any key_letter_mark from instances of Mark where selected.markable_name == "DomainTerminator" and
      selected.feature_name == "key_letter" and selected.path == "" + domain.name + "::" + terminator.name;
    if not_empty key_letter_mark
      term_name = key_letter_mark.value;
    end if;
    param.filenames[i] = term_name + "_" + terminator_service.name + ".tr";
    i = i + 1;
  end for;
end for;

select many objs related by domain->ObjectDeclaration[R5805] where SORT::ascending(attr:"name");
for each obj in objs
  obj_name = "" + obj.name;
  select any key_letter_mark from instances of Mark where selected.markable_name == "Object" and
    selected.feature_name == "key_letter" and selected.path == "" + domain.name + "::" + obj.name;
  if not_empty key_letter_mark
    obj_name = key_letter_mark.value;
  end if;
 
  // object and instance services
  select many object_services related by obj->ObjectService[R5808]->Service[R5203] where SORT::ascending(attr:"name");
  for each object_service in object_services
    param.filenames[i] = obj_name + "_" + object_service.name + ".svc";
    i = i + 1;
  end for;

  // states
  select many object_states related by obj->MaslState[R6105] where "" + selected.name != "Non_Existent" and SORT::ascending(attr:"name");
  for each object_state in object_states
    sep = "_";
    if object_state.flavor == StateType::assigner or object_state.flavor == StateType::assigner_start
      sep = "-A_";
    end if;
    param.filenames[i] = obj_name + sep + object_state.name + ".al";
    i = i + 1;
  end for;
end for;

return param.filenames;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	0,
	11);
INSERT INTO S_SPARM
	VALUES ("8d8e6df6-d04a-4727-bc97-fffddbe354c3",
	"dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	'domain',
	"d467079c-c61e-4b05-8498-3fe2f24782a6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6eb13365-4345-4014-aab4-9034b2009c29",
	"dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	'filenames',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	"8d8e6df6-d04a-4727-bc97-fffddbe354c3",
	'');
INSERT INTO S_DIM
	VALUES (0,
	0,
	"00000000-0000-0000-0000-000000000000",
	"6eb13365-4345-4014-aab4-9034b2009c29",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"9e4f9ca3-d051-43d8-9c59-1c4c65a7e72e",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_DIM
	VALUES (0,
	0,
	"dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"920b87a5-4f6b-461e-8335-8dc3fe683387",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO PE_PE
	VALUES ("dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e07b20ae-d318-4371-8a3d-25598d8c7348",
	"00000000-0000-0000-0000-000000000000",
	'get_project_activities',
	'',
	'project = param.project;
i = 0;

// TODO consider overloading

select many project_domains related by project->ProjectDomain[R5900];
for each project_domain in project_domains
  select one domain related by project_domain->Domain[R5901];

  // terminator services
  select many terminators related by project_domain->ProjectTerminator[R5902] where SORT::ascending(attr:"name");
  for each terminator in terminators
    select many terminator_services related by terminator->ProjectTerminatorService[R5903]->Service[R5203] where SORT::ascending(attr:"name");
    for each terminator_service in terminator_services
      term_name = "" + terminator.name;
      select any key_letter_mark from instances of Mark where selected.markable_name == "ProjectTerminator" and
        selected.feature_name == "key_letter" and selected.path == "" + project.name + "::" + domain.name + "::" + terminator.name;
      if not_empty key_letter_mark
        term_name = key_letter_mark.value;
      end if;
      param.filenames[i] = "" + domain.name + "_" + term_name + "_" + terminator_service.name + ".tr";
      i = i + 1;
    end for;
  end for;

end for;

return param.filenames;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	0,
	11);
INSERT INTO S_SPARM
	VALUES ("9a245058-496c-450d-b34c-37f45bd5e55c",
	"e07b20ae-d318-4371-8a3d-25598d8c7348",
	'project',
	"441f24d5-1449-4a86-a093-cf7c331418a3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("441f24d5-1449-4a86-a093-cf7c331418a3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Project>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/project/project.xtuml');
INSERT INTO S_SPARM
	VALUES ("c5f07d37-497a-4ef6-b1a8-05d3bcb69b9d",
	"e07b20ae-d318-4371-8a3d-25598d8c7348",
	'filenames',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	"9a245058-496c-450d-b34c-37f45bd5e55c",
	'');
INSERT INTO S_DIM
	VALUES (0,
	0,
	"00000000-0000-0000-0000-000000000000",
	"c5f07d37-497a-4ef6-b1a8-05d3bcb69b9d",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"113f6080-99f2-424c-8515-c2278b733370",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_DIM
	VALUES (0,
	0,
	"e07b20ae-d318-4371-8a3d-25598d8c7348",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"d3621d02-96f9-436b-a031-77cd3ffebd07",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO PE_PE
	VALUES ("e07b20ae-d318-4371-8a3d-25598d8c7348",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4f5b7c96-aba1-4f90-974b-ff2812008342",
	"00000000-0000-0000-0000-000000000000",
	'resolve_SliceExpression',
	'',
	'root = param.root;
access_expr = param.access_expr;

// resolve a square bracket access.

select one root_type related by root->BasicType[R5570];
select one access_type related by access_expr->BasicType[R5570];

select one root_collection_type related by root_type->CollectionType[R6205];
select one root_sequence_type related by root_collection_type->SequenceType[R6207];
select one root_array_type related by root_collection_type->ArrayType[R6207];
select one root_string_type related by root_type->BuiltinType[R6205] where "" + selected.name == "string";
select one root_dict_type related by root_type->DictionaryType[R6205];

select one access_range_type related by access_type->CollectionType[R6205]->RangeType[R6207];
select one access_int_type related by access_type->BuiltinType[R6205] where "" + selected.name == "integer";


if (not_empty root_sequence_type or not_empty root_array_type or not_empty root_string_type)

  if not_empty access_range_type
    // TODO slice expression

  elif not_empty access_int_type
    // indexed name expression
    create object instance expr of MaslExpression;
    select one basic_type related by root_collection_type->BasicType[R6208];
    if empty basic_type
      select any char_type from instances of BuiltinType where "" + selected.name == "character";
      select one basic_type related by char_type->BasicType[R6205];
    end if;
    relate basic_type to expr across R5570;
    create object instance indexed_name_expr of IndexedNameExpression;
    relate indexed_name_expr to expr across R5517;
    relate root to indexed_name_expr across R5523;
    relate access_expr to indexed_name_expr across R5522;
    return expr;
  end if;
  
elif not_empty root_dict_type
  
  // TODO dictionary access
  
end if;


LOG::LogFailure(message:"Failed to resolve square bracket access");
select any empty_expr from instances of MaslExpression;
return empty_expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	12);
INSERT INTO S_SPARM
	VALUES ("97c3703a-6687-4176-aaca-381433ea76ea",
	"4f5b7c96-aba1-4f90-974b-ff2812008342",
	'root',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("86483cd5-aa8d-4892-b7fc-cdd237f88abc",
	"4f5b7c96-aba1-4f90-974b-ff2812008342",
	'access_expr',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"97c3703a-6687-4176-aaca-381433ea76ea",
	'');
INSERT INTO PE_PE
	VALUES ("4f5b7c96-aba1-4f90-974b-ff2812008342",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	"00000000-0000-0000-0000-000000000000",
	'ASL_assignment_relink_type',
	'',
	'// ASL supports implicit typing of local variables.
// When a new name is discovered, it is linked to a random type.
// Here we link the lhs expression and the variable definition to the correct type.

lhs = param.lhs;
rhs = param.rhs;

select one var_def related by lhs->VariableNameExpression[R5517]->VariableDefinition[R5562];
if not_empty var_def

  select one rhs_basic_type related by rhs->BasicType[R5570];
  select one lhs_basic_type related by lhs->BasicType[R5570];
  select one var_basic_type related by var_def->BasicType[R5137];

if ( empty rhs )
  LOG::LogInfo( message:"ASL_assignment_relink_type:  no type found on rhs." );
end if;
if ( empty rhs_basic_type )
  LOG::LogInfo( message:"ASL_assignment_relink_type:  no basic type found on rhs." );
end if;
  // relink the expression type
  if ( empty lhs_basic_type )
    LOG::LogInfo( message:"ASL_assignment_relink_type:  no type found on lhs." );
  else
    unrelate lhs from lhs_basic_type across R5570;
  end if;
  relate lhs to rhs_basic_type across R5570;

  // relink the variable type
  if ( empty var_basic_type )
    LOG::LogInfo( message:"ASL_assignment_relink_type:  no type found on var." );
  else
    unrelate var_def from var_basic_type across R5137;
  end if;
  relate var_def to rhs_basic_type across R5137;
  
  LOG::LogInfo( message:"Unlinked and relinked type of lhs in assignment statement." );
  
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	13);
INSERT INTO S_SPARM
	VALUES ("102ba935-fe21-49ae-84c0-e6a03fa62417",
	"7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("3848c7d8-000e-4c0c-a711-a73f05f97a68",
	"7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	'rhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"102ba935-fe21-49ae-84c0-e6a03fa62417",
	'');
INSERT INTO PE_PE
	VALUES ("7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4ec2754e-fec2-44fb-8563-407f995a6ad0",
	"00000000-0000-0000-0000-000000000000",
	'ASL_structure_instantiation',
	'',
	'// Create a collection type to carry members of the input (structure) basic type.

member_basic_type = param.basic_type;

create object instance type_definition of TypeDefinition;
create object instance sequence_basic_type of BasicType;
sequence_basic_type.isanonymous = true;
create object instance collection_type of CollectionType;
create object instance sequence_type of SequenceType;

relate type_definition to sequence_basic_type across R6236;
relate sequence_basic_type to collection_type across R6205;
relate collection_type to sequence_type across R6207;

relate collection_type to member_basic_type across R6208;

return sequence_basic_type;',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	1,
	'',
	0,
	14);
INSERT INTO S_SPARM
	VALUES ("261c7217-b922-42a4-96fb-0ea1a9ed4821",
	"4ec2754e-fec2-44fb-8563-407f995a6ad0",
	'basic_type',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("4ec2754e-fec2-44fb-8563-407f995a6ad0",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("efe36786-4b7a-45a0-a64d-a502444a81d1",
	"00000000-0000-0000-0000-000000000000",
	'ASL_basic_type_info',
	'',
	'basic_type = param.basic_type;
label = param.label;
LOG::LogInfo( message:"basic_type_info:  " + label );

select one udt related by basic_type->MaslUserDefinedType[R6205];
if ( not_empty udt )
  LOG::LogInfo( message:"basic_type_info:  UDT.name:  " + udt.name );
else
select one instance_type related by basic_type->InstanceType[R6205];
if ( not_empty instance_type )
  LOG::LogInfo( message:"basic_type_info:  found instance type" );
else
select one collection_type related by basic_type->CollectionType[R6205];
if ( not_empty collection_type )
  LOG::LogInfo( message:"basic_type_info:  found collection type" );
else
select one builtin_type related by basic_type->BuiltinType[R6205];
if ( not_empty builtin_type )
  LOG::LogInfo( message:"basic_type_info:  found builtin type:  " +builtin_type.name );
else
end if;
end if;
end if;
end if;
select any udt related by basic_type->TypeDefinition[R6236]->TypeDeclaration[R6234]->MaslUserDefinedType[R6241];
if ( not_empty udt )
  LOG::LogInfo( message:"basic_type_info:  upwards UDT.name:  " + udt.name );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	15);
INSERT INTO S_SPARM
	VALUES ("5ba809ef-a797-40e6-9555-4cfb8bfd961f",
	"efe36786-4b7a-45a0-a64d-a502444a81d1",
	'basic_type',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("72acccb5-6961-46c1-8858-e3acc1164a97",
	"efe36786-4b7a-45a0-a64d-a502444a81d1",
	'label',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5ba809ef-a797-40e6-9555-4cfb8bfd961f",
	'');
INSERT INTO PE_PE
	VALUES ("efe36786-4b7a-45a0-a64d-a502444a81d1",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4b618769-988a-420d-9e25-82dd38a026fb",
	"00000000-0000-0000-0000-000000000000",
	'ASL_enumerator_relink_type',
	'',
	'// ASL enumerator variables can be typed or not on second usage.
// Here we link the lhs expression and the variable definition to the correct type.

variable_expression = param.variable_expression;
type_name = param.type_name;
enum_basic_type = ::select_BasicType_where_name( domainname:"", name:type_name );
select one existing_basic_type related by variable_expression->BasicType[R5570];
if ( not_empty existing_basic_type )
  unrelate existing_basic_type from variable_expression across R5570;
end if;
relate enum_basic_type to variable_expression across R5570;

LOG::LogInfo( message:"Unlinked and relinked type of enumeration expression." );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	16);
INSERT INTO S_SPARM
	VALUES ("52deab9d-05b3-44e7-8229-ca098b6a978d",
	"4b618769-988a-420d-9e25-82dd38a026fb",
	'variable_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("34370e25-911a-4f6d-b348-265e6602b08f",
	"4b618769-988a-420d-9e25-82dd38a026fb",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"52deab9d-05b3-44e7-8229-ca098b6a978d",
	'');
INSERT INTO PE_PE
	VALUES ("4b618769-988a-420d-9e25-82dd38a026fb",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("45378197-fd9e-4ed8-93a0-726f09e20a7d",
	"00000000-0000-0000-0000-000000000000",
	'trace',
	'',
	'number = STRING::itoa( i:param.i );
LOG::LogInfo( message: number + ":  " + param.s );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	17);
INSERT INTO S_SPARM
	VALUES ("5a8343e0-ddce-4b51-a507-ccc07adf093c",
	"45378197-fd9e-4ed8-93a0-726f09e20a7d",
	's',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"726282b0-3930-467c-8486-48e6114ac252",
	'');
INSERT INTO S_SPARM
	VALUES ("726282b0-3930-467c-8486-48e6114ac252",
	"45378197-fd9e-4ed8-93a0-726f09e20a7d",
	'i',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("45378197-fd9e-4ed8-93a0-726f09e20a7d",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("fa715298-1ee7-4f4d-9dc6-ff741962c501",
	1,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO S_SYS_PROXY
	VALUES ("e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	'stratus',
	1,
	'../stratus.xtuml');
