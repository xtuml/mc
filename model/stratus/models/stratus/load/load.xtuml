-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	"e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	'load',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	112,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'4.1.17',
	'stratus::load');
INSERT INTO GD_GE
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"d253fd26-846d-41fa-866d-36f9d01a0fa1",
	108,
	0,
	'stratus::load::selectors');
INSERT INTO GD_SHP
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO GD_NCS
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO DIM_GE
	VALUES (0.000000,
	0.000000,
	"434c8733-cf38-4a4d-b980-5478813c08be",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"cf20d32f-ee33-4e4b-856b-a86d23675ef0",
	108,
	0,
	'stratus::load::marking');
INSERT INTO GD_SHP
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO GD_NCS
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO DIM_GE
	VALUES (220.000000,
	0.000000,
	"c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"f2c7a380-21fe-4c0d-9f05-1bf86680e190",
	108,
	0,
	'stratus::load::ASL2MASL');
INSERT INTO GD_SHP
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12");
INSERT INTO GD_NCS
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12");
INSERT INTO DIM_ND
	VALUES (181.000000,
	97.000000,
	"cfd38096-8232-4756-8641-7c67eb94ea12");
INSERT INTO DIM_GE
	VALUES (12.000000,
	180.000000,
	"cfd38096-8232-4756-8641-7c67eb94ea12",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("cfd38096-8232-4756-8641-7c67eb94ea12",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_DIA
	VALUES ("2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("2fa13145-0c97-4f52-b60b-01b9250b2b55",
	"00000000-0000-0000-0000-000000000000",
	'BuiltinType_populate',
	'',
	'create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "instance";
create object instance any_instance_type of AnyInstanceType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to any_instance_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "boolean";
create object instance boolean_type of BooleanType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to boolean_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "character";
create object instance character_type of CharacterType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to character_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "device";
create object instance device_type of DeviceType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to device_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "duration";
create object instance duration_type of DurationType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to duration_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "event";
create object instance event_type of MaslEventType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to event_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "string";
create object instance string_type of StringType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to string_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "timer";
create object instance timer_type of TimerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to timer_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "timestamp";
create object instance timestamp_type of TimestampType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to timestamp_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "wcharacter";
create object instance wcharacter_type of WCharacterType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to wcharacter_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "wstring";
create object instance wstring_type of WStringType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to wstring_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "real";
create object instance numeric_type of NumericType;
numeric_type.bits = 64;
numeric_type.signed = true;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance real_type of RealType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to real_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "long_integer";
create object instance numeric_type of NumericType;
numeric_type.bits = 64;
numeric_type.signed = true;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance integer_type of IntegerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to integer_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "byte";
create object instance numeric_type of NumericType;
numeric_type.bits = 8;
numeric_type.signed = false;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 255; // 2 ^ 8 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 0;
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance byte_type of ByteType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to byte_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "integer";
create object instance numeric_type of NumericType;
numeric_type.bits = 32;
numeric_type.signed = false;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 31 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // - 2 ^ 31 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance small_type of SmallIntegerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to small_type across R6221;

/* Comment out the logging if not desired.
 */
select many builtin_types from instances of BuiltinType where ( SORT::ascending( attr:"name" ) );
message = "builtin types:  ";
for each builtin_type in builtin_types
  message = message + builtin_type.name + " ";
end for;
LOG::LogInfo( message:message );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("2fa13145-0c97-4f52-b60b-01b9250b2b55",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	"00000000-0000-0000-0000-000000000000",
	'create_DotExpression',
	'',
	'lhs = param.lhs;
create object instance expression of MaslExpression;

select one lhs_basic_type related by lhs->BasicType[R5570];
if (empty lhs_basic_type)
  ::trace(i:20,s:"create_DotExpression:  lhs has no type - " + param.name);
end if;

// TODO - provide subtyping maybe from DotExpression <- SelectedAttributeExpression, SelectedComponentExpression, TypeNameExpression, ObjectNameExpresion

// Look for class based operation access.
select one object_reference related by lhs->ObjectNameExpression[R5517];
if (not_empty object_reference)
  select many object_services related by object_reference->ObjectDeclaration[R5533]->ObjectService[R5808] where (not selected.isInstance);
  select any service related by object_services->Service[R5203] where (selected.name == param.name);
  if (not_empty service)
    create object instance call_expr of CallExpression;
    relate call_expr to expression across R5517;
    create object instance service_invocation of ServiceInvocation;
    relate service_invocation to call_expr across R5500;
    create object instance object_service_invocation of ObjectServiceInvocation;
    relate object_service_invocation to service_invocation across R5610;
    select one object_service related by service->ObjectService[R5203];
    relate object_service to object_service_invocation across R5613;
    select one basic_type related by service->BasicType[R5205];
    if (not_empty basic_type)
      relate basic_type to expression across R5570;
    end if;
    ::trace(i:21,s:"create_DotExpression:  object service invocation:  " + param.name);
    return expression;
  end if;
end if;

// Look for attribute access.
select one instance_type related by lhs_basic_type->InstanceType[R6205];
if (not_empty instance_type)
  select any attribute_declaration related by instance_type->ObjectDeclaration[R6220]->AttributeDeclaration[R5802] where (selected.name == param.name);
  if (not_empty attribute_declaration)
    // create selected attribute expression
    create object instance selected_attribute_expression of SelectedAttributeExpression;
    relate lhs to selected_attribute_expression across R5569;
    relate selected_attribute_expression to expression across R5517;
    relate selected_attribute_expression to attribute_declaration across R5541;
    select one basic_type related by attribute_declaration->BasicType[R5803];
    relate basic_type to expression across R5570;
    ::trace(i:22,s:"create_DotExpression:  attribute:  " + param.name);
    return expression;
  end if;
  // Look for instance operation access.
  select any service related by instance_type->ObjectDeclaration[R6220]->ObjectService[R5808]->Service[R5203] where (selected.name == param.name);
  if (not_empty service)
    create object instance call_expr of CallExpression;
    relate call_expr to expression across R5517;
    create object instance service_invocation of ServiceInvocation;
    relate service_invocation to call_expr across R5500;
    create object instance instance_service_invocation of InstanceServiceInvocation;
    relate instance_service_invocation to service_invocation across R5610;
    relate lhs to instance_service_invocation across R5615;
    select one object_service related by service->ObjectService[R5203];
    relate object_service to instance_service_invocation across R5614;
    select one basic_type related by service->BasicType[R5205];
    if (not_empty basic_type)
      relate basic_type to expression across R5570;
    end if;
    ::trace(i:23,s:"create_DotExpression:  instance service invocation:  " + param.name);
    return expression;
  end if;
end if;
 
// Look for structure element.
select one structure_type related by lhs_basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
if (not_empty structure_type)
  select one structure_element related by structure_type->StructureElement[R6244];
  while (not_empty structure_element)
    if (param.name == structure_element.name)
      // create selected component expression
      create object instance selected_component_expression of SelectedComponentExpression;
      relate lhs to selected_component_expression across R5544;
      relate selected_component_expression to expression across R5517;
      relate selected_component_expression to structure_element across R5543;
      select one basic_type related by structure_element->BasicType[R6230];
      relate basic_type to expression across R5570;
      ::trace(i:24,s:"create_DotExpression:  structure element:  " + param.name);
      return expression;
    end if;
    select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
  end while;
else
end if;

::trace(i:25,s:"ERROR:create_DotExpression: failed to resolve dot expression: " + param.name);
return expression;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("8497859e-df75-4e8f-8b56-feeeb63e620c",
	"8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"45edb3d8-f5bc-43e5-ba45-c0fc8b5f3cdb",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	"00000000-0000-0000-0000-000000000000",
	'Name',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/Shared/Shared.xtuml');
INSERT INTO S_SPARM
	VALUES ("45edb3d8-f5bc-43e5-ba45-c0fc8b5f3cdb",
	"8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Expression>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	"00000000-0000-0000-0000-000000000000",
	'create_RelationshipSpecification',
	'',
	'relationship_declaration = param.relationship_declaration;
from_object_declaration = param.from_object_declaration;
to_object_declaration = param.to_object_declaration;
object_or_role = param.object_or_role;

// remove object_or_role if it is redundant
if (not_empty to_object_declaration and "" + to_object_declaration.name == object_or_role)
  object_or_role = "";
end if;

spec = "" + from_object_declaration.name + "->" + relationship_declaration.name;
if (object_or_role != "")
  spec = spec + "." + object_or_role;
end if;
if (not_empty to_object_declaration)
  spec = spec + "." + to_object_declaration.name;
end if;
LOG::LogInfo(message:"creating relationship spec: " + spec);

// Create the relationship specification
create object instance relationship_specification of RelationshipSpecification;
relate relationship_specification to relationship_declaration across R6015;
relate relationship_specification to from_object_declaration across R6014;


// Resolve when all information is provided.
if (not_empty to_object_declaration and object_or_role != "")
  
  // Fill out "to" object and role phrase
  relate relationship_specification to to_object_declaration across R6011;
  relationship_specification.role = object_or_role;

  // Find applicable half-relationship for binary and associative relationships.
  // Binary
	select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
	select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
	if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name and half_rel_1.role == object_or_role)
		LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
	select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
	if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name and half_rel_2.role == object_or_role)
		LOG::LogInfo(message: "normal rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;
	
	// Assoc
	select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
	select one from_object_1 related by half_rel_1->ObjectDeclaration[R6006];
	if (not_empty from_object_1 and from_object_1.name == from_object_declaration.name and half_rel_1.role == object_or_role)
		LOG::LogInfo(message: "assoc ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
	select one from_object_2 related by half_rel_2->ObjectDeclaration[R6006];
	if (not_empty from_object_2 and from_object_2.name == from_object_declaration.name and half_rel_2.role == object_or_role)
		LOG::LogInfo(message: "assoc rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;
	select one link_obj related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]
	  ->ObjectDeclaration[R6001] where selected.name == from_object_declaration.name;
	if (not_empty link_obj)  // from the associator to the one or other
		select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
		select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
		if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name and half_rel_1.role == object_or_role)
			LOG::LogInfo(message: "assoc ltr from " + to_object_declaration.name + "->" + to_object_declaration.name);
			relate relationship_specification to half_rel_1 across R6013;
			relationship_specification.multiplicity = half_rel_1.multiplicity;
			relationship_specification.conditional = half_rel_1.isconditional;
			return relationship_specification;
		end if;
		select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
		select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
		if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name and half_rel_2.role == object_or_role)
			LOG::LogInfo(message: "assoc rtl from " + to_object_declaration.name + "->" + to_object_declaration.name);
			relate relationship_specification to half_rel_2 across R6013;
			relationship_specification.multiplicity = half_rel_2.multiplicity;
			relationship_specification.conditional = half_rel_2.isconditional;
			return relationship_specification;
		end if;
	end if;
	
	// sub-super
  select one subsup related by relationship_declaration->SubtypeRelationshipDeclaration[R6010];
  if (not_empty subsup)
		relationship_specification.multiplicity = MaslMultiplicity::one;
		relationship_specification.conditional = false;
		return relationship_specification;
  end if;

// Resolve when the relationship name and either the object name or role phrase
// is provided but not both.
elif ((empty to_object_declaration and object_or_role != "") or
      (not_empty to_object_declaration and object_or_role == ""))
  if (empty to_object_declaration)
		select any to_object_declaration related by relationship_declaration->Domain[R6003]
			->ObjectDeclaration[R5805] where "" + selected.name == object_or_role;
  end if;

	// Resolve when only the relationship name and to object name are provided.
	// All non-reflexive binary and associative relationships and sub-super
	// relationships can be resolved with this information.
  if (not_empty to_object_declaration)
    if (to_object_declaration.name != from_object_declaration.name)

			// Fill out "to" object
			relate relationship_specification to to_object_declaration across R6011;

			// Find applicable half-relationship for binary and associative relationships.
			// Binary
			select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
			select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
			if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name)
				LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_1 across R6013;
				relationship_specification.multiplicity = half_rel_1.multiplicity;
				relationship_specification.conditional = half_rel_1.isconditional;
				relationship_specification.role = half_rel_1.role;
				return relationship_specification;
			end if;
			select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
			select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
			if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name)
				LOG::LogInfo(message: "normal rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_2 across R6013;
				relationship_specification.multiplicity = half_rel_2.multiplicity;
				relationship_specification.conditional = half_rel_2.isconditional;
				relationship_specification.role = half_rel_2.role;
				return relationship_specification;
			end if;
			
			// Assoc
			select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
			select one from_object_1 related by half_rel_1->ObjectDeclaration[R6006];
			if (not_empty from_object_1 and from_object_1.name == from_object_declaration.name)
				LOG::LogInfo(message: "assoc ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_1 across R6013;
				relationship_specification.multiplicity = half_rel_1.multiplicity;
				relationship_specification.conditional = half_rel_1.isconditional;
				relationship_specification.role = half_rel_1.role;
				return relationship_specification;
			end if;
			select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
			select one from_object_2 related by half_rel_2->ObjectDeclaration[R6006];
			if (not_empty from_object_2 and from_object_2.name == from_object_declaration.name)
				LOG::LogInfo(message: "assoc rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_2 across R6013;
				relationship_specification.multiplicity = half_rel_2.multiplicity;
				relationship_specification.conditional = half_rel_2.isconditional;
				relationship_specification.role = half_rel_2.role;
				return relationship_specification;
			end if;
			select one link_obj related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]
				->ObjectDeclaration[R6001] where selected.name == from_object_declaration.name;
			if (not_empty link_obj)  // from the associator to the one or other
				select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
				select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
				if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name)
					LOG::LogInfo(message: "assoc ltr from " + to_object_declaration.name + "->" + to_object_declaration.name);
					relate relationship_specification to half_rel_1 across R6013;
					relationship_specification.multiplicity = half_rel_1.multiplicity;
					relationship_specification.conditional = half_rel_1.isconditional;
					relationship_specification.role = half_rel_1.role;
					return relationship_specification;
				end if;
				select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
				select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
				if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name)
					LOG::LogInfo(message: "assoc rtl from " + to_object_declaration.name + "->" + to_object_declaration.name);
					relate relationship_specification to half_rel_2 across R6013;
					relationship_specification.multiplicity = half_rel_2.multiplicity;
					relationship_specification.conditional = half_rel_2.isconditional;
					relationship_specification.role = half_rel_2.role;
					return relationship_specification;
				end if;
			end if;
			
			// sub-super
			select one subsup related by relationship_declaration->SubtypeRelationshipDeclaration[R6010];
			if (not_empty subsup)
				relationship_specification.multiplicity = MaslMultiplicity::one;
				relationship_specification.conditional = false;
				relationship_specification.role = "is_a";
				return relationship_specification;
			end if;

		end if;
    
	// Resolve when only the relationship name and role phrase are provided.
	// Only binary relationships can be resolved with this information.
  else
    
	  relationship_specification.role = object_or_role;

		// normal binary
		select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007]
		  where selected.role == object_or_role;
		select one object_declaration related by half_rel_1->ObjectDeclaration[R6004];
		if (not_empty object_declaration)
			LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + object_declaration.name);
			relate relationship_specification to half_rel_1 across R6013;
			relate relationship_specification to object_declaration across R6011;
			relationship_specification.multiplicity = half_rel_1.multiplicity;
			relationship_specification.conditional = half_rel_1.isconditional;
			return relationship_specification;
		end if;
		select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008]
		  where selected.role == object_or_role;
		select one object_declaration related by half_rel_2->ObjectDeclaration[R6004];
		if (not_empty object_declaration)
			LOG::LogInfo(message: "normal rtl to " + from_object_declaration.name + "->" + object_declaration.name);
			relate relationship_specification to half_rel_2 across R6013;
			relate relationship_specification to object_declaration across R6011;
			relationship_specification.multiplicity = half_rel_2.multiplicity;
			relationship_specification.conditional = half_rel_2.isconditional;
			return relationship_specification;
		end if;
		
		// TODO from link class to one or other

  end if;
  
// Resolve when only relationship name provided.
// Only non-reflexive binary associations and sub->supertype associations can be
// resolved with this little information.
elif (empty to_object_declaration and object_or_role == "")

	// normal binary non-reflexive
	select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
	select one object_declaration related by half_rel_1->ObjectDeclaration[R6004];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
	  relationship_specification.role = half_rel_1.role;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
	select one object_declaration related by half_rel_2->ObjectDeclaration[R6004];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "normal rtl to " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
	  relationship_specification.role = half_rel_2.role;
		return relationship_specification;
	end if;

	// supertype
	select one object_declaration related by relationship_declaration->SubtypeRelationshipDeclaration[R6010]->ObjectDeclaration[R6017];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "sub-super supertype " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = MaslMultiplicity::one;
		relationship_specification.conditional = false;
	  relationship_specification.role = "is_a";
		return relationship_specification;
	end if;

end if;

LOG::LogFailure(message:"Failed to resolve relationship specification");
return relationship_specification;',
	"47e32455-be33-4b7c-9e44-d3b8f4f9ad39",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("01c2ac2c-dccd-4eed-99b4-a6caef76d43c",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'from_object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"08bc443f-7e24-4cb7-8e8d-0e99e8bb8fc9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ccbbc697-c60c-4034-8e31-7a46032151eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ObjectDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("08bc443f-7e24-4cb7-8e8d-0e99e8bb8fc9",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'relationship_declaration',
	"fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("d7a813ed-b8ed-4aa3-afc3-5e9ddec62d42",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'object_or_role',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"01c2ac2c-dccd-4eed-99b4-a6caef76d43c",
	'');
INSERT INTO S_SPARM
	VALUES ("21e7b6d3-c7be-4951-9e8b-1a7ad83d3d2a",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'to_object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"d7a813ed-b8ed-4aa3-afc3-5e9ddec62d42",
	'');
INSERT INTO PE_PE
	VALUES ("090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("47e32455-be33-4b7c-9e44-d3b8f4f9ad39",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipSpecification>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SYNC
	VALUES ("646d0520-59e0-4335-b11f-e59c46fc675c",
	"00000000-0000-0000-0000-000000000000",
	'InternalType_populate',
	'',
	'create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "characteristic";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "enum";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "object";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "service";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "split";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "stream_modifier";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "terminator";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "type";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "unknown_type";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

/* Comment out the logging if not desired.
 */
select many internal_types from instances of InternalType where ( SORT::ascending( attr:"name" ) );
message = "internal types:  ";
for each internal_type in internal_types
  message = message + internal_type.name + " ";
end for;
LOG::LogInfo( message:message );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("646d0520-59e0-4335-b11f-e59c46fc675c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	"00000000-0000-0000-0000-000000000000",
	'OrderingExpression_initialize',
	'',
	'child_expression = param.child_expression;

create object instance expr of MaslExpression;

create object instance ordering_expression of OrderingExpression;
relate ordering_expression to expr across R5517;
ordering_expression.isreverse = param.isreverse;
relate ordering_expression to child_expression across R5535;

// Determine whether we have structures or instances.
select one child_basic_type related by child_expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
select one instance_type related by child_basic_type->InstanceType[R6205];
if ( not_empty instance_type )
  // We have a collection of instances.
  create object instance instance_ordering_expression of InstanceOrderingExpression;
  relate instance_ordering_expression to ordering_expression across R5534;
else
  // We have a collection of structures
  create object instance structure_ordering_expression of StructureOrderingExpression;
  relate structure_ordering_expression to ordering_expression across R5534;
end if;

// Find or create an anonymous sequence of the same element as the child expression.
select any basic_type related by child_basic_type->CollectionType[R6208]->SequenceType[R6207]->CollectionType[R6207]->BasicType[R6205];
if empty basic_type
  create object instance type_definition of TypeDefinition;
  create object instance basic_type of BasicType;
  basic_type.isanonymous = true;
  create object instance collection_type of CollectionType;
  create object instance sequence_type of SequenceType;
  relate basic_type to type_definition across R6236;
  relate collection_type to basic_type across R6205;
  relate sequence_type to collection_type across R6207;
  relate collection_type to child_basic_type across R6208;
end if;

relate basic_type to expr across R5570;

return expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("88d37daf-bb85-43d0-8d37-5a7979ca6cc0",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'child_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("98ec35b4-1347-4a64-a5a6-e3bc8505da11",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'isreverse',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"88d37daf-bb85-43d0-8d37-5a7979ca6cc0",
	'');
INSERT INTO PE_PE
	VALUES ("ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("20183b0e-40fc-465f-94b7-5494d92bc624",
	"00000000-0000-0000-0000-000000000000",
	'OrderingExpression_sort',
	'',
	'expression = param.expression;

select one child_basic_type related by expression->OrderingExpression[R5517]->MaslExpression[R5535]->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
select one instance_ordering_expression related by expression->OrderingExpression[R5517]->InstanceOrderingExpression[R5534];
if ( not_empty instance_ordering_expression )
  select one instance_type related by child_basic_type->InstanceType[R6205];
  select one object_declaration related by instance_type->ObjectDeclaration[R6220];
  select any attribute_declaration related by object_declaration->AttributeDeclaration[R5802] where ( selected.name == param.name );
  if ( not_empty attribute_declaration )
    create object instance key of AttributeOrderingKey;
    key.order = param.index;
    key.isreverse = param.isreverse;
    relate attribute_declaration to instance_ordering_expression across R5563 using key;
  end if;
else
  select one structure_ordering_expression related by expression->OrderingExpression[R5517]->StructureOrderingExpression[R5534];
  select one structure_type related by child_basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
  select one structure_element related by structure_type->StructureElement[R6244];
  while ( not_empty structure_element )
    if ( structure_element.name == param.name )
      create object instance key of StructureElementOrderingKey;
      key.order = param.index;
      key.isreverse = param.isreverse;
      relate structure_element to structure_ordering_expression across R5564 using key;
      break;
    end if;
    select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
  end while;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("120e9147-178e-45ac-8fb9-475ad8821729",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("df97b1a7-79bb-468e-9dc2-dade0205c464",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"120e9147-178e-45ac-8fb9-475ad8821729",
	'');
INSERT INTO S_SPARM
	VALUES ("616cebf9-3b36-4725-86b0-49abb45c5ede",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'isreverse',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"df97b1a7-79bb-468e-9dc2-dade0205c464",
	'');
INSERT INTO S_SPARM
	VALUES ("c2cf44e3-bdae-4707-a7ae-6edd2394f6aa",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"616cebf9-3b36-4725-86b0-49abb45c5ede",
	'');
INSERT INTO PE_PE
	VALUES ("20183b0e-40fc-465f-94b7-5494d92bc624",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("90e0a8bb-2227-4ea2-a3cd-74317453fb69",
	"00000000-0000-0000-0000-000000000000",
	'ReferentialAttribute_resolve',
	'',
	'// Link up the referential attributes here after all objects and attributes
// are fully defined.  During the first pass, the referentials were linked
// to themselves.

LOG::LogInfo( message:"RerentialAttribute_resolve starting..." );

o_referring = ""; o_referenced = ""; // string UDTs
select many referential_attribute_definitions from instances of ReferentialAttributeDefinition;
for each referential_attribute_definition in referential_attribute_definitions
  select one referring_attribute_declaration related by referential_attribute_definition->AttributeDeclaration[R5800.''is_referenced_by''];
  select one referring_object_declaration related by referring_attribute_declaration->ObjectDeclaration[R5802];
  o_referring = referring_object_declaration.name;
  o_referring = o_referring + "." + referential_attribute_definition.name;
  unrelate referring_attribute_declaration from referring_attribute_declaration across R5800.''refers_to'' using referential_attribute_definition;
  select any referenced_attribute_declaration related by
    referential_attribute_definition->RelationshipSpecification[R5811]->ObjectDeclaration[R6011]->AttributeDeclaration[R5802]
    where ( selected.name == referential_attribute_definition.name );
  if ( empty referenced_attribute_declaration )
    LOG::LogFailure( message:"RerentialAttribute_resolve failed to find referenced attribute:  " + referential_attribute_definition.name );
  else
    select one referenced_object_declaration related by referenced_attribute_declaration->ObjectDeclaration[R5802];
    o_referenced = referenced_object_declaration.name;
    o_referenced = o_referenced + "." + referenced_attribute_declaration.name;
    relate referring_attribute_declaration to referenced_attribute_declaration across R5800.''refers_to'' using referential_attribute_definition;
    LOG::LogInfo( message:"RerentialAttribute_resolve " + o_referring + " to " + o_referenced );
  end if;
end for;

LOG::LogInfo( message:"RerentialAttribute_resolve ...done" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("90e0a8bb-2227-4ea2-a3cd-74317453fb69",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("833efa7d-504f-41aa-86e3-501de92ef97c",
	"00000000-0000-0000-0000-000000000000",
	'relate_ObjectDeclaration_to_Domain',
	'',
	'// relate the two, but not if already related
object_declaration = param.object_declaration;
if not_empty object_declaration
  select one domain related by object_declaration->Domain[R5805];
  if empty domain
    domain = param.domain;
    relate object_declaration to domain across R5805;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	1);
INSERT INTO S_SPARM
	VALUES ("a99c4e53-1924-4627-afe7-b9f6789f1cf7",
	"833efa7d-504f-41aa-86e3-501de92ef97c",
	'object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("154560e5-f3ab-469e-bc56-a2022769b696",
	"833efa7d-504f-41aa-86e3-501de92ef97c",
	'domain',
	"d467079c-c61e-4b05-8498-3fe2f24782a6",
	0,
	'',
	"a99c4e53-1924-4627-afe7-b9f6789f1cf7",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d467079c-c61e-4b05-8498-3fe2f24782a6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Domain>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO PE_PE
	VALUES ("833efa7d-504f-41aa-86e3-501de92ef97c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("183c6254-c6e2-4d4e-a5f3-5011775222ab",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NameExpression',
	'',
	'select any domain from instances of Domain where selected.name == param.domain_name;
root_code_block = ::select_CodeBlock_root( code_block:param.current_block );

// search for local variable reference
// Notice that ASL has one scope for all local variables.  It is the root CodeBlock of the activity.
if ( "" == param.scope )
select any var related by root_code_block->VariableDefinition[R5151] where (selected.name == param.name);
if (not_empty var)
  // create a new variable reference
  create object instance expr of MaslExpression;
  select one type related by var->BasicType[R5137];
  relate type to expr across R5570;
  create object instance var_ref of VariableNameExpression;
  relate var_ref to expr across R5517;
  relate var_ref to var across R5562;
  return expr;
end if;

// search for parameter reference
select one current_service related by root_code_block->Service[R5403];
select one current_state related by root_code_block->MaslState[R6115];
select any ref_param from instances of ParameterDefinition where false;
select one service_param related by current_service->ParameterDefinition[R5204];
while (not_empty service_param and empty ref_param)
  if (service_param.name == param.name)
    ref_param = service_param;
  end if;
  select one service_param related by service_param->ParameterDefinition[R5208.''precedes''];
end while;
select one state_param related by current_state->ParameterDefinition[R6104];
while (not_empty state_param and empty ref_param)
  if (state_param.name == param.name)
    ref_param = state_param;
  end if;
  select one state_param related by state_param->ParameterDefinition[R5208.''precedes''];
end while;
if (not_empty ref_param)
  create object instance expr of MaslExpression;
  create object instance param_ref of ParameterNameExpression;
  relate param_ref to expr across R5517;
  relate ref_param to param_ref across R5536;
  select one type related by ref_param->BasicType[R5200];
  relate type to expr across R5570;
  return expr;
end if;

// search for literal enumerators
select any enumer related by domain->MaslUserDefinedType[R6235]->TypeDeclaration[R6241]->TypeDefinition[R6234]
  ->FullTypeDefinition[R6236]->EnumerateType[R6219]->EnumerateItem[R6245] where selected.name == param.name;
if ( "" != param.base_name )
  select any user_defined_type related by domain->MaslUserDefinedType[R6235] where ( "" + selected.name == param.base_name );
  select any enumer related by user_defined_type->TypeDeclaration[R6241]->TypeDefinition[R6234]
    ->FullTypeDefinition[R6236]->EnumerateType[R6219]->EnumerateItem[R6245] where selected.name == param.name;
end if;
if not_empty enumer
  create object instance expr of MaslExpression;
  select any type related by enumer->EnumerateType[R6245]->FullTypeDefinition[R6219]->TypeDefinition[R6236]
    ->TypeDeclaration[R6234]->MaslUserDefinedType[R6241]->BasicType[R6205];
  relate type to expr across R5570;
  create object instance literal_expr of LiteralExpression;
  relate literal_expr to expr across R5517;
  create object instance enum_expr of EnumerateLiteral;
  relate enum_expr to literal_expr across R5700;
  relate enumer to enum_expr across R5701;
  return expr;
end if;
end if;

// search for domain service reference
if ( "::" == param.scope )
select any service related by domain->DomainService[R5303]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  else
    // ASL-specific, find out parameter to serve as call_expression type
    select one parameter_definition related by service->ParameterDefinition[R5204];
    while (not_empty parameter_definition)
      if ( parameter_definition.mode == ParameterMode::out )
        select one type related by parameter_definition->BasicType[R5200];
        if (not_empty type)
          relate type to expr across R5570;
          break;
        end if;
      end if;
      select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
    end while;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance domain_service_invocation of DomainServiceInvocation;
  relate domain_service_invocation to service_invocation across R5610;
  select one domain_service related by service->DomainService[R5203];
  relate domain_service to domain_service_invocation across R5611;
  return expr;
end if;
end if;

// search for objects
select any object_declaration related by domain->ObjectDeclaration[R5805] where selected.name == param.name;
if (not_empty object_declaration)
  create object instance expr of MaslExpression;
  create object instance obj_name_expr of ObjectNameExpression;
  relate obj_name_expr to expr across R5517;
  relate object_declaration to obj_name_expr across R5533;
  type = ::select_create_InstanceType(object_declaration:object_declaration, isset:true);
  relate type to expr across R5570;
  return expr;
end if;

// search for terminator service reference
if ( ":" == param.scope )
select any service related by domain->DomainTerminator[R5304]->DomainTerminatorService[R5306]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  else
    // ASL-specific, find out parameter to serve as call_expression type
    select one parameter_definition related by service->ParameterDefinition[R5204];
    while (not_empty parameter_definition)
      if ( parameter_definition.mode == ParameterMode::out )
        select one type related by parameter_definition->BasicType[R5200];
        if (not_empty type)
          relate type to expr across R5570;
          break;
        end if;
      end if;
      select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
    end while;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance terminator_service_invocation of TerminatorServiceInvocation;
  relate terminator_service_invocation to service_invocation across R5610;
  select one terminator_service related by service->DomainTerminatorService[R5203];
  relate terminator_service to terminator_service_invocation across R5612;
  return expr;
end if;

// search for object service reference
select any service related by domain->ObjectDeclaration[R5805]->ObjectService[R5808]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  else
    // ASL-specific, find out parameter to serve as call_expression type
    select one parameter_definition related by service->ParameterDefinition[R5204];
    while (not_empty parameter_definition)
      if ( parameter_definition.mode == ParameterMode::out )
        select one type related by parameter_definition->BasicType[R5200];
        if (not_empty type)
          relate type to expr across R5570;
          break;
        end if;
      end if;
      select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
    end while;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance object_service_invocation of ObjectServiceInvocation;
  relate object_service_invocation to service_invocation across R5610;
  select one object_service related by service->ObjectService[R5203];
  relate object_service to object_service_invocation across R5613;
  return expr;
end if;
end if;

// search for types (for characteristics and type casting)
if ( false ) // ASL does not have type expressions.
select any builtin from instances of BuiltinType where selected.name == param.name;
select one basic_type related by builtin->BasicType[R6205];
if empty basic_type
  select any udt related by domain->MaslUserDefinedType[R6235] where selected.name == param.name;
  select one basic_type related by udt->BasicType[R6205];
end if;
if not_empty basic_type
  // create a new type type name expression
  create object instance expr of MaslExpression;
  relate basic_type to expr across R5570;
  create object instance type_name_expr of TypeNameExpression;
  relate type_name_expr to expr across R5517;
  relate basic_type to type_name_expr across R5578;
  log_name = param.name;
  if empty builtin
    log_name = param.domain_name + "::" + log_name;
  end if;
  return expr;
end if;
end if; // ASL

// ASL will coerce an invocation to Get_Time_Remaining to a call expression with a characteristic.
if ( "Get_Time_Remaining" == "" + param.name )
  ::trace(i:11,s:"created Get_Remaining_Time call expression" );
  // create an expression tree that corresponds to the following:
  // (<timer_handle>''scheduled_at - timestamp''now)''seconds
  // (<timer_handle>''scheduled_at - timestamp''now)''milliseconds
  // the <timer_handle> expression will be resolved in
  // ''resolve_Expression_ArgumentList'' once the arguments are processed
  
  // create the outer characteristic expression
  create object instance expr1 of MaslExpression;
  create object instance call_expr1 of CallExpression;
  create object instance characteristic_expr1 of CharacteristicExpression;
  relate characteristic_expr1 to call_expr1 across R5500;
  relate call_expr1 to expr1 across R5517;
  characteristic_expr1.characteristic = "milliseconds";  // this is a placeholder, but when the timer is processed it may change
  select any int_builtin_type from instances of BuiltinType where ( "" + selected.name == "integer" );
  select one int_basic_type related by int_builtin_type->BasicType[R6205];
  relate int_basic_type to expr1 across R5570;
  
  // create the binary expression which is the root of the characteristic expression
  create object instance expr1_1 of MaslExpression;
  create object instance binary_expr of BinaryExpression;
  binary_expr.operator = Operator::minus;
  create object instance bae of BinaryAdditiveExpression;
  relate bae to binary_expr across R5000;
  relate binary_expr to expr1_1 across R5517;
  select any duration_builtin_type from instances of BuiltinType where ( "" + selected.name == "duration" );
  select one duration_basic_type related by duration_builtin_type->BasicType[R6205];
  relate duration_basic_type to expr1_1 across R5570;
  relate expr1_1 to characteristic_expr1 across R5504;
  
  // create the LHS of the binary expression -- leave the root of this characteristic expression blank
  create object instance expr1_1_1 of MaslExpression;
  create object instance call_expr2 of CallExpression;
  create object instance characteristic_expr2 of CharacteristicExpression;
  relate characteristic_expr2 to call_expr2 across R5500;
  relate call_expr2 to expr1_1_1 across R5517;
  characteristic_expr2.characteristic = "scheduled_at";
  select any timestamp_builtin_type from instances of BuiltinType where ( "" + selected.name == "timestamp" );
  select one timestamp_basic_type related by timestamp_builtin_type->BasicType[R6205];
  relate timestamp_basic_type to expr1_1_1 across R5570;
  relate expr1_1_1 to binary_expr across R5001;

  // create the RHS of the binary expression
  create object instance expr1_1_2 of MaslExpression;
  create object instance call_expr3 of CallExpression;
  create object instance characteristic_expr3 of CharacteristicExpression;
  relate characteristic_expr3 to call_expr3 across R5500;
  relate call_expr3 to expr1_1_2 across R5517;
  characteristic_expr3.characteristic = "now";
  relate timestamp_basic_type to expr1_1_2 across R5570;
  relate expr1_1_2 to binary_expr across R5002;
  
  // create the root of the RHS characteristic expression
  create object instance expr1_1_2_1 of MaslExpression;
  create object instance type_name_expr of TypeNameExpression;
  relate type_name_expr to expr1_1_2_1 across R5517;
  relate timestamp_basic_type to type_name_expr across R5578;
  relate timestamp_basic_type to expr1_1_2_1 across R5570;
  relate expr1_1_2_1 to characteristic_expr3 across R5504;

  return expr1;
end if;

if ( "event" == "" + param.name )
  // create an event expression, but do not relate the event until it is parsed as the parameter
  create object instance expr of MaslExpression;
  create object instance event_expr of EventExpression;
  relate event_expr to expr across R5517;
  select any builtin_type from instances of BuiltinType where ( "" + selected.name == "event" );
  select one basic_type related by builtin_type->BasicType[R6205];
  if (not_empty basic_type)
    relate basic_type to expr across R5570;
  end if;
  return expr;
end if;

// Call to Create_Timer is ignored as timers are initialized by instance creation in MASL
if ( "Create_Timer" == "" + param.name )
  select any expr from instances of MaslExpression where false;
  return expr;
end if;

// ASL "SECOND" and "MILLISECOND" name expressions are interpereted as literal strings for schedule statements 
if ( "''SECOND''" == "" + param.name or "''MILLISECOND''" == "" + param.name )
  create object instance expr of MaslExpression;
  create object instance literal_expr of LiteralExpression;
  relate literal_expr to expr across R5517;
  create object instance string_literal of StringLiteral;
  relate string_literal to literal_expr across R5700;
  string_literal.original = "" + STRING::substr(s: param.name, begin: 1, end: STRING::strlen(s: param.name) - 1);
  string_literal.noQuotes = "" + STRING::substr(s: param.name, begin: 1, end: STRING::strlen(s: param.name) - 1);
  select any builtin_type from instances of BuiltinType where ( "" + selected.name == "string" );
  select one basic_type related by builtin_type->BasicType[R6205];
  if (not_empty basic_type)
    relate basic_type to expr across R5570;
  end if;
  return expr;
end if;
  
// ASL is implicitly typed.  Create a variable for this unrecognized name.

create object instance var of VariableDefinition;
var.name = param.name;
var.isreadonly = false;
// ASL has a flat scope for activities.  Relate to outer level CodeBlock.
relate var to root_code_block across R5151;
// create a new variable reference
create object instance expr of MaslExpression;
// Relate to ''unknown_type'' for now.  This will get changed in Assignment and LoopSpec.
select any unknown_type from instances of InternalType where ("" + selected.name) == "unknown_type";
select one type related by unknown_type->BasicType[R6205];
relate type to var across R5137;
relate type to expr across R5570;
create object instance var_ref of VariableNameExpression;
relate var_ref to expr across R5517;
relate var_ref to var across R5562;
::trace(i:10,s:"created variable and resolved name [variable]: ''" + param.name + "''");
return expr;
',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	2);
INSERT INTO S_SPARM
	VALUES ("fedc6e46-b6f0-48ac-9833-caf14c14d63e",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'domain_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("36951a0f-4c2a-4b7c-b397-52e2fb563a44",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"fedc6e46-b6f0-48ac-9833-caf14c14d63e",
	'');
INSERT INTO S_SPARM
	VALUES ("e71e8b02-8ca0-473b-b978-25e75c6c8e28",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'current_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"36951a0f-4c2a-4b7c-b397-52e2fb563a44",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<CodeBlock>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("0a53e771-8261-4c53-80ee-3a0fc2c4242d",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'scope',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e71e8b02-8ca0-473b-b978-25e75c6c8e28",
	'');
INSERT INTO S_SPARM
	VALUES ("ccd94894-5ff5-4bd2-a57a-d795cb861033",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'base_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0a53e771-8261-4c53-80ee-3a0fc2c4242d",
	'');
INSERT INTO S_SPARM
	VALUES ("4cc1bb9e-271f-4ee3-982a-f35bd469bbcf",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ccd94894-5ff5-4bd2-a57a-d795cb861033",
	'');
INSERT INTO PE_PE
	VALUES ("183c6254-c6e2-4d4e-a5f3-5011775222ab",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	"00000000-0000-0000-0000-000000000000",
	'resolve_BinaryExpression_type',
	'',
	'expression = param.expression;
select one binary related by expression->BinaryExpression[R5517];
lhs = param.lhs;
rhs = param.rhs;

select one l_type related by lhs->BasicType[R5570];
select one r_type related by rhs->BasicType[R5570];
select one l_builtin related by l_type->BuiltinType[R6205];
select one l_numeric related by l_builtin->NumericType[R6206];
select one r_builtin related by r_type->BuiltinType[R6205];
select one r_numeric related by r_builtin->NumericType[R6206];

// default to using the type of the left-hand-side
binary_type = l_type;

// handle numeric types
if (not_empty l_numeric and not_empty r_numeric)
  // if either of the types is real, promot to real otherwise take the left type
  // only need to check the right-hand-side since LHS is the default
  select one r_builtin related by r_numeric->BuiltinType[R6206];
  if ("" + r_builtin.name == "real")
    binary_type = r_type;
  end if;
end if;

// comparison and logical binary expressions are always boolean
select one comp_binary related by expression->BinaryExpression[R5517]->BinaryComparisonExpression[R5000];
select one logical_binary related by expression->BinaryExpression[R5517]->BinaryLogicalExpression[R5000];
if (not_empty comp_binary or not_empty logical_binary)
  select any bool_type from instances of BuiltinType where "" + selected.name == "boolean";
  select one binary_type related by bool_type->BasicType[R6205];
end if;

// Time arithmetic
if not_empty l_builtin and not_empty r_builtin
  select any timestamp_type from instances of BuiltinType where "" + selected.name == "timestamp";
  select any duration_type from instances of BuiltinType where "" + selected.name == "duration";

  if "" + l_builtin.name == "timestamp"
    // timestamp + duration = timestamp
    if binary.operator == Operator::plus and "" + r_builtin.name == "duration"
      select one binary_type related by timestamp_type->BasicType[R6205];
    // timestamp - duration = timestamp
    elif binary.operator == Operator::minus and "" + r_builtin.name == "duration"
      select one binary_type related by timestamp_type->BasicType[R6205];
    // timetamp - timestamp = duration
    elif binary.operator == Operator::minus and "" + r_builtin.name == "timestamp"
      select one binary_type related by duration_type->BasicType[R6205];
    end if;
  end if;
  
  if "" + l_builtin.name == "duration"
    // duration + timestamp = timestamp
    if binary.operator == Operator::plus and "" + r_builtin.name == "timestamp"
      select one binary_type related by timestamp_type->BasicType[R6205];
    // duration + duration = duration
    elif binary.operator == Operator::plus and "" + r_builtin.name == "duration"
      select one binary_type related by duration_type->BasicType[R6205];
    // duration - duration = duration
    elif binary.operator == Operator::minus and "" + r_builtin.name == "duration"
      select one binary_type related by duration_type->BasicType[R6205];
    // duration * numeric = duration
    elif binary.operator == Operator::times
      select one binary_type related by duration_type->BasicType[R6205];
    // duration / numeric = duration
    elif binary.operator == Operator::divide
      select one binary_type related by duration_type->BasicType[R6205];
    end if;
  end if;

end if;

// ASL correlated navigation uses _and_ to combine instances to the associative on the RHS.
select one instance_type related by r_type->InstanceType[R6205];
if ( not_empty instance_type )
  binary_type = r_type;
  select one object_declaration related by instance_type->ObjectDeclaration[R6220.''references''];
else
  select one basic_type related by r_type->CollectionType[R6205]->BasicType[R6208];
  if ( not_empty basic_type )
    binary_type = basic_type;
  end if;
end if;

// type the expression
relate binary_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("7afdb7d5-027f-4100-8b8a-950b3e27acc9",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c56f0b39-1c44-413d-85b5-dbd10fc56088",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"7afdb7d5-027f-4100-8b8a-950b3e27acc9",
	'');
INSERT INTO S_SPARM
	VALUES ("3dd22e06-404d-462b-9415-49dab59f2fb9",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'rhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"c56f0b39-1c44-413d-85b5-dbd10fc56088",
	'');
INSERT INTO PE_PE
	VALUES ("a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	"00000000-0000-0000-0000-000000000000",
	'resolve_Expression_ArgumentList',
	'',
	'expression = param.expression;
first_argument = param.first_argument;

select one event_expr related by expression->EventExpression[R5517];
select one call_expr related by expression->CallExpression[R5517];

// this handles "Set_Timer" ASL calls where the event is given in the form ''event("KL1")''
if not_empty event_expr
    
  select one event_declaration related by event_expr->EventDeclaration[R5516];
  select one string_literal related by first_argument->MaslExpression[R5577]->LiteralExpression[R5517]->StringLiteral[R5700];
  
  if empty event_declaration and not_empty string_literal
    i = STRING::strlen(s: string_literal.noQuotes);
    while i > 0
      if STRING::indexof(haystack: "0123456789", needle: STRING::substr(s: string_literal.noQuotes, begin: i - 1, end: i)) == -1
        // i is the last non-numeric character
        break;
      end if;
      i = i - 1;
    end while;
    kl = STRING::substr(s: string_literal.noQuotes, begin: 0, end: i);
    num = STRING::substr(s: string_literal.noQuotes, begin: i, end: -1);
    event_declaration = ::ASL_select_EventDeclaration_where_keyletters_name(object_keyletters: kl, num: num, name: "");
    if not_empty event_declaration
      relate event_declaration to event_expr across R5516;
    end if;
  end if;
    
elif not empty call_expr
    
  // handle an invocation of Get_Time_Remaining
  select one root_characteristic related by call_expr->CharacteristicExpression[R5500];
  select one lhs_characteristic related by root_characteristic->MaslExpression[R5504]->BinaryExpression[R5517]->MaslExpression[R5001]->CallExpression[R5517]->CharacteristicExpression[R5500];
  select one lhs_base related by lhs_characteristic->MaslExpression[R5504];
  if not empty lhs_characteristic and lhs_characteristic.characteristic == "scheduled_at" and empty lhs_base
      
      // link the timer handle passed as an argument to the base of the characteristic
      select one lhs_base related by first_argument->MaslExpression[R5577];
      unrelate lhs_base from first_argument across R5577;
      relate lhs_base to lhs_characteristic across R5504;
      
  else
  
    // if this is a type name expression, perform a subtype migration to convert to
    // a cast expression
    select one type_name_expr related by expression->TypeNameExpression[R5517];
    if not_empty type_name_expr
      select one basic_type related by type_name_expr->BasicType[R5578];
      // unhook and dispose the type name expression
      unrelate basic_type from type_name_expr across R5578;
      unrelate type_name_expr from expression across R5517;
      delete object instance type_name_expr;
      // create the cast expression
      create object instance call_expr of CallExpression;
      relate call_expr to expression across R5517;
      create object instance cast of CastExpression;
      relate cast to call_expr across R5500;
      relate basic_type to cast across R5501;
    end if;
    
    // link the first argument to the call expression
    if not_empty call_expr and not_empty first_argument
      relate first_argument to call_expr across R5575;
    end if;
  
  end if;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	4);
INSERT INTO S_SPARM
	VALUES ("c02182a4-29f3-4906-bd55-fa851fcdcf28",
	"9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("372c7571-e9e3-4168-8e25-633579955a66",
	"9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	'first_argument',
	"55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	0,
	'',
	"c02182a4-29f3-4906-bd55-fa851fcdcf28",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Argument>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("93010171-646f-4498-b423-fab780cdb6fe",
	"00000000-0000-0000-0000-000000000000",
	'resolve_ServiceCall',
	'',
	'service_call = param.service_call;
expression = param.expression;
select one service_invocation related by expression->CallExpression[R5517]->ServiceInvocation[R5500];
if (not_empty service_call and not_empty service_invocation)
  relate service_call to service_invocation across R5161;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	5);
INSERT INTO S_SPARM
	VALUES ("4ef35007-2a43-4084-94b6-4480118d5d51",
	"93010171-646f-4498-b423-fab780cdb6fe",
	'service_call',
	"9e1e8ee5-e6f9-48b8-a8f3-324c684cde30",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9e1e8ee5-e6f9-48b8-a8f3-324c684cde30",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ServiceCall>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("bbbf6b59-e897-4a66-858b-0fb595d578e8",
	"93010171-646f-4498-b423-fab780cdb6fe",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"4ef35007-2a43-4084-94b6-4480118d5d51",
	'');
INSERT INTO PE_PE
	VALUES ("93010171-646f-4498-b423-fab780cdb6fe",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dafc5a91-48fd-4fcd-961a-350711f96eaf",
	"00000000-0000-0000-0000-000000000000",
	'resolve_TerminatorServiceInvocation',
	'',
	'expression = param.terminator_service_expression;
service_name = param.service_name;

// gather info
select one terminator_service_invocation related by expression->CallExpression[R5517]->ServiceInvocation[R5500]->TerminatorServiceInvocation[R5610];
select one existing_terminator_service related by terminator_service_invocation->DomainTerminatorService[R5612];
select any service related by existing_terminator_service->DomainTerminator[R5306]->DomainTerminatorService[R5306]->Service[R5203] where selected.name == service_name;
if (not_empty service)
	select one new_terminator_service related by service->DomainTerminatorService[R5203];

	// unlink and link the terminator service
	if existing_terminator_service != new_terminator_service
		unrelate existing_terminator_service from terminator_service_invocation across R5612;
		relate new_terminator_service to terminator_service_invocation across R5612;
	end if;

	// link the type to the expression
	select one type related by service->BasicType[R5205];
	if (not_empty type)
		relate type to expression across R5570;
	end if;

else
  LOG::LogFailure(message:"Failed to resolve terminator service");
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	6);
INSERT INTO S_SPARM
	VALUES ("5553823a-ad3a-4fec-bdc0-9f7b728f8903",
	"dafc5a91-48fd-4fcd-961a-350711f96eaf",
	'terminator_service_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0cfc70d6-e1ce-4570-b7ed-fadc2bbe88bf",
	"dafc5a91-48fd-4fcd-961a-350711f96eaf",
	'service_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"5553823a-ad3a-4fec-bdc0-9f7b728f8903",
	'');
INSERT INTO PE_PE
	VALUES ("dafc5a91-48fd-4fcd-961a-350711f96eaf",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("52644604-406b-4908-8eec-87492d918120",
	"00000000-0000-0000-0000-000000000000",
	'resolve_FindExpression_type',
	'',
	'expression = param.expression;
select one find_expression related by expression->FindExpression[R5517];
if (not_empty find_expression)
  // for now, assume the root expression is a set
  select one root_type related by find_expression->MaslExpression[R5519]->BasicType[R5570];
  if find_expression.flavor == FindType::find
    relate root_type to expression across R5570;
  elif (find_expression.flavor == FindType::find_one or find_expression.flavor == FindType::find_only)
    select one root_single_type related by root_type->CollectionType[R6205]->BasicType[R6208];
    relate root_single_type to expression across R5570;
  else
    // default to set for ASL find-all
    relate root_type to expression across R5570;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("571e0577-84d0-458a-a437-c456b85fe7f1",
	"52644604-406b-4908-8eec-87492d918120",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("52644604-406b-4908-8eec-87492d918120",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("01643d70-2092-460d-856a-f4ddca302cc7",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NavigationExpression',
	'',
	'expression = param.expression;
select one rel_spec related by expression->NavigationExpression[R5517]->RelationshipSpecification[R5531];
select one lhs_collection related by expression->NavigationExpression[R5517]->MaslExpression[R5532]->BasicType[R5570]->CollectionType[R6205];
select one to_obj_decl related by rel_spec->ObjectDeclaration[R6011];
select one from_obj related by rel_spec->ObjectDeclaration[R6014];
select one using_obj related by rel_spec->RelationshipDeclaration[R6015]->AssociativeRelationshipDeclaration[R6010]->ObjectDeclaration[R6001];

select any nav_type from instances of BasicType where false;

// if the rel spec is a "many" association or the lhs is a collection type,
// assure that the type of the expression is an instance set
if not_empty lhs_collection or ((empty using_obj or using_obj != from_obj) and (rel_spec.multiplicity == MaslMultiplicity::many))
  nav_type = ::select_create_InstanceType(object_declaration:to_obj_decl, isset:true);
else
  nav_type = ::select_create_InstanceType(object_declaration:to_obj_decl, isset:false);
end if;
relate nav_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	7);
INSERT INTO S_SPARM
	VALUES ("da8d8905-9e8b-4627-9a36-e95419bc25d6",
	"01643d70-2092-460d-856a-f4ddca302cc7",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("01643d70-2092-460d-856a-f4ddca302cc7",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	"00000000-0000-0000-0000-000000000000",
	'resolve_UnaryExpression',
	'',
	'operand = param.operand;
op = param.op;

// if the operator is PLUS, it''s a pass through
if op == Operator::plus
  return operand;
end if;

// if the operator is MINUS and this is a numeric literal, simply prepend the literal text
select one numeric_literal related by operand->LiteralExpression[R5517]->NumericLiteral[R5700];
if not_empty numeric_literal and op == Operator::minus
  numeric_literal.text = "-" + numeric_literal.text;
  ::trace(i:44,s:"Numeric negation applied to literal");
  return operand;
end if;

// create unary operation
create object instance expression of MaslExpression;
select one basic_type related by operand->BasicType[R5570];
if ( op == Operator::abs )
  select any builtin_type from instances of BuiltinType where ( "" + selected.name == "integer" );
  select one basic_type related by builtin_type->BasicType[R6205];
end if;
relate basic_type to expression across R5570;
create object instance unary_exp of UnaryExpression;
relate unary_exp to expression across R5517;
unary_exp.operator = op;
relate operand to unary_exp across R5561;

return expression;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	8);
INSERT INTO S_SPARM
	VALUES ("39393a9d-52b6-4c26-9721-018e5ecc16ed",
	"fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	'operand',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5ee4b190-786c-4c3f-9e64-3803b49aa2af",
	"fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	'op',
	"766b5d8d-2e60-4295-a0c6-de1ee59cb168",
	0,
	'',
	"39393a9d-52b6-4c26-9721-018e5ecc16ed",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("766b5d8d-2e60-4295-a0c6-de1ee59cb168",
	"00000000-0000-0000-0000-000000000000",
	'Operator',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/Shared/Shared.xtuml');
INSERT INTO PE_PE
	VALUES ("fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	"00000000-0000-0000-0000-000000000000",
	'resolve_CharacteristicExpression',
	'',
	'expression = param.expression;
base_expression = param.base_expression;

// relate the base expression
select one characteristic related by expression->CallExpression[R5517]->CharacteristicExpression[R5500];
relate base_expression to characteristic across R5504;
select one base_type related by base_expression->BasicType[R5570];


// resolve the result type for characteristic

if characteristic.characteristic == "parse"

  // the result type is the type referenced by the base expression
  relate base_type to expression across R5570;
  
elif characteristic.characteristic == "elements"
  
  // the result type is the sequence type of the given collection type
	select one base_collection related by base_type->CollectionType[R6205];
	if not_empty base_collection
		select one base_element_type related by base_collection->BasicType[R6208];
		select any basic_type related by base_element_type->CollectionType[R6208]->SequenceType[R6207]->CollectionType[R6207]->BasicType[R6205];
		if empty basic_type
			create object instance type_definition of TypeDefinition;
			create object instance basic_type of BasicType;
			basic_type.isanonymous = true;
			create object instance collection_type of CollectionType;
			create object instance sequence_type of SequenceType;
			relate basic_type to type_definition across R6236;
			relate collection_type to basic_type across R6205;
			relate sequence_type to collection_type across R6207;
			relate collection_type to base_element_type across R6208;
		end if;
		relate basic_type to expression across R5570;
	end if;

elif characteristic.characteristic == "length"
  
  // the result type is always integer (only valid for collections)
	select one base_collection related by base_type->CollectionType[R6205];
	if not_empty base_collection
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;

elif characteristic.characteristic == "image"

  // the result type is always string (valid for all types)
  select any string_builtin from instances of BuiltinType where "" + selected.name == "string";
  select one string_type related by string_builtin->BasicType[R6205];
  relate string_type to expression across R5570;

elif characteristic.characteristic == "first" or characteristic.characteristic == "last"
  
  // the result type is integer (only valid for sequences, arrays, and strings)
  select one base_builtin related by base_type->BuiltinType[R6205];
  select one base_collection related by base_type->CollectionType[R6205];
  select one base_sequence related by base_collection->SequenceType[R6207];
  select one base_array related by base_collection->ArrayType[R6207];
  if not_empty base_sequence or not_empty base_array or (not_empty base_builtin and "" + base_builtin.name == "string")
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;

elif characteristic.characteristic == "now"
  
  // the result type is a timestamp (only valid for type timestamp)
  select one base_builtin related by base_type->BuiltinType[R6205];
  if not_empty base_builtin and "" + base_builtin.name == "timestamp"
    relate base_type to expression across R5570;
  end if;

elif characteristic.characteristic == "seconds"
  
  // the result type is integer (only valid for timestamp and duration)
  select one base_builtin related by base_type->BuiltinType[R6205];
  if not_empty base_builtin and ("" + base_builtin.name == "timestamp" or "" + base_builtin.name == "duration")
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;

end if;


// timer specific characteristics
select one base_builtin related by base_type->BuiltinType[R6205];
if not_empty base_builtin and "" + base_builtin.name == "timer"
  if characteristic.characteristic == "delta"
    select any duration_builtin from instances of BuiltinType where "" + selected.name == "duration";
    select one duration_type related by duration_builtin->BasicType[R6205];
    relate duration_type to expression across R5570;
  elif characteristic.characteristic == "scheduled_at" or characteristic.characteristic == "expired_at"
    select any timestamp_builtin from instances of BuiltinType where "" + selected.name == "timestamp";
    select one timestamp_type related by timestamp_builtin->BasicType[R6205];
    relate timestamp_type to expression across R5570;
  elif characteristic.characteristic == "scheduled" or characteristic.characteristic == "expired"
    select any boolean_builtin from instances of BuiltinType where "" + selected.name == "boolean";
    select one boolean_type related by boolean_builtin->BasicType[R6205];
    relate boolean_type to expression across R5570;
  elif characteristic.characteristic == "length"
    select any integer_builtin from instances of BuiltinType where "" + selected.name == "integer";
    select one integer_type related by integer_builtin->BasicType[R6205];
    relate integer_type to expression across R5570;
  end if;
end if;


// TODO fill out for all characteristics',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	6);
INSERT INTO S_SPARM
	VALUES ("4b4444c1-73b2-4a44-b5d0-462af20d03da",
	"d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a45c6504-266a-41e4-aaf9-f5a8a5e7606c",
	"d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	'base_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"4b4444c1-73b2-4a44-b5d0-462af20d03da",
	'');
INSERT INTO PE_PE
	VALUES ("d0c79f76-2f61-4609-950b-4c8fb05f3c31",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	"00000000-0000-0000-0000-000000000000",
	'resolve_LoopSpec',
	'',
	'loop_spec = param.loop_spec;
expression = param.expression;
root_code_block = ::select_CodeBlock_root( code_block:param.current_code_block );

// determine the flavor of loop expression.
// resolve the subtype.
// return the type of the loop variable
::trace(i:75,s:"resolve_LoopSpec with LoopVariable:" + loop_spec.loopVariable );

select any basic_type from instances of BasicType where false;

select one min_max_range related by expression->RangeExpression[R5517]->MinMaxRange[R5540];
if not_empty min_max_range
  create object instance from_to_range of FromToRange;
  relate from_to_range to loop_spec across R5123;
  relate min_max_range to from_to_range across R5111;
  // the type of a min/max range expression is the type of the min or max epression
  // (I arbitrarily choose max because that''s what the C++ model compiler does)
  select one basic_type related by min_max_range->MaslExpression[R5528]->BasicType[R5570];
else
  select one characteristic_expression related by expression->CallExpression[R5517]->CharacteristicExpression[R5500];
  if not_empty characteristic_expression and characteristic_expression.characteristic == "elements"
    create object instance variable_elements of VariableElements;
    relate variable_elements to loop_spec across R5123;
    relate expression to variable_elements across R5139;
    // the type of a variable elements expression is the base type of the collection
    select one basic_type related by expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
  elif not_empty characteristic_expression and characteristic_expression.characteristic == "range"
    select one type_name_expression related by characteristic_expression->MaslExpression[R5504] where false; // TODO need to be able to reference types
    if not_empty type_name_expression
      // TODO
    else
      create object instance variable_range of VariableRange;
      relate variable_range to loop_spec across R5123;
      relate expression to variable_range across R5140;
      // the type of a variable range expression is either the range type (if the variable is an array) or integer
      select one basic_type related by expression->BasicType[R5570]->CollectionType[R6205]->ArrayType[R6207]->MaslExpression[R6201]->BasicType[R5570];
      if empty basic_type
        select any integer_type from instances of BuiltinType where "" + selected.name == "integer";
        select one basic_type related by integer_type->BasicType[R6205];
      end if;
    end if;
  else
    select one collection_type related by expression->BasicType[R5570]->CollectionType[R6205];
    if not_empty collection_type
      create object instance variable_elements of VariableElements;
      relate variable_elements to loop_spec across R5123;
      relate expression to variable_elements across R5139;
      // The type of a variable elements expression is the base type of the collection.
      select one basic_type related by expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
      // Find the VariableDefinition that was created for the loop variable.
      select any variable_definition related by root_code_block->VariableDefinition[R5151] where ( selected.name == loop_spec.loopVariable );
      if ( not_empty variable_definition )
        ::trace(i:77,s:"resolve_LoopSpec found existing loopVariable:  " + loop_spec.loopVariable);
      else
        create object instance variable_definition of VariableDefinition;
        variable_definition.name = loop_spec.loopVariable;
        variable_definition.isreadonly = true;
        relate basic_type to variable_definition across R5137;
        relate variable_definition to root_code_block across R5151;
      end if;
      relate loop_spec to variable_definition across R5154;
      // ASL does structure unpacking.
      // Check to see if the collection is a set of structures.  If so, we need to unpack it.
      select one structure_type related by basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
      if ( not_empty structure_type )
        // Now, unpack and assign types to the input loop variable tuple.
        // Loop through the argument list and the structure members.
        // Assign the types as we go.
        argument_expression = param.argument_list_expression;
        select one structure_element related by structure_type->StructureElement[R6244];
        first = true;
        select any previous_variable_definition from instances of VariableDefinition where false;
        while ( not_empty structure_element and not_empty argument_expression ) 
          // Unrelate the argument_expression BasicType and link the one found on the structure element.
          select one element_basic_type related by structure_element->BasicType[R6230];
          select one argument_basic_type related by argument_expression->BasicType[R5570];
          unrelate argument_basic_type from argument_expression across R5570;
          relate element_basic_type to argument_expression across R5570;
          select one argument_basic_type related by argument_expression->BasicType[R5570];
          select one udt related by element_basic_type->MaslUserDefinedType[R6205];
          if ( not_empty udt )
            //::trace(i:80,s:"LOOPing and linked type:  " + udt.name);
          end if;
          if ( empty element_basic_type or empty argument_basic_type )
            //::trace(i:81,s:"LOOPing EMPTY type:  " );
          end if;
          // Find the name of the tuple member.
          select one variable_definition related by argument_expression->VariableNameExpression[R5517]->VariableDefinition[R5562];
          if ( not_empty variable_definition )
            variable_definition.isreadonly = true;
            if ( first )
              ::trace(i:91,s:"first variable_definition " + variable_definition.name);
              relate variable_definition to loop_spec across R5154;
              first = false;
            else
              if ( empty variable_definition )
                ::trace(i:92,s:"empty variable_definition" );
              end if;
              if ( empty previous_variable_definition )
                ::trace(i:93,s:"empty previous_variable_definition" );
              end if;
              if ( previous_variable_definition == variable_definition )
                ::trace(i:94,s:"variable_definition == previous_variable_definition" );
              end if;
              // Check to see if this tuple member is already related to the next one.
              // This is dubious reuse of the loop variables from a previous context.
              select one link_check related by variable_definition->VariableDefinition[R5164.''succeeds''];
              if ( empty link_check )
                relate variable_definition to previous_variable_definition across R5164.''succeeds'';
              end if;
            end if;
            previous_variable_definition = variable_definition;
            select one basic_type related by variable_definition->BasicType[R5137];
            unrelate basic_type from variable_definition across R5137;
            relate element_basic_type to variable_definition across R5137;
          else
            ::trace(i:83,s:"looping not finding variable_definition" );
          end if;
          ::trace(i:84,s:"resolve_LoopSpec:  looping through argument list and structure members:  " + structure_element.name);
          select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
          select one argument_expression related by argument_expression->Argument[R5577]->Argument[R5576.''precedes'']->MaslExpression[R5577];
        end while;
      else
        ::trace(i:86,s:"resolve_LoopSpec:  did not find set of structures:  " + loop_spec.loopVariable);
      end if;
    else
      ::trace(i:85,s:"resolve_LoopSpec:  ERROR - Could not determine type of loop spec variable:  " + loop_spec.loopVariable);
      ::trace(i:85,s:"resolve_LoopSpec:  Perhaps missing collection type?");
    end if;
  end if;
end if;

return basic_type;',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	1,
	'',
	0,
	9);
INSERT INTO S_SPARM
	VALUES ("616cce8b-3e85-4dc9-b80d-a0fa8bf41f36",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'loop_spec',
	"c60f6c86-bba8-4cc5-b3d8-ebf816da1798",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c60f6c86-bba8-4cc5-b3d8-ebf816da1798",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<LoopSpec>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("1fffd28c-693f-4306-9f26-f85f62d96d68",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"616cce8b-3e85-4dc9-b80d-a0fa8bf41f36",
	'');
INSERT INTO S_SPARM
	VALUES ("9baeb8ad-2be3-4704-a381-118b52a779dd",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'argument_list_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"1fffd28c-693f-4306-9f26-f85f62d96d68",
	'');
INSERT INTO S_SPARM
	VALUES ("6373fb09-e558-4dae-b790-632ba705c6b4",
	"2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	'current_code_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"9baeb8ad-2be3-4704-a381-118b52a779dd",
	'');
INSERT INTO PE_PE
	VALUES ("2b0f2e47-71e0-4f17-85f8-0aa79463d50a",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("f2470f88-fc4a-406d-ba1c-54179e448ed4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<BasicType>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/type/type.xtuml');
INSERT INTO S_SYNC
	VALUES ("d7ab00cc-2a6d-4f76-b901-a5820120a218",
	"00000000-0000-0000-0000-000000000000",
	'resolve_Non_Existent',
	'',
	'object_declaration = param.object_declaration;

select any ne_st related by object_declaration->MaslState[R6105] where "" + selected.name == "Non_Existent";
if empty ne_st
  // create the default Non_Existent state if there is at least one instance state
  select any st related by object_declaration->MaslState[R6105]
    where selected.flavor == StateType::creation or selected.flavor == StateType::terminal or selected.flavor == StateType::normal;
  if not_empty st
    create object instance ne_st of MaslState;
    ne_st.name = "Non_Existent";
    ne_st.flavor = StateType::normal;
    relate ne_st to object_declaration across R6105;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	10);
INSERT INTO S_SPARM
	VALUES ("2c774dea-0025-4e68-a193-43521a97e8e2",
	"d7ab00cc-2a6d-4f76-b901-a5820120a218",
	'object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("d7ab00cc-2a6d-4f76-b901-a5820120a218",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c323ddee-0396-411f-aefc-af182b646bd0",
	"00000000-0000-0000-0000-000000000000",
	'resolve_FindNameExpression',
	'',
	'current_object = param.current_object;

// TODO structure components and array elements

// search for find expression attribute reference
select any attr_ref related by current_object->AttributeDeclaration[R5802] where selected.name == param.name;
if not_empty attr_ref
  create object instance expr of MaslExpression;
  create object instance find_attr_ref of FindAttributeNameExpression;
  relate find_attr_ref to expr across R5517;
  relate attr_ref to find_attr_ref across R5518;
  select one basic_type related by attr_ref->BasicType[R5803];
  relate basic_type to expr across R5570;
  return expr;
end if;

::trace(i:30,s:"Could not resolve find name expression: " + param.name + ", " + param.comp_name);
select any expr from instances of MaslExpression where false;
return expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	2);
INSERT INTO S_SPARM
	VALUES ("a23a4ba1-98db-4823-83b6-a409e1576505",
	"c323ddee-0396-411f-aefc-af182b646bd0",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6c4353eb-d209-43c4-8516-8f5cee805dc6",
	"c323ddee-0396-411f-aefc-af182b646bd0",
	'current_object',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"aeb56ca8-2b1c-431c-a7de-77cb30306d2e",
	'');
INSERT INTO S_SPARM
	VALUES ("aeb56ca8-2b1c-431c-a7de-77cb30306d2e",
	"c323ddee-0396-411f-aefc-af182b646bd0",
	'comp_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"a23a4ba1-98db-4823-83b6-a409e1576505",
	'');
INSERT INTO PE_PE
	VALUES ("c323ddee-0396-411f-aefc-af182b646bd0",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e93ae7d3-47cb-4beb-8d53-ad43ee89cb9a",
	"00000000-0000-0000-0000-000000000000",
	'resolve_CorrelatedNavExpression',
	'',
	'expression = param.expression;
select one rel_spec related by expression->CorrelatedNavExpression[R5517]->RelationshipSpecification[R5507];
select one lhs_collection related by expression->CorrelatedNavExpression[R5517]->MaslExpression[R5506]->BasicType[R5570]->CollectionType[R6205];
select one rhs_collection related by expression->CorrelatedNavExpression[R5517]->MaslExpression[R5508]->BasicType[R5570]->CollectionType[R6205];
select one using_obj_decl related by rel_spec->RelationshipDeclaration[R6015]->AssociativeRelationshipDeclaration[R6010]->ObjectDeclaration[R6001];

select any nav_type from instances of BasicType where false;

// if the rel spec is a "many" association or the lhs is a collection type,
// assure that the type of the expression is an instance set
if not_empty lhs_collection or not_empty rhs_collection
  nav_type = ::select_create_InstanceType(object_declaration:using_obj_decl, isset:true);
else
  nav_type = ::select_create_InstanceType(object_declaration:using_obj_decl, isset:false);
end if;
relate nav_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	7);
INSERT INTO S_SPARM
	VALUES ("e419d58f-f189-4072-81ad-f898450674af",
	"e93ae7d3-47cb-4beb-8d53-ad43ee89cb9a",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("e93ae7d3-47cb-4beb-8d53-ad43ee89cb9a",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	"00000000-0000-0000-0000-000000000000",
	'get_domain_activities',
	'',
	'domain = param.domain;
i = 0;

// TODO consider overloading

// domain services
select many domain_services related by domain->DomainService[R5303]->Service[R5203] where SORT::ascending(attr:"name");
for each domain_service in domain_services
  extension = ".svc";
  select any scenario_mark from instances of Mark where selected.markable_name == "DomainService" and
    selected.feature_name == "scenario" and selected.path == "" + domain.name + "::" + domain_service.name;
  select any external_mark from instances of Mark where selected.markable_name == "DomainService" and
    selected.feature_name == "external" and selected.path == "" + domain.name + "::" + domain_service.name;
  if not_empty scenario_mark
    extension = ".scn";
  elif not_empty external_mark
    extension = ".ext";
  else
  end if;
  param.filenames[i] = "" + domain_service.name + extension;
  ::trace( i:102, s:"get_domain_services:  " + domain_service.name + "  filename:" + param.filenames[i] );
  i = i + 1;
end for;

// terminator services
select many terminators related by domain->DomainTerminator[R5304] where SORT::ascending(attr:"name");
for each terminator in terminators
  select many terminator_services related by terminator->DomainTerminatorService[R5306]->Service[R5203] where SORT::ascending(attr:"name");
  for each terminator_service in terminator_services
    term_name = "" + terminator.name;
    select any key_letter_mark from instances of Mark where selected.markable_name == "DomainTerminator" and
      selected.feature_name == "key_letter" and selected.path == "" + domain.name + "::" + terminator.name;
    if not_empty key_letter_mark
      term_name = key_letter_mark.value;
    end if;
    param.filenames[i] = term_name + "_" + terminator_service.name + ".tr";
    i = i + 1;
  end for;
end for;

select many objs related by domain->ObjectDeclaration[R5805] where SORT::ascending(attr:"name");
for each obj in objs
  obj_name = "" + obj.name;
  select any key_letter_mark from instances of Mark where selected.markable_name == "Object" and
    selected.feature_name == "key_letter" and selected.path == "" + domain.name + "::" + obj.name;
  if not_empty key_letter_mark
    obj_name = key_letter_mark.value;
  end if;
 
  // object and instance services
  select many object_services related by obj->ObjectService[R5808]->Service[R5203] where SORT::ascending(attr:"name");
  for each object_service in object_services
    param.filenames[i] = obj_name + "_" + object_service.name + ".svc";
    i = i + 1;
  end for;

  // states
  select many object_states related by obj->MaslState[R6105] where "" + selected.name != "Non_Existent" and SORT::ascending(attr:"name");
  for each object_state in object_states
    sep = "_";
    if object_state.flavor == StateType::assigner or object_state.flavor == StateType::assigner_start
      sep = "-A_";
    end if;
    param.filenames[i] = obj_name + sep + object_state.name + ".al";
    i = i + 1;
  end for;
end for;

return param.filenames;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	0,
	11);
INSERT INTO S_SPARM
	VALUES ("8d8e6df6-d04a-4727-bc97-fffddbe354c3",
	"dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	'domain',
	"d467079c-c61e-4b05-8498-3fe2f24782a6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6eb13365-4345-4014-aab4-9034b2009c29",
	"dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	'filenames',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	"8d8e6df6-d04a-4727-bc97-fffddbe354c3",
	'');
INSERT INTO S_DIM
	VALUES (0,
	0,
	"00000000-0000-0000-0000-000000000000",
	"6eb13365-4345-4014-aab4-9034b2009c29",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"9e4f9ca3-d051-43d8-9c59-1c4c65a7e72e",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_DIM
	VALUES (0,
	0,
	"dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"920b87a5-4f6b-461e-8335-8dc3fe683387",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO PE_PE
	VALUES ("dbb0edb8-a6e0-4ac6-b7d0-3e5716714f8b",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e07b20ae-d318-4371-8a3d-25598d8c7348",
	"00000000-0000-0000-0000-000000000000",
	'get_project_activities',
	'',
	'project = param.project;
i = 0;

// TODO consider overloading

select many project_domains related by project->ProjectDomain[R5900];
for each project_domain in project_domains
  select one domain related by project_domain->Domain[R5901];

  // terminator services
  select many terminators related by project_domain->ProjectTerminator[R5902] where SORT::ascending(attr:"name");
  for each terminator in terminators
    select many terminator_services related by terminator->ProjectTerminatorService[R5903]->Service[R5203] where SORT::ascending(attr:"name");
    for each terminator_service in terminator_services
      term_name = "" + terminator.name;
      select any key_letter_mark from instances of Mark where selected.markable_name == "ProjectTerminator" and
        selected.feature_name == "key_letter" and selected.path == "" + project.name + "::" + domain.name + "::" + terminator.name;
      if not_empty key_letter_mark
        term_name = key_letter_mark.value;
      end if;
      param.filenames[i] = "" + domain.name + "_" + term_name + "_" + terminator_service.name + ".tr";
      i = i + 1;
    end for;
  end for;

end for;

return param.filenames;',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	0,
	11);
INSERT INTO S_SPARM
	VALUES ("9a245058-496c-450d-b34c-37f45bd5e55c",
	"e07b20ae-d318-4371-8a3d-25598d8c7348",
	'project',
	"441f24d5-1449-4a86-a093-cf7c331418a3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("441f24d5-1449-4a86-a093-cf7c331418a3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Project>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/project/project.xtuml');
INSERT INTO S_SPARM
	VALUES ("c5f07d37-497a-4ef6-b1a8-05d3bcb69b9d",
	"e07b20ae-d318-4371-8a3d-25598d8c7348",
	'filenames',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'[]',
	"9a245058-496c-450d-b34c-37f45bd5e55c",
	'');
INSERT INTO S_DIM
	VALUES (0,
	0,
	"00000000-0000-0000-0000-000000000000",
	"c5f07d37-497a-4ef6-b1a8-05d3bcb69b9d",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"113f6080-99f2-424c-8515-c2278b733370",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_DIM
	VALUES (0,
	0,
	"e07b20ae-d318-4371-8a3d-25598d8c7348",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"d3621d02-96f9-436b-a031-77cd3ffebd07",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO PE_PE
	VALUES ("e07b20ae-d318-4371-8a3d-25598d8c7348",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4f5b7c96-aba1-4f90-974b-ff2812008342",
	"00000000-0000-0000-0000-000000000000",
	'resolve_SliceExpression',
	'',
	'root = param.root;
access_expr = param.access_expr;

// resolve a square bracket access.

select one root_type related by root->BasicType[R5570];
select one access_type related by access_expr->BasicType[R5570];

select one root_collection_type related by root_type->CollectionType[R6205];
select one root_sequence_type related by root_collection_type->SequenceType[R6207];
select one root_array_type related by root_collection_type->ArrayType[R6207];
select one root_string_type related by root_type->BuiltinType[R6205] where "" + selected.name == "string";
select one root_dict_type related by root_type->DictionaryType[R6205];

select one access_range_type related by access_type->CollectionType[R6205]->RangeType[R6207];
select one access_int_type related by access_type->BuiltinType[R6205] where "" + selected.name == "integer";


if (not_empty root_sequence_type or not_empty root_array_type or not_empty root_string_type)

  if not_empty access_range_type
    // TODO slice expression

  elif not_empty access_int_type
    // indexed name expression
    create object instance expr of MaslExpression;
    select one basic_type related by root_collection_type->BasicType[R6208];
    if empty basic_type
      select any char_type from instances of BuiltinType where "" + selected.name == "character";
      select one basic_type related by char_type->BasicType[R6205];
    end if;
    relate basic_type to expr across R5570;
    create object instance indexed_name_expr of IndexedNameExpression;
    relate indexed_name_expr to expr across R5517;
    relate root to indexed_name_expr across R5523;
    relate access_expr to indexed_name_expr across R5522;
    return expr;
  end if;
  
elif not_empty root_dict_type
  
  // TODO dictionary access
  
end if;


LOG::LogFailure(message:"Failed to resolve square bracket access");
select any empty_expr from instances of MaslExpression;
return empty_expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	12);
INSERT INTO S_SPARM
	VALUES ("97c3703a-6687-4176-aaca-381433ea76ea",
	"4f5b7c96-aba1-4f90-974b-ff2812008342",
	'root',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("86483cd5-aa8d-4892-b7fc-cdd237f88abc",
	"4f5b7c96-aba1-4f90-974b-ff2812008342",
	'access_expr',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"97c3703a-6687-4176-aaca-381433ea76ea",
	'');
INSERT INTO PE_PE
	VALUES ("4f5b7c96-aba1-4f90-974b-ff2812008342",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	"00000000-0000-0000-0000-000000000000",
	'ASL_assignment_relink_type',
	'',
	'// ASL supports implicit typing of local variables.
// When a new name is discovered, it is linked to a random type.
// Here we link the lhs expression and the variable definition to the correct type.

lhs = param.lhs;
rhs = param.rhs;

// Look for a service call expression.  If so, there will be no assignment, just the invocation.
select one call_expression related by rhs->CallExpression[R5517];
select one service_invocation related by call_expression->ServiceInvocation[R5500];
if ( not_empty service_invocation )

  // Check for arguments on the LHS.  If so, these are output parameters to an ASL call expression.
  select one argument related by lhs->Argument[R5577];
  position = 0;
  while ( not_empty argument )
    select one argument_expression related by argument->MaslExpression[R5577];
    select one argument_basic_type related by argument_expression->BasicType[R5570];
    // Relink the argument expression to the basic type of the parameter definition.
    basic_type = ::ASL_get_out_parameter_basic_type( call_expression:call_expression, position:position );
    if ( empty basic_type )
      break;
    end if;
    position = position + 1;
    // Look for a variable related to the argument.  If found, relink its type.
    // There is not always a variable; sometimes there is a passed parameter.
    select one variable_definition related by argument_expression->VariableNameExpression[R5517]->VariableDefinition[R5562];
    select one var_basic_type related by variable_definition->BasicType[R5137];
    if not_empty variable_definition
      // only perform the relinking if the variable type is ''unknown_type''
      select one var_internal_type related by var_basic_type->InternalType[R6205];
      if not empty var_internal_type and ("" + var_internal_type.name) == "unknown_type"
        // relink the variable type
        select one var_basic_type related by variable_definition->BasicType[R5137];
        if ( not_empty var_basic_type )
          unrelate variable_definition from var_basic_type across R5137;
        end if;
        relate variable_definition to basic_type across R5137;
      else
        ::trace( i:114, s:"ASL_assignment_relink_type variable type has already been relinked" );
      end if;
    else
      ::trace( i:113, s:"ASL_assignment_relink_type did not find variable_definition" );
    end if;
    select one argument related by argument->Argument[R5576.''precedes''];
  end while;
  
else

  select one var_def related by lhs->VariableNameExpression[R5517]->VariableDefinition[R5562];
  if not_empty var_def
  
    select one rhs_basic_type related by rhs->BasicType[R5570];
    select one lhs_basic_type related by lhs->BasicType[R5570];
    select one var_basic_type related by var_def->BasicType[R5137];
    
    // only perform the relinking if the variable type is ''unknown_type''
    select one var_internal_type related by var_basic_type->InternalType[R6205];
    if empty var_internal_type or ("" + var_internal_type.name) != "unknown_type"
      ::trace( i:114, s:"ASL_assignment_relink_type variable type has already been relinked" );
      return;
    end if;
  
    if ( empty rhs )
      ::trace(i:11,s:"ASL_assignment_relink_type:  no type found on rhs." );
    end if;
    if ( empty rhs_basic_type )
      ::trace(i:12,s:"ASL_assignment_relink_type:  no basic type found on rhs." );
    end if;
    
    // relink the expression type
    if ( empty lhs_basic_type )
      ::trace(i:13,s:"ASL_assignment_relink_type:  no type found on lhs." );
    else
      unrelate lhs from lhs_basic_type across R5570;
    end if;
    relate lhs to rhs_basic_type across R5570;
  
    // relink the variable type
    if ( empty var_basic_type )
      ::trace(i:14,s:"ASL_assignment_relink_type:  no type found on var." );
    else
      unrelate var_def from var_basic_type across R5137;
    end if;
    relate var_def to rhs_basic_type across R5137;
  
  end if;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	13);
INSERT INTO S_SPARM
	VALUES ("102ba935-fe21-49ae-84c0-e6a03fa62417",
	"7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("3848c7d8-000e-4c0c-a711-a73f05f97a68",
	"7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	'rhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"102ba935-fe21-49ae-84c0-e6a03fa62417",
	'');
INSERT INTO PE_PE
	VALUES ("7ccb3b77-1990-48c5-b466-39dbbd6a4fd6",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4ec2754e-fec2-44fb-8563-407f995a6ad0",
	"00000000-0000-0000-0000-000000000000",
	'ASL_structure_instantiation',
	'',
	'// Create a collection type to carry members of the input (structure) basic type.

structure_basic_type = param.basic_type;
expression = param.expression;
current_block = param.current_block;

// 1. Create an assignement statement to be returned and linked to supertype statement.
// 2. Link the expression to the LHS of the assignment.
// 3. If it does not already exist, declare an _empty_set_ variable for zeroing with a set wrapped around it.
// 4. Create an expression to be associated with the _empty_set_ variable.
// 5. link the expression to the RHS of the assignment.
// 6. A variable or parameter for the LHS will exist.  If variable, unlink and relink to correct type.

// 1. Create an assignement statement to be returned and linked to supertype statement.
create object instance assignment_statement of AssignmentStatement;

// 2. Link the expression to the LHS of the assignment.
relate expression to assignment_statement across R5101;
select one lhs_basic_type related by expression->BasicType[R5570];

select one structure_user_defined_type related by structure_basic_type->MaslUserDefinedType[R6205];
select one structure_type related by structure_user_defined_type->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->MaslStructureType[R6219];
if ( empty structure_type )
  ::trace( i:214, s:"ERROR structure instantiation:  no structure" );
end if;

// 3. if it does not already exist, declare an _empty_set_ variable for zeroing with a set wrapped around it.
root_code_block = ::select_CodeBlock_root( code_block:param.current_block );
select any empty_variable_definition related by root_code_block->VariableDefinition[R5151] where ( "" + selected.name == "_empty_set_" + structure_user_defined_type.name );
if ( empty empty_variable_definition )
  ::trace( i:215, s:"structure instantiation:  empty_ being created" );
  // Create a variable definition and expression for empty structure.
  create object instance empty_variable_definition of VariableDefinition;
  empty_variable_definition.name = "_empty_set_" + structure_user_defined_type.name;
  empty_variable_definition.isreadonly = false;
  relate empty_variable_definition to root_code_block across R5151;
  // Create a collection type to wrap around the structure basic type.
  create object instance type_definition of TypeDefinition;
  create object instance basic_type of BasicType;
  basic_type.isanonymous = true;
  create object instance collection_type of CollectionType;
  create object instance sequence_type of SequenceType;
  relate type_definition to basic_type across R6236;
  relate basic_type to collection_type across R6205;
  relate collection_type to sequence_type across R6207;
  relate collection_type to structure_basic_type across R6208;
  relate basic_type to empty_variable_definition across R5137;
  lhs_basic_type = basic_type;
else
  ::trace( i:216, s:"structure instantiation:  empty_ already exists" );
  select one lhs_basic_type related by empty_variable_definition->BasicType[R5137];
end if;

// 4. Create an expression to be associated with the _empty_set_ variable.
create object instance expr of MaslExpression;
relate lhs_basic_type to expr across R5570;
create object instance var_ref of VariableNameExpression;
relate var_ref to expr across R5517;
relate var_ref to empty_variable_definition across R5562;
// 5. link the expression to the RHS of the assignment.
relate expr to assignment_statement across R5100;

// 6. A variable or parameter for the LHS will exist.  If variable, relink to correct type.
select one lhs_variable_definition related by expression->VariableNameExpression[R5517]->VariableDefinition[R5562];
if ( not_empty lhs_variable_definition )
  select one expression_basic_type related by expression->BasicType[R5570];
  select one var_basic_type related by lhs_variable_definition->BasicType[R5137];
  unrelate expression from expression_basic_type across R5570;
  unrelate lhs_variable_definition from var_basic_type across R5137;
  // (Re)link the expression to the newly created collection.
  relate expression to lhs_basic_type across R5570;
  relate lhs_variable_definition to lhs_basic_type across R5137;
end if;

return assignment_statement;
',
	"71dca57b-4d62-4071-b97e-de30ee42722f",
	1,
	'',
	0,
	14);
INSERT INTO S_SPARM
	VALUES ("261c7217-b922-42a4-96fb-0ea1a9ed4821",
	"4ec2754e-fec2-44fb-8563-407f995a6ad0",
	'basic_type',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c8134667-5ff3-4e9d-a543-250649b1e751",
	"4ec2754e-fec2-44fb-8563-407f995a6ad0",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"261c7217-b922-42a4-96fb-0ea1a9ed4821",
	'');
INSERT INTO S_SPARM
	VALUES ("b27d32f3-cca1-471e-8d76-ad5839037ed9",
	"4ec2754e-fec2-44fb-8563-407f995a6ad0",
	'current_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"c8134667-5ff3-4e9d-a543-250649b1e751",
	'');
INSERT INTO PE_PE
	VALUES ("4ec2754e-fec2-44fb-8563-407f995a6ad0",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("71dca57b-4d62-4071-b97e-de30ee42722f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<AssignmentStatement>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SYNC
	VALUES ("efe36786-4b7a-45a0-a64d-a502444a81d1",
	"00000000-0000-0000-0000-000000000000",
	'ASL_basic_type_info',
	'',
	'basic_type = param.basic_type;
label = param.label;
LOG::LogInfo( message:"basic_type_info:  " + label );

select one udt related by basic_type->MaslUserDefinedType[R6205];
if ( not_empty udt )
  LOG::LogInfo( message:"basic_type_info:  UDT.name:  " + udt.name );
else
select one instance_type related by basic_type->InstanceType[R6205];
if ( not_empty instance_type )
  LOG::LogInfo( message:"basic_type_info:  found instance type" );
else
select one collection_type related by basic_type->CollectionType[R6205];
if ( not_empty collection_type )
  LOG::LogInfo( message:"basic_type_info:  found collection type" );
  select one collection_basic_type related by collection_type->BasicType[R6208];
  ::ASL_basic_type_info( basic_type:collection_basic_type, label:"drilling down" );
else
select one builtin_type related by basic_type->BuiltinType[R6205];
if ( not_empty builtin_type )
  LOG::LogInfo( message:"basic_type_info:  found builtin type:  " +builtin_type.name );
else
end if;
end if;
end if;
end if;
select any udt related by basic_type->TypeDefinition[R6236]->TypeDeclaration[R6234]->MaslUserDefinedType[R6241];
if ( not_empty udt )
  LOG::LogInfo( message:"basic_type_info:  upwards UDT.name:  " + udt.name );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	15);
INSERT INTO S_SPARM
	VALUES ("5ba809ef-a797-40e6-9555-4cfb8bfd961f",
	"efe36786-4b7a-45a0-a64d-a502444a81d1",
	'basic_type',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("72acccb5-6961-46c1-8858-e3acc1164a97",
	"efe36786-4b7a-45a0-a64d-a502444a81d1",
	'label',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5ba809ef-a797-40e6-9555-4cfb8bfd961f",
	'');
INSERT INTO PE_PE
	VALUES ("efe36786-4b7a-45a0-a64d-a502444a81d1",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4b618769-988a-420d-9e25-82dd38a026fb",
	"00000000-0000-0000-0000-000000000000",
	'ASL_enumerator_relink_type',
	'',
	'// ASL enumerator variables can be typed or not on second usage.
// Here we link the lhs expression and the variable definition to the correct type.

variable_expression = param.variable_expression;
type_name = param.type_name;
enum_basic_type = ::select_BasicType_where_name( domainname:"", name:type_name );
select one existing_basic_type related by variable_expression->BasicType[R5570];
if ( not_empty existing_basic_type )
  unrelate existing_basic_type from variable_expression across R5570;
end if;
relate enum_basic_type to variable_expression across R5570;

::trace( i:58, s:"Unlinked and relinked type of enumeration expression." );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	16);
INSERT INTO S_SPARM
	VALUES ("52deab9d-05b3-44e7-8229-ca098b6a978d",
	"4b618769-988a-420d-9e25-82dd38a026fb",
	'variable_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("34370e25-911a-4f6d-b348-265e6602b08f",
	"4b618769-988a-420d-9e25-82dd38a026fb",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"52deab9d-05b3-44e7-8229-ca098b6a978d",
	'');
INSERT INTO PE_PE
	VALUES ("4b618769-988a-420d-9e25-82dd38a026fb",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("45378197-fd9e-4ed8-93a0-726f09e20a7d",
	"00000000-0000-0000-0000-000000000000",
	'trace',
	'',
	'number = STRING::itoa( i:param.i );
LOG::LogInfo( message: number + ":  " + param.s );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	17);
INSERT INTO S_SPARM
	VALUES ("5a8343e0-ddce-4b51-a507-ccc07adf093c",
	"45378197-fd9e-4ed8-93a0-726f09e20a7d",
	's',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"726282b0-3930-467c-8486-48e6114ac252",
	'');
INSERT INTO S_SPARM
	VALUES ("726282b0-3930-467c-8486-48e6114ac252",
	"45378197-fd9e-4ed8-93a0-726f09e20a7d",
	'i',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("45378197-fd9e-4ed8-93a0-726f09e20a7d",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2b12a7bd-91e2-4dfe-b231-76668bfdcf74",
	"00000000-0000-0000-0000-000000000000",
	'ASL_structure_assembly',
	'',
	'expression = param.expression;
current_code_block = param.current_block;
select one rhs_expression related by expression->BinaryExpression[R5517]->MaslExpression[R5002];
if ( empty rhs_expression )
  ::trace( i:106, s:"ASL_structure_assembly:  failed to find rhs_expression" );
end if;
select one rhs_basic_type related by rhs_expression->BasicType[R5570];
if ( empty rhs_basic_type )
  ::trace( i:106, s:"ASL_structure_assembly:  failed to find rhs_basic_type" );
end if;
select one structure_basic_type related by rhs_expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
if ( empty structure_basic_type )
  ::trace( i:106, s:"ASL_structure_assembly:  failed to find structure_basic_type" );
  ::ASL_basic_type_info( basic_type:rhs_basic_type, label:"ASL_structure_assembly rhs_basic_type" );
end if;
select one structure_user_defined_type related by structure_basic_type->MaslUserDefinedType[R6205];
if ( not_empty structure_user_defined_type )
  // Create a variable definition and expression for temporary structure.
  root_code_block = ::select_CodeBlock_root( code_block:param.current_block );
  select any var_defn related by root_code_block->VariableDefinition[R5151.''scopes''] where ( "" + selected.name == "temp_" + structure_user_defined_type.name );
  if ( empty var_defn )
    create object instance variable_definition of VariableDefinition;
    variable_definition.name = "temp_" + structure_user_defined_type.name;
    variable_definition.isreadonly = false;
    // ASL has a flat scope for activities.  Relate to outer level CodeBlock.
    relate variable_definition to root_code_block across R5151;
    // create a new variable reference
    create object instance expr of MaslExpression;
    relate structure_basic_type to variable_definition across R5137;
    relate structure_basic_type to expr across R5570;
    create object instance var_ref of VariableNameExpression;
    relate var_ref to expr across R5517;
    relate var_ref to variable_definition across R5562;
    // Create a variable definition and expression for empty structure.
    select any empty_variable_definition related by root_code_block->VariableDefinition[R5151] where ( "" + selected.name == "empty_" + structure_user_defined_type.name );
    if ( empty empty_variable_definition )
      create object instance empty_variable_definition of VariableDefinition;
      empty_variable_definition.name = "empty_" + structure_user_defined_type.name;
      empty_variable_definition.isreadonly = false;
      // ASL has a flat scope for activities.  Relate to outer level CodeBlock.
      relate empty_variable_definition to root_code_block across R5151;
    end if;
    // create a new variable reference
    create object instance expr of MaslExpression;
    relate structure_basic_type to empty_variable_definition across R5137;
    relate structure_basic_type to expr across R5570;
    create object instance var_ref of VariableNameExpression;
    relate var_ref to expr across R5517;
    relate var_ref to empty_variable_definition across R5562;
  end if;
else
  ::trace( i:108, s:"ASL_structure_assembly:  no structure UDT found" );
end if;

return rhs_expression;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	18);
INSERT INTO S_SPARM
	VALUES ("66787805-a66a-475f-a331-27d4de60e333",
	"2b12a7bd-91e2-4dfe-b231-76668bfdcf74",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("fd060124-5874-41d3-9bfd-69e4faeb30d4",
	"2b12a7bd-91e2-4dfe-b231-76668bfdcf74",
	'current_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"66787805-a66a-475f-a331-27d4de60e333",
	'');
INSERT INTO PE_PE
	VALUES ("2b12a7bd-91e2-4dfe-b231-76668bfdcf74",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6a9a6ea0-db8d-41bf-9e0d-1428bc04789c",
	"00000000-0000-0000-0000-000000000000",
	'ASL_link_timer_type',
	'',
	'// Relink input expression basic type to timer type.

lhs = param.lhs;

select one var_def related by lhs->VariableNameExpression[R5517]->VariableDefinition[R5562];
if not_empty var_def

  select one lhs_basic_type related by lhs->BasicType[R5570];
  select one var_basic_type related by var_def->BasicType[R5137];

  // relink the expression type
  if ( empty lhs_basic_type )
    ::trace(i:13,s:"ASL_link_timer_type:  no type found on lhs." );
  else
    unrelate lhs from lhs_basic_type across R5570;
  end if;
  select any builtin_type from instances of BuiltinType where ( ( "" + selected.name ) == "timer" );
  select one timer_basic_type related by builtin_type->BasicType[R6205];
  relate lhs to timer_basic_type across R5570;

  // relink the variable type
  if ( empty var_basic_type )
    ::trace(i:14,s:"ASL_link_timer_type:  no type found on var." );
  else
    unrelate var_def from var_basic_type across R5137;
  end if;
  relate var_def to timer_basic_type across R5137;
  
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	19);
INSERT INTO S_SPARM
	VALUES ("8bf62fb7-4782-4c34-a14c-60f26396b05f",
	"6a9a6ea0-db8d-41bf-9e0d-1428bc04789c",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("6a9a6ea0-db8d-41bf-9e0d-1428bc04789c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9a356292-4fab-46e0-9de4-b50847ebf3d8",
	"00000000-0000-0000-0000-000000000000",
	'ASL_resolve_inferred_referential_identifiers',
	'',
	'// This operation attempts to infer referential identifier attribute
// initializations based on a ''link'' statement later in the same body. This
// operation only supports single instance handles (not sets) and only when the
// instance handle is a transient variable

statement = param.statement;

// search through the code block for create statements
while not empty statement
  select one link_statement related by statement->LinkUnlinkStatement[R5135] where selected.isLink;
  if not empty link_statement
    select one link_rel related by link_statement->RelationshipSpecification[R5120]->RelationshipDeclaration[R6015];
    
    select one lhs related by link_statement->MaslExpression[R5122];
    select one lhs_var related by lhs->VariableNameExpression[R5517]->VariableDefinition[R5562];
    select one rhs related by link_statement->MaslExpression[R5119];
    select one rhs_var related by rhs->VariableNameExpression[R5517]->VariableDefinition[R5562];
    select one uses related by link_statement->MaslExpression[R5121];
    select one uses_var related by uses->VariableNameExpression[R5517]->VariableDefinition[R5562];
    
    // resolve creates associated with the left hand side
    select many lhs_create_smts related by lhs_var->VariableNameExpression[R5562]->MaslExpression[R5517]->AssignmentStatement[R5101]->MaslExpression[R5100]->CreateExpression[R5517]->MaslExpression[R5517]->AssignmentStatement[R5100]->MaslStatement[R5135];
    select any lhs_closest_create from instances of MaslStatement where false;
    for each lhs_create_smt in lhs_create_smts
      if lhs_create_smt.line_number < statement.line_number and (empty lhs_closest_create or lhs_create_smt.line_number > lhs_closest_create.line_number)
        lhs_closest_create = lhs_create_smt;
      end if;
    end for;
    select one lhs_create related by lhs_closest_create->AssignmentStatement[R5135]->MaslExpression[R5100]->CreateExpression[R5517];
    if not empty lhs_create
      select one lhs_object related by lhs_create->ObjectDeclaration[R5511];
      select many lhs_attrs related by lhs_object->AttributeDeclaration[R5802] where selected.isIdentifier and not selected.isUnique;
      for each lhs_attr in lhs_attrs
	    select any lhs_attr_init_attr related by lhs_create->AttributeInitialization[R5566]->AttributeDeclaration[R5565] where selected.name == lhs_attr.name;
	    if empty lhs_attr_init_attr
	      // An identifier attribute has not been initialized. See if we can find a value in the object to link
	      select many rhs_vars from instances of VariableDefinition where false;
	      rhs_vars = rhs_vars | rhs_var;
	      ::create_inferred_attribute_initialization( create_expr: lhs_create, ref_id_attr: lhs_attr, rhs_vars: rhs_vars, link_rel: link_rel);
	    end if;
      end for;
    end if;

    // resolve creates associated with the right hand side
    select many rhs_create_smts related by rhs_var->VariableNameExpression[R5562]->MaslExpression[R5517]->AssignmentStatement[R5101]->MaslExpression[R5100]->CreateExpression[R5517]->MaslExpression[R5517]->AssignmentStatement[R5100]->MaslStatement[R5135];
    select any rhs_closest_create from instances of MaslStatement where false;
    for each rhs_create_smt in rhs_create_smts
      if rhs_create_smt.line_number < statement.line_number and (empty rhs_closest_create or rhs_create_smt.line_number > rhs_closest_create.line_number)
        rhs_closest_create = rhs_create_smt;
      end if;
    end for;
    select one rhs_create related by rhs_closest_create->AssignmentStatement[R5135]->MaslExpression[R5100]->CreateExpression[R5517];
    if not empty rhs_create
      select one rhs_object related by rhs_create->ObjectDeclaration[R5511];
      select many rhs_attrs related by rhs_object->AttributeDeclaration[R5802] where selected.isIdentifier and not selected.isUnique;
      for each rhs_attr in rhs_attrs
	    select any rhs_attr_init_attr related by rhs_create->AttributeInitialization[R5566]->AttributeDeclaration[R5565] where selected.name == rhs_attr.name;
	    if empty rhs_attr_init_attr
	      // An identifier attribute has not been initialized. See if we can find a value in the object to link
	      select many rhs_vars from instances of VariableDefinition where false;
	      rhs_vars = rhs_vars | lhs_var;
	      ::create_inferred_attribute_initialization( create_expr: rhs_create, ref_id_attr: rhs_attr, rhs_vars: rhs_vars, link_rel: link_rel);
	    end if;
      end for;
    end if;

    // resolve creates associated with the associator instance
    select many uses_create_smts related by uses_var->VariableNameExpression[R5562]->MaslExpression[R5517]->AssignmentStatement[R5101]->MaslExpression[R5100]->CreateExpression[R5517]->MaslExpression[R5517]->AssignmentStatement[R5100]->MaslStatement[R5135];
    select any uses_closest_create from instances of MaslStatement where false;
    for each uses_create_smt in uses_create_smts
      if uses_create_smt.line_number < statement.line_number and (empty uses_closest_create or uses_create_smt.line_number > uses_closest_create.line_number)
        uses_closest_create = uses_create_smt;
      end if;
    end for;
    select one uses_create related by uses_closest_create->AssignmentStatement[R5135]->MaslExpression[R5100]->CreateExpression[R5517];
    if not empty uses_create
      select one uses_object related by uses_create->ObjectDeclaration[R5511];
      select many uses_attrs related by uses_object->AttributeDeclaration[R5802] where selected.isIdentifier and not selected.isUnique;
      for each uses_attr in uses_attrs
	    select any uses_attr_init_attr related by uses_create->AttributeInitialization[R5566]->AttributeDeclaration[R5565] where selected.name == uses_attr.name;
	    if empty uses_attr_init_attr
	      // An identifier attribute has not been initialized. See if we can find a value in the object to link
	      select many rhs_vars from instances of VariableDefinition where false;
	      rhs_vars = rhs_vars | lhs_var | rhs_var;
	      ::create_inferred_attribute_initialization( create_expr: uses_create, ref_id_attr: uses_attr, rhs_vars: rhs_vars, link_rel: link_rel);
	    end if;
      end for;
    end if;

  end if;
  
  // if statements
  select one sub_statement related by statement->IfStatement[R5135]->MaslStatement[R5144];
  if not empty sub_statement
    ::ASL_resolve_inferred_referential_identifiers(statement: sub_statement);
  end if;
  
  // if statement alternatives (elif, else)
  select many sub_statements related by statement->IfStatement[R5135]->Alternative[R5145]->MaslStatement[R5148];
  for each sub_statement in sub_statements
    ::ASL_resolve_inferred_referential_identifiers(statement: sub_statement);
  end for;

  // case statement alternatives
  select many sub_statements related by statement->CaseStatement[R5135]->Alternative[R5146]->MaslStatement[R5148];
  for each sub_statement in sub_statements
    ::ASL_resolve_inferred_referential_identifiers(statement: sub_statement);
  end for;

  // for statement
  select one sub_statement related by statement->ForStatement[R5135]->MaslStatement[R5153];
  if not empty sub_statement
    ::ASL_resolve_inferred_referential_identifiers(statement: sub_statement);
  end if;

  // while statement
  select one sub_statement related by statement->WhileStatement[R5135]->MaslStatement[R5141];
  if not empty sub_statement
    ::ASL_resolve_inferred_referential_identifiers(statement: sub_statement);
  end if;

  // code block statement
  select one sub_statement related by statement->CodeBlockStatement[R5135]->MaslCodeBlock[R5163]->MaslStatement[R5150];
  if not empty sub_statement
    ::ASL_resolve_inferred_referential_identifiers(statement: sub_statement);
  end if;

  select one statement related by statement->MaslStatement[R5155.''precedes''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	20);
INSERT INTO S_SPARM
	VALUES ("eb81cf0c-3c58-43f6-b9dc-eded617b0651",
	"9a356292-4fab-46e0-9de4-b50847ebf3d8",
	'statement',
	"05890c89-f4eb-4163-9007-b5abcf03a719",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("05890c89-f4eb-4163-9007-b5abcf03a719",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO PE_PE
	VALUES ("9a356292-4fab-46e0-9de4-b50847ebf3d8",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("907dd3fa-94c8-40c6-bc63-595e3d2704cc",
	"00000000-0000-0000-0000-000000000000",
	'create_inferred_attribute_initialization',
	'',
	'create_expr = param.create_expr;
ref_id_attr = param.ref_id_attr;
rhs_vars = param.rhs_vars;
link_rel = param.link_rel;

select one lhs_object related by ref_id_attr->ObjectDeclaration[R5802];
select any current_block related by rhs_vars->MaslCodeBlock[R5151];

// An identifier attribute has not been initialized. See if we can find a value in the object to link
for each rhs_var in rhs_vars
  select one rhs_object related by rhs_var->BasicType[R5137]->InstanceType[R6205]->ObjectDeclaration[R6220];
  select many rhs_attr_refs related by rhs_object->AttributeDeclaration[R5802]->ReferentialAttributeDefinition[R5800.''is_referenced_by''];
  for each rhs_attr_ref in rhs_attr_refs
    select one referred_to_attr related by rhs_attr_ref->AttributeDeclaration[R5800.''refers_to''];
    select one rel related by rhs_attr_ref->RelationshipSpecification[R5811]->RelationshipDeclaration[R6015];
    select one referring_attr related by rhs_attr_ref->AttributeDeclaration[R5800.''is_referenced_by''];
    select one referring_obj related by referring_attr->ObjectDeclaration[R5802];
    if rel.name == link_rel.name and referring_attr.name == ref_id_attr.name and referring_obj.name == lhs_object.name
      // found a match. create a new attribute initializer
      var_ref_expr = ::resolve_NameExpression(domain_name: "", name: rhs_var.name, current_block: current_block, scope: "", base_name: "", number: "");
      attr_ref_expr = ::create_DotExpression(lhs: var_ref_expr, name: referred_to_attr.name);
      create object instance new_attr_init of AttributeInitialization;
      relate new_attr_init to attr_ref_expr across R5568;
      relate new_attr_init to referring_attr across R5565;
      relate new_attr_init to create_expr across R5566;
      return;
    end if;
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	21);
INSERT INTO S_SPARM
	VALUES ("eb30e82d-108a-46a0-8b46-d8a56af1ee07",
	"907dd3fa-94c8-40c6-bc63-595e3d2704cc",
	'create_expr',
	"5cf91f22-7d2b-48cf-aed2-8f35dd414190",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cf91f22-7d2b-48cf-aed2-8f35dd414190",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<CreateExpression>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO S_SPARM
	VALUES ("2481294f-5701-4439-9e46-8e9326d650c7",
	"907dd3fa-94c8-40c6-bc63-595e3d2704cc",
	'ref_id_attr',
	"bc9fb0af-6887-4a01-9bad-2412058db57c",
	0,
	'',
	"eb30e82d-108a-46a0-8b46-d8a56af1ee07",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bc9fb0af-6887-4a01-9bad-2412058db57c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<AttributeDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("e892ed6d-dabb-44aa-ab3c-8e86566baf06",
	"907dd3fa-94c8-40c6-bc63-595e3d2704cc",
	'rhs_vars',
	"edbae1ce-6fdd-4814-999e-35fec1435572",
	0,
	'',
	"2481294f-5701-4439-9e46-8e9326d650c7",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("edbae1ce-6fdd-4814-999e-35fec1435572",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<VariableDefinition>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("33127950-5741-49bb-962c-dc8f3f635ac5",
	"907dd3fa-94c8-40c6-bc63-595e3d2704cc",
	'link_rel',
	"fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	0,
	'',
	"e892ed6d-dabb-44aa-ab3c-8e86566baf06",
	'');
INSERT INTO PE_PE
	VALUES ("907dd3fa-94c8-40c6-bc63-595e3d2704cc",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fdb4dc6f-3111-41b6-abd0-6b08be436f68",
	"00000000-0000-0000-0000-000000000000",
	'audit_create_unique',
	'',
	'create_expr = param.create_expr;
select one obj related by create_expr->ObjectDeclaration[R5511];
select any non_unique_id_attr related by obj->AttributeDeclaration[R5802] where selected.isIdentifier and not selected.isUnique;
if not empty non_unique_id_attr
  select one domain related by obj->Domain[R5805];
  ::trace(i: 125, s: "WARNING: object " + domain.name + "::" + obj.name + " used in a ''create unique'' expression contains a non-unique identifier attribute");
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	22);
INSERT INTO S_SPARM
	VALUES ("ae8db941-9829-451a-9ddd-b46c80003f5c",
	"fdb4dc6f-3111-41b6-abd0-6b08be436f68",
	'create_expr',
	"5cf91f22-7d2b-48cf-aed2-8f35dd414190",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("fdb4dc6f-3111-41b6-abd0-6b08be436f68",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3c642ebf-38a0-4ca1-8cdb-5ebdaf34ac5c",
	"00000000-0000-0000-0000-000000000000",
	'ASL_resolve_inferred_initial_state',
	'',
	'state = param.state;
statement = param.statement;

select one obj related by state->ObjectDeclaration[R6105];
    
// get the first statement
if empty statement
  select one statement related by state->MaslCodeBlock[R6115]->MaslStatement[R5150];
end if;

// if this is a creation state, search through for create expressions and fill in missing initial state assignments
if state.flavor == StateType::creation
    
  while not empty statement
      
    // in MASL converted from ASL, create expressions will always be the RHS of an assignment statement
    select one create_expr related by statement->AssignmentStatement[R5135]->MaslExpression[R5100]->CreateExpression[R5517];
    if not empty create_expr
      select one create_obj related by create_expr->ObjectDeclaration[R5511];
      select any initial_state related by create_expr->AttributeInitialization[R5566]->MaslState[R5567];
      if create_obj.name == obj.name and empty initial_state
        // create the initialization
        create object instance state_initialization of AttributeInitialization;
        relate state to state_initialization across R5567;
        relate state_initialization to create_expr across R5566;
      end if;
    end if;

    // if statements
    select one sub_statement related by statement->IfStatement[R5135]->MaslStatement[R5144];
    if not empty sub_statement
      ::ASL_resolve_inferred_initial_state(state: state, statement: sub_statement);
    end if;
    
    // if statement alternatives (elif, else)
    select many sub_statements related by statement->IfStatement[R5135]->Alternative[R5145]->MaslStatement[R5148];
    for each sub_statement in sub_statements
      ::ASL_resolve_inferred_initial_state(state: state, statement: sub_statement);
    end for;

    // case statement alternatives
    select many sub_statements related by statement->CaseStatement[R5135]->Alternative[R5146]->MaslStatement[R5148];
    for each sub_statement in sub_statements
      ::ASL_resolve_inferred_initial_state(state: state, statement: sub_statement);
    end for;

    // for statement
    select one sub_statement related by statement->ForStatement[R5135]->MaslStatement[R5153];
    if not empty sub_statement
      ::ASL_resolve_inferred_initial_state(state: state, statement: sub_statement);
    end if;

    // while statement
    select one sub_statement related by statement->WhileStatement[R5135]->MaslStatement[R5141];
    if not empty sub_statement
      ::ASL_resolve_inferred_initial_state(state: state, statement: sub_statement);
    end if;

    // code block statement
    select one sub_statement related by statement->CodeBlockStatement[R5135]->MaslCodeBlock[R5163]->MaslStatement[R5150];
    if not empty sub_statement
      ::ASL_resolve_inferred_initial_state(state: state, statement: sub_statement);
    end if;

    select one statement related by statement->MaslStatement[R5155.''precedes''];
  end while;
    
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	20);
INSERT INTO S_SPARM
	VALUES ("f9b7c97a-8d38-4247-9015-e5cc49f0010f",
	"3c642ebf-38a0-4ca1-8cdb-5ebdaf34ac5c",
	'state',
	"640e9a30-074e-45fd-aa2b-fdcc3fc56f5b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("640e9a30-074e-45fd-aa2b-fdcc3fc56f5b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statemodel/statemodel.xtuml');
INSERT INTO S_SPARM
	VALUES ("e3a018b5-3f43-43b8-a28f-2e7bd5114436",
	"3c642ebf-38a0-4ca1-8cdb-5ebdaf34ac5c",
	'statement',
	"05890c89-f4eb-4163-9007-b5abcf03a719",
	0,
	'',
	"f9b7c97a-8d38-4247-9015-e5cc49f0010f",
	'');
INSERT INTO PE_PE
	VALUES ("3c642ebf-38a0-4ca1-8cdb-5ebdaf34ac5c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5245f3d5-3b14-447e-95a1-52f1b06c2779",
	"00000000-0000-0000-0000-000000000000",
	'ASL_resolve_schedule_statement',
	'',
	'select any schedule_statement from instances of ScheduleStatement where false;
arg = param.first_argument;

// gather arguments
// Arg 1 = timer expression
select any prev_arg from instances of Argument where false;
select one timer_expr related by arg->MaslExpression[R5577];
if not empty prev_arg
  unrelate arg from prev_arg across R5576.''follows'';
end if;

// Arg 2 = delay as an integer
prev_arg = arg;
select one arg related by arg->Argument[R5576.''precedes''];
select one delay_expr related by arg->MaslExpression[R5577]->LiteralExpression[R5517]->NumericLiteral[R5700]->IntegerLiteral[R5703];
if not empty prev_arg
  unrelate arg from prev_arg across R5576.''follows'';
end if;

// Arg 3 time unit as a string literal - either "MILLISECOND" or "SECOND"
prev_arg = arg;
select one arg related by arg->Argument[R5576.''precedes''];
select one unit_expr related by arg->MaslExpression[R5577]->LiteralExpression[R5517]->StringLiteral[R5700];
if not empty prev_arg
  unrelate arg from prev_arg across R5576.''follows'';
end if;

// Arg 4 = event to generate as an event expression
prev_arg = arg;
select one arg related by arg->Argument[R5576.''precedes''];
select one event_expr related by arg->MaslExpression[R5577]->EventExpression[R5517];
if not empty prev_arg
  unrelate arg from prev_arg across R5576.''follows'';
end if;

// Arg 5 = target instance
prev_arg = arg;
select one arg related by arg->Argument[R5576.''precedes''];
select one target_expr related by arg->MaslExpression[R5577];
if not empty prev_arg
  unrelate arg from prev_arg across R5576.''follows'';
end if;

// if all required arguments are present, create the schedule statement
if not empty timer_expr and not empty delay_expr and not empty unit_expr and not empty event_expr and not empty target_expr
    
  create object instance schedule_statement of ScheduleStatement;
  schedule_statement.isAbsolute = false;
  schedule_statement.timeUnit = unit_expr.noQuotes;
  
  // link to the timer handle
  relate timer_expr to schedule_statement across R5132;
  
  // create the duration expression from the delay value and unit
  create object instance duration_expr of MaslExpression;
  create object instance call_expr of CallExpression;
  relate call_expr to duration_expr across R5517;
  select any builtin_type from instances of BuiltinType where ( "" + selected.name == "duration" );
  select one basic_type related by builtin_type->BasicType[R6205];
  relate basic_type to duration_expr across R5570;
  create object instance characteristic_expression of CharacteristicExpression;
  if schedule_statement.timeUnit == "SECOND"
    characteristic_expression.characteristic = "seconds";
  elif schedule_statement.timeUnit == "MILLISECOND"
    characteristic_expression.characteristic = "milliseconds";
  else
    characteristic_expression.characteristic = schedule_statement.timeUnit;
    ::trace(i:302,s:"ASL_resolve_schedule_statement:  ERROR - Unrecognized time unit: " + schedule_statement.timeUnit);
  end if;
  characteristic_expression.number_of_arguments = 1;
  characteristic_expression.allowAsPrefix = false;
  relate characteristic_expression to call_expr across R5500;
  create object instance type_expr of MaslExpression;
  create object instance duration_type_expr of TypeNameExpression;
  relate duration_type_expr to type_expr across R5517;
  relate basic_type to duration_type_expr across R5578;
  relate type_expr to characteristic_expression across R5504;
  select one duration_arg related by delay_expr->NumericLiteral[R5703]->LiteralExpression[R5700]->MaslExpression[R5517]->Argument[R5577];
  relate duration_arg to call_expr across R5575;
  relate duration_expr to schedule_statement across R5130;
  
  // create the generate statement
  create object instance smt of MaslStatement;
  create object instance generate_smt of GenerateStatement;
  relate generate_smt to smt across R5135;
  relate generate_smt to schedule_statement across R5129;
  
  // link the event declaration
  select one event_decl related by event_expr->EventDeclaration[R5516];
  relate event_decl to generate_smt across R5112;
  
  // link the target expression
  relate target_expr to generate_smt across R5113;
  
  // ASL timed events never have arguments
    
else
  ::trace(i:301,s:"ASL_resolve_schedule_statement:  ERROR - Malformed ''generate TIM1:Set_Timer'' statement");
end if;

return schedule_statement;',
	"3308c2f3-61d3-4fc1-8818-9897c77e99fe",
	1,
	'',
	0,
	23);
INSERT INTO S_SPARM
	VALUES ("da18bd87-2969-4a80-a7fa-701afa61f688",
	"5245f3d5-3b14-447e-95a1-52f1b06c2779",
	'first_argument',
	"55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("5245f3d5-3b14-447e-95a1-52f1b06c2779",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("3308c2f3-61d3-4fc1-8818-9897c77e99fe",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ScheduleStatement>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SYNC
	VALUES ("a5b75b86-1d5e-4ac7-b64f-ba2b9e4e87f9",
	"00000000-0000-0000-0000-000000000000",
	'ASL_resolve_schedule_time_units',
	'',
	'// find any characteristic ''scheduled_at'' expressions. Navigate up to the top
// level characteristic expression and modify the time unit.

select many scheduled_at_characteristics from instances of CharacteristicExpression where selected.characteristic == "scheduled_at";
for each scheduled_at_characteristic in scheduled_at_characteristics
    
  select one root_characteristic related by scheduled_at_characteristic->CallExpression[R5500]->MaslExpression[R5517]->BinaryExpression[R5001]->MaslExpression[R5517]->CharacteristicExpression[R5504];
  if not empty root_characteristic
      
    // assume that timer expressions for Get_Time_Remaining and Set_Timer are only attribute accesses
    select any schedule_smt related by scheduled_at_characteristic->MaslExpression[R5504]->SelectedAttributeExpression[R5517]->AttributeDeclaration[R5541]->SelectedAttributeExpression[R5541]->MaslExpression[R5517]->ScheduleStatement[R5132];
    if not empty schedule_smt
      if schedule_smt.timeUnit == "SECOND"
        root_characteristic.characteristic = "seconds";
      elif schedule_smt.timeUnit == "MILLISECOND"
        root_characteristic.characteristic = "milliseconds";
      end if;
    end if;

  end if;
    
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	24);
INSERT INTO PE_PE
	VALUES ("a5b75b86-1d5e-4ac7-b64f-ba2b9e4e87f9",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("fa715298-1ee7-4f4d-9dc6-ff741962c501",
	1,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO S_SYS_PROXY
	VALUES ("e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	'stratus',
	1,
	'../stratus.xtuml');
