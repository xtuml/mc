T_b("/*----------------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* File:  ");
T_b(te_file->callout);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* Description:");
T_b("\n");
T_b(" ");
T_b("* Function declarations for user supplied (non-translated) call out entry");
T_b("\n");
T_b(" ");
T_b("* points in the generated application.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_copyright->body);
T_b("\n");
T_b(" ");
T_b("*--------------------------------------------------------------------------*/");
T_b("\n");
T_b("#ifndef ");
T_b(te_prefix->define_usw);
T_b(te_file->callout);
T_b("_");
T_b(te_file->hdr_file_ext);
T_b("\n");
T_b("#define ");
T_b(te_prefix->define_usw);
T_b(te_file->callout);
T_b("_");
T_b(te_file->hdr_file_ext);
T_b("\n");
T_b(te_target->c2cplusplus_linkage_begin);
T_b("\n");
if ( ( te_sys->AUTOSAR ) || ( te_sys->VFB ) ) {
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Default to enabling the AUTOSAR-specific code.  Turn it off by commenting");
T_b("\n");
T_b(" ");
T_b("* out the following directive.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("#define ");
T_b(te_thread->AUTOSAR_enabled);
T_b(" 1");
T_b("\n");
}
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->initialization);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked at the immediate beginning of application");
T_b("\n");
T_b(" ");
T_b("* initialization. It is the very first function to be executed at system");
T_b("\n");
T_b(" ");
T_b("* startup.");
T_b("\n");
T_b(" ");
T_b("* User supplied implementation of this function should be restricted to");
T_b("\n");
T_b(" ");
T_b("* things like memory initialization, early hardware duties, etc.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->initialization);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.");
T_b("\n");
if ( 0==strcmp("C",te_target->language) ) {
T_b("   ");
T_b("(activated by default...  Uncomment to deactivate.)");
T_b("\n");
T_b("#define ");
T_b(te_callout->initialization);
T_b("()");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
} else {
T_b(" ");
T_b("*/");
T_b("\n");
T_b("#define ");
T_b(te_callout->initialization);
T_b("()");
T_b("\n");
}
T_b("#ifndef ");
T_b(te_callout->initialization);
T_b("\n");
T_b("#define ");
T_b(te_callout->initialization);
T_b("() ");
T_b(te_callout->initialization);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->pre_xtUML_initialization);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked immediately prior to executing any xtUML");
T_b("\n");
T_b(" ");
T_b("* initialization functions.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->pre_xtUML_initialization);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->pre_xtUML_initialization);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->pre_xtUML_initialization);
T_b("\n");
T_b("#define ");
T_b(te_callout->pre_xtUML_initialization);
T_b("() ");
T_b(te_callout->pre_xtUML_initialization);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->post_xtUML_initialization);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked immediately after executing any xtUML");
T_b("\n");
T_b(" ");
T_b("* initialization functions.");
T_b("\n");
T_b(" ");
T_b("* When this callout function returns, the system dispatcher will allow the");
T_b("\n");
T_b(" ");
T_b("* xtUML application analysis state models to start consuming events.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->post_xtUML_initialization);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->post_xtUML_initialization);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->post_xtUML_initialization);
T_b("\n");
T_b("#define ");
T_b(te_callout->post_xtUML_initialization);
T_b("() ");
T_b(te_callout->post_xtUML_initialization);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->background_processing);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked once during each loop execution of the system");
T_b("\n");
T_b(" ");
T_b("* dispather.");
T_b("\n");
T_b(" ");
T_b("* It is invoked at the 'top' of the system dispatcher loop, immediately");
T_b("\n");
T_b(" ");
T_b("* prior to dispatching any xtUML application analysis events.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->background_processing);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.");
T_b("\n");
if ( 0==strcmp("C",te_target->language) ) {
T_b("   ");
T_b("(activated by default...  Uncomment to deactivate.)");
T_b("\n");
T_b("#define ");
T_b(te_callout->background_processing);
T_b("()");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
} else {
T_b(" ");
T_b("*/");
T_b("\n");
T_b("#define ");
T_b(te_callout->background_processing);
T_b("()");
T_b("\n");
}
T_b("#ifndef ");
T_b(te_callout->background_processing);
T_b("\n");
T_b("#define ");
T_b(te_callout->background_processing);
T_b("() ");
T_b(te_callout->background_processing);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->pre_shutdown);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked at termination of the system dispatcher, but");
T_b("\n");
T_b(" ");
T_b("* prior to performing any xtUML application analysis shutdown sequencing.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->pre_shutdown);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->pre_shutdown);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->pre_shutdown);
T_b("\n");
T_b("#define ");
T_b(te_callout->pre_shutdown);
T_b("() ");
T_b(te_callout->pre_shutdown);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->post_shutdown);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked immediately before application exit.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->post_shutdown);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->post_shutdown);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->post_shutdown);
T_b("\n");
T_b("#define ");
T_b(te_callout->post_shutdown);
T_b("() ");
T_b(te_callout->post_shutdown);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->event_cant_happen);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked any time that an event is received that");
T_b("\n");
T_b(" ");
T_b("* results in a \"cant happen\" transition.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->event_cant_happen);
T_b("f( const ");
T_b(te_typemap->state_number_name);
T_b(",");
T_b("\n");
T_b("                                         ");
T_b("const ");
T_b(te_typemap->state_number_name);
T_b(",");
T_b("\n");
T_b("                                         ");
T_b("const ");
T_b(te_typemap->event_number_name);
T_b(" );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->event_cant_happen);
T_b("( s1, s2, e )");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->event_cant_happen);
T_b("\n");
T_b("#define ");
T_b(te_callout->event_cant_happen);
T_b("( s1, s2, e ) ");
T_b(te_callout->event_cant_happen);
T_b("f( s1, s2, e )");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->event_no_instance);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when we failed to validate the instance");
T_b("\n");
T_b(" ");
T_b("* to which an event was directed.  This can happen in normal operation");
T_b("\n");
T_b(" ");
T_b("* when the instance was deleted while the event was in flight (analysis");
T_b("\n");
T_b(" ");
T_b("* error).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->event_no_instance);
T_b("f( const ");
T_b(te_typemap->event_number_name);
T_b(" );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->event_no_instance);
T_b("( e )");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->event_no_instance);
T_b("\n");
T_b("#define ");
T_b(te_callout->event_no_instance);
T_b("( e ) ");
T_b(te_callout->event_no_instance);
T_b("f( e )");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->event_free_list_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to allocate an");
T_b("\n");
T_b(" ");
T_b("* event, but there are no more left.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->event_free_list_empty);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->event_free_list_empty);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->event_free_list_empty);
T_b("\n");
T_b("#define ");
T_b(te_callout->event_free_list_empty);
T_b("() ");
T_b(te_callout->event_free_list_empty);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->empty_handle_detected);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to use an instance");
T_b("\n");
T_b(" ");
T_b("* reference variable (handle) that is null (empty).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->empty_handle_detected);
T_b("f( c_t *, c_t * );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->empty_handle_detected);
T_b("( s1, s2 )");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->empty_handle_detected);
T_b("\n");
T_b("#define ");
T_b(te_callout->empty_handle_detected);
T_b("( s1, s2 ) ");
T_b(te_callout->empty_handle_detected);
T_b("f( (c_t *) s1, (c_t *) s2 )");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->object_pool_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to create an");
T_b("\n");
T_b(" ");
T_b("* instance of an object, but there are no instances available.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->object_pool_empty);
T_b("f( const ");
T_b(te_typemap->domain_number_name);
T_b(", const ");
T_b(te_typemap->object_number_name);
T_b(" );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.");
T_b("\n");
T_b("   ");
T_b("(activated by default...  Uncomment to deactivate.)");
T_b("\n");
T_b("#define ");
T_b(te_callout->object_pool_empty);
T_b("( s1, s2 )");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->object_pool_empty);
T_b("\n");
T_b("#define ");
T_b(te_callout->object_pool_empty);
T_b("( s1, s2 ) ");
T_b(te_callout->object_pool_empty);
T_b("f( s1, s2 )");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->node_list_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to allocate a");
T_b("\n");
T_b(" ");
T_b("* node, but there are no more left.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->node_list_empty);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->node_list_empty);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->node_list_empty);
T_b("\n");
T_b("#define ");
T_b(te_callout->node_list_empty);
T_b("() ");
T_b(te_callout->node_list_empty);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when an attempt is made to post too many");
T_b("\n");
T_b(" ");
T_b("* interleaved bridges.  The depth of this list is defined by");
T_b("\n");
T_b(" ");
T_b("* SYS_MAX_INTERLEAVED_BRIDGES (unless changed in the archetype).");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("\n");
T_b("#define ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("() ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->self_event_queue_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when the events to self queue is");
T_b("\n");
T_b(" ");
T_b("* interrogated and found to be empty.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->self_event_queue_empty);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->self_event_queue_empty);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->self_event_queue_empty);
T_b("\n");
T_b("#define ");
T_b(te_callout->self_event_queue_empty);
T_b("() ");
T_b(te_callout->self_event_queue_empty);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->non_self_event_queue_empty);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when the events to instance queue is");
T_b("\n");
T_b(" ");
T_b("* interrogated and found to be empty.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->non_self_event_queue_empty);
T_b("f( void );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->non_self_event_queue_empty);
T_b("()");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->non_self_event_queue_empty);
T_b("\n");
T_b("#define ");
T_b(te_callout->non_self_event_queue_empty);
T_b("() ");
T_b(te_callout->non_self_event_queue_empty);
T_b("f()");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_callout->persistence_error);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* This function is invoked when trouble is detected reading from");
T_b("\n");
T_b(" ");
T_b("* or writing to persistent storage.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_callout->persistence_error);
T_b("f( i_t );");
T_b("\n");
T_b("/* The following empty definition renders the callout hook invisible.");
T_b("\n");
T_b("   ");
T_b("Delete or comment out the following define to activate the in line");
T_b("\n");
T_b("   ");
T_b("hook for this callout.  */");
T_b("\n");
T_b("#define ");
T_b(te_callout->persistence_error);
T_b("( i1 )");
T_b("\n");
T_b("#ifndef ");
T_b(te_callout->persistence_error);
T_b("\n");
T_b("#define ");
T_b(te_callout->persistence_error);
T_b("( i1 ) ");
T_b(te_callout->persistence_error);
T_b("f( i1 )");
T_b("\n");
T_b("#endif");
T_b("\n");
T_b(te_target->c2cplusplus_linkage_end);
T_b("\n");
T_b("#endif  /* ");
T_b(te_prefix->define_usw);
T_b(te_file->callout);
T_b("_");
T_b(te_file->hdr_file_ext);
T_b(" */");
T_b("\n");
