T_b("/*---------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* File:  ");
T_b(te_file->thread);
T_b(".");
T_b(te_file->src_file_ext);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* Description:");
T_b("\n");
T_b(" ");
T_b("* This file provides implementation of multi-tasking/threading");
T_b("\n");
T_b(" ");
T_b("* capabilities allowing classes/subsystems to run in different");
T_b("\n");
T_b(" ");
T_b("* threads on a multi-tasking/threading OS/RTOS.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_copyright->body);
T_b("\n");
T_b(" ");
T_b("*-------------------------------------------------------------------*/");
T_b("\n");
T_b("#include <osx.h>   /* OSX declarations */");
T_b("\n");
T_b("#include \"");
T_b(te_file->types);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
if ( te_sys->MaxTimers > 0 ) {
T_b("#include \"");
T_b(te_file->tim);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
}
T_b("static osxHANDLE mutices[ SEMAPHORE_FLAVOR_MAX ];");
T_b("\n");
T_b("static osxHANDLE nonbusy_wait_cond[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("static u1_t threadnumber[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Initialize those structures that need to be set up once at system");
T_b("\n");
T_b(" ");
T_b("* bring-up time.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_prefix->result);
T_b("InitializeThreading( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t i;");
T_b("\n");
T_b("  ");
T_b("ul_t rc;");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < NUM_OF_TOTAL_THREADS; i++ ) {");
T_b("\n");
T_b("    ");
T_b("threadnumber[ i ] = i;");
T_b("\n");
T_b("    ");
T_b("rc = osxCreateSemaphore( 0, 1, &nonbusy_wait_cond[ i ] );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < SEMAPHORE_FLAVOR_MAX; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = osxCreateSemaphore( 1, 1, &mutices[ i ] );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Obtain a resource lock so that this thread has mutually exclusive");
T_b("\n");
T_b(" ");
T_b("* access.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->mutex_lock);
T_b("( const u1_t flavor )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("ul_t rc = osxAcquireSemaphore( mutices[ flavor ], eOSX_WAIT_FOREVER, 0 );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Release a resource lock that was obtained with the lock method.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->mutex_unlock);
T_b("( const u1_t flavor )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("ul_t rc = osxReleaseSemaphore( mutices[ flavor ] );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Go into a non-busy wait state waiting on someone to wake us");
T_b("\n");
T_b(" ");
T_b("* up with the nonbusy_wake method.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->nonbusy_wait);
T_b("( const u1_t thread )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("extern bool bSimulation;");
T_b("\n");
T_b("  ");
T_b("ul_t timeout, rc;");
T_b("\n");
T_b("  ");
T_b("timeout = ( bSimulation ) ? SIMULATE_25MS_STROBE : WAIT_TIMEOUT_MS;");
T_b("\n");
T_b("  ");
T_b("rc = osxAcquireSemaphore( nonbusy_wait_cond[ thread ], eOSX_WAIT_FOREVER, timeout );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Wake up a thread that went to sleep waiting for something to happen.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->nonbusy_wake);
T_b("( const u1_t thread )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("ul_t rc;");
T_b("\n");
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_NONBUSY );");
T_b("\n");
T_b("  ");
T_b("rc = osxReleaseSemaphore( nonbusy_wait_cond[ thread ] );");
T_b("\n");
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_NONBUSY );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Create and spin off a task/thread to run the input routine.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->create);
T_b("( void *(routine)(void *), const u1_t i )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("osxTaskHandle_t handle;");
T_b("\n");
T_b("  ");
T_b("ul_t rc;");
T_b("\n");
T_b("  ");
T_b("rc = osxBeginTask(");
T_b("\n");
T_b("    ");
T_b("( void ( * )( void * ) ) routine,");
T_b("\n");
T_b("    ");
T_b("45000,");
T_b("\n");
T_b("    ");
T_b("( i == 0 ) ? osxTHREAD_PRIORITY_HIGHEST : osxTHREAD_PRIORITY_NORMAL,");
T_b("\n");
T_b("    ");
T_b("&threadnumber[ i ],");
T_b("\n");
T_b("    ");
T_b("( osxTaskHandle_t * ) &handle );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Cleanup the structures initialized in ");
T_b(te_prefix->result);
T_b("InitializeThreading.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->shutdown);
T_b("( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t i;");
T_b("\n");
T_b("  ");
T_b("ul_t rc;");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < NUM_OF_TOTAL_THREADS; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = osxDeleteSemaphore( nonbusy_wait_cond[ i ] );");
T_b("\n");
T_b("    ");
T_b("nonbusy_wait_cond[ i ] = 0;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < SEMAPHORE_FLAVOR_MAX; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = osxDeleteSemaphore( mutices[ i ] );");
T_b("\n");
T_b("    ");
T_b("mutices[ i ] = 0;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
