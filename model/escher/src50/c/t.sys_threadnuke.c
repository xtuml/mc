T_b("/*---------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* File:  ");
T_b(te_file->thread);
T_b(".");
T_b(te_file->src_file_ext);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* Description:");
T_b("\n");
T_b(" ");
T_b("* This file provides implementation of multi-tasking/threading");
T_b("\n");
T_b(" ");
T_b("* capabilities allowing classes/subsystems to run in different");
T_b("\n");
T_b(" ");
T_b("* threads on a multi-tasking/threading OS/RTOS.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_copyright->body);
T_b("\n");
T_b(" ");
T_b("*-------------------------------------------------------------------*/");
T_b("\n");
T_b("#include \"");
T_b(te_file->types);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
T_b("extern VOID Escher_main( UNSIGNED, VOID * );");
T_b("\n");
T_b("static UNSIGNED ");
T_b(te_prefix->result);
T_b("task_stack_depth = 4096; /* default */");
T_b("\n");
T_b("static NU_MEMORY_POOL * ");
T_b(te_prefix->result);
T_b("memory_pool; /* ptr to stack space */");
T_b("\n");
T_b("static NU_SEMAPHORE mutices[ SEMAPHORE_FLAVOR_MAX ];");
T_b("\n");
T_b("static NU_TASK xtUML_tasks[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("static u1_t xtUML_task_priorities[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("static u1_t threadnumber[ NUM_OF_TOTAL_THREADS ];");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Initialize those structures that need to be set up once at system");
T_b("\n");
T_b(" ");
T_b("* bring-up time.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_prefix->result);
T_b("InitializeThreading( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t i;");
T_b("\n");
T_b("  ");
T_b("STATUS rc;");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < NUM_OF_TOTAL_THREADS; i++ ) {");
T_b("\n");
T_b("    ");
T_b("threadnumber[ i ] = i;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < SEMAPHORE_FLAVOR_MAX; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = NU_Create_Semaphore( &mutices[ i ], \"esc_sems\", 1, NU_FIFO );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Obtain a resource lock so that this thread has mutually exclusive");
T_b("\n");
T_b(" ");
T_b("* access.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->mutex_lock);
T_b("( const u1_t flavor )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("STATUS rc = NU_Obtain_Semaphore( &mutices[ flavor ], NU_SUSPEND );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Release a resource lock that was obtained with the lock method.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->mutex_unlock);
T_b("( const u1_t flavor )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("STATUS rc = NU_Release_Semaphore( &mutices[ flavor ] );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Go into a non-busy wait state waiting on someone to wake us");
T_b("\n");
T_b(" ");
T_b("* up with the nonbusy_wake method.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->nonbusy_wait);
T_b("( const u1_t thread )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("STATUS rc = NU_Suspend_Task( &xtUML_tasks[ thread ] );");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Wake up a thread that went to sleep waiting for something to happen.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->nonbusy_wake);
T_b("( const u1_t thread )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("STATUS rc = NU_Resume_Task( &xtUML_tasks[ thread ] );");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Create and spin off a task/thread to run the input routine.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("typedef void (*fp)(UNSIGNED, VOID *);");
T_b("\n");
T_b("void ");
T_b(te_thread->create);
T_b("( void (routine)(UNSIGNED, void *), const u1_t i )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("VOID * stack_ptr;");
T_b("\n");
T_b("  ");
T_b("STATUS rc = NU_Allocate_Memory(");
T_b("\n");
T_b("    ");
T_b(te_prefix->result);
T_b("memory_pool,               /* system dynamic memory pool */");
T_b("\n");
T_b("    ");
T_b("&stack_ptr,                /* return pointer to allocated block */");
T_b("\n");
T_b("    ");
T_b(te_prefix->result);
T_b("task_stack_depth,                      /* depth of stack */");
T_b("\n");
T_b("    ");
T_b("NU_NO_SUSPEND );             /* whether to suspend if no memory */");
T_b("\n");
T_b("  ");
T_b("rc = NU_Create_Task(");
T_b("\n");
T_b("    ");
T_b("&xtUML_tasks[ i ],       /* pointer to task control block (TCB) */");
T_b("\n");
T_b("    ");
T_b("\"BPMC3020\",                        /* alphabetic name for tasks */");
T_b("\n");
T_b("    ");
T_b("(fp) routine,                               /* task entry point */");
T_b("\n");
T_b("    ");
T_b("i,                                  /* integer for passing data */");
T_b("\n");
T_b("    ");
T_b("&threadnumber[ i ],               /* pointer to the task number */");
T_b("\n");
T_b("    ");
T_b("stack_ptr,                  /* pointer to block of stack memory */");
T_b("\n");
T_b("    ");
T_b(te_prefix->result);
T_b("task_stack_depth,                 /* size of stack block */");
T_b("\n");
T_b("    ");
T_b("xtUML_task_priorities[ i ],            /* priority of this task */");
T_b("\n");
T_b("    ");
T_b("0,                    /* time slicing control - no time slicing */");
T_b("\n");
T_b("    ");
T_b("NU_PREEMPT,                              /* preemptibility flag */");
T_b("\n");
T_b("    ");
T_b("NU_START );                            /* Go ready right away.  */");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Create the default xtUML task.");
T_b("\n");
T_b(" ");
T_b("* Stow stack memory information \"under a rock\" for use by the");
T_b("\n");
T_b(" ");
T_b("* task initialization routines later on.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b("xtUML_Application_Initialize(");
T_b("\n");
T_b("  ");
T_b("NU_MEMORY_POOL * system_stack_memory_pool,");
T_b("\n");
T_b("  ");
T_b("const UNSIGNED stack_depth");
T_b("\n");
T_b(")");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b(te_prefix->result);
T_b("task_stack_depth = stack_depth;");
T_b("\n");
T_b("  ");
T_b(te_prefix->result);
T_b("memory_pool = system_stack_memory_pool;");
T_b("\n");
T_b(te_thread->extra_initialization);
T_b("");
T_b("  ");
T_b(te_thread->create);
T_b("( ");
T_b(te_prefix->result);
T_b("main, 0 );");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Cleanup the structures initialized in ");
T_b(te_prefix->result);
T_b("InitializeThreading.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void ");
T_b(te_thread->shutdown);
T_b("( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("u1_t i;");
T_b("\n");
T_b("  ");
T_b("STATUS rc;");
T_b("\n");
T_b("  ");
T_b("for ( i = 0; i < SEMAPHORE_FLAVOR_MAX; i++ ) {");
T_b("\n");
T_b("    ");
T_b("rc = NU_Delete_Semaphore( &mutices[ i ] );");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("rc = rc;");
T_b("\n");
T_b("}");
T_b("\n");
