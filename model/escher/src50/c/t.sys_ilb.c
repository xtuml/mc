T_b("/*---------------------------------------------------------------------");
T_b("\n");
T_b(" ");
T_b("* File:  ");
T_b(te_file->ilb);
T_b(".");
T_b(te_file->src_file_ext);
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* Description:");
T_b("\n");
T_b(" ");
T_b("* This file provides a means to safely receive calls from interrupt");
T_b("\n");
T_b(" ");
T_b("* handlers or other tasks/threads/contexts.");
T_b("\n");
T_b(" ");
T_b("*");
T_b("\n");
T_b(" ");
T_b("* ");
T_b(te_copyright->body);
T_b("\n");
T_b(" ");
T_b("*-------------------------------------------------------------------*/");
T_b("\n");
T_b("#include \"");
T_b(te_file->types);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
T_b("#include \"");
T_b(te_file->ilb);
T_b(".");
T_b(te_file->hdr_file_ext);
T_b("\"");
T_b("\n");
T_b("typedef void ( * interleaved_bridge_t )( void );");
T_b("\n");
T_b("static interleaved_bridge_t interleaved_bridges[ ");
T_b(te_ilb->define_name);
T_b(" ];");
T_b("\n");
T_b("typedef struct { u1_t space[ ");
T_b(te_ilb->data_define_name);
T_b(" ]; } ilb_data_t;");
T_b("\n");
T_b("static ilb_data_t ilb_data[ ");
T_b(te_ilb->define_name);
T_b(" ];");
T_b("\n");
T_b("static u1_t ilb_head = 0;");
T_b("\n");
T_b("static u1_t ilb_tail = 0;");
T_b("\n");
T_b("static bool ilb_empty = true;");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Post a bridge routine for execution after any executing state");
T_b("\n");
T_b(" ");
T_b("* action completes.");
T_b("\n");
T_b(" ");
T_b("* Protect the data structures from being clobbered by another context");
T_b("\n");
T_b(" ");
T_b("* by disabling interrupts around the data access.");
T_b("\n");
T_b(" ");
T_b("* Return a pointer to the argument data used by this bridge operation.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void *");
T_b("\n");
T_b(te_ilb->interleave_bridge);
T_b("( void (vfp)(void) )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b("void * ilb = 0;");
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
T_b("  ");
T_b(disable_interrupts->result);
T_b("\n");
T_b("  ");
T_b("if ( ( ilb_head == ilb_tail ) && ( ilb_empty != true ) ) {");
T_b("\n");
T_b("    ");
T_b("/* Overflowed array of interleaved bridges.  */");
T_b("\n");
T_b("    ");
T_b(te_callout->interleaved_bridge_overflow);
T_b("();");
T_b("\n");
T_b("  ");
T_b("} else {");
T_b("\n");
T_b("    ");
T_b("ilb_empty = false;");
T_b("\n");
T_b("    ");
T_b("ilb = (void *) &ilb_data[ ilb_head ];");
T_b("\n");
T_b("    ");
T_b("interleaved_bridges[ ilb_head ] = vfp;");
T_b("\n");
T_b("    ");
T_b("/* Bump the head of the circular list.  */");
T_b("\n");
T_b("    ");
T_b("ilb_head = ( ilb_head == (");
T_b(te_ilb->define_name);
T_b(" - 1) ) ? 0 : ilb_head + 1;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b("return ilb;");
T_b("\n");
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Unlock the resource that is protecting our interleaved bridge.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_ilb->interleave_bridge_done);
T_b("( void )");
T_b("\n");
T_b("{");
T_b("\n");
T_b("  ");
T_b(enable_interrupts->result);
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
T_b("  ");
T_b(te_thread->nonbusy_wake);
T_b("( 0 ); /* Wake default thread to process.  */");
T_b("\n");
}
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Sequentially execute each of the bridge routines that have been");
T_b("\n");
T_b(" ");
T_b("* posted during the most recent executing state action.");
T_b("\n");
T_b(" ");
T_b("* Protect the data structures from being clobbered by another context");
T_b("\n");
T_b(" ");
T_b("* by disabling interrupts around the data access.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void");
T_b("\n");
T_b(te_ilb->dispatch);
T_b("( void )");
T_b("\n");
T_b("{");
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
T_b("  ");
T_b(disable_interrupts->result);
T_b("\n");
T_b("  ");
T_b("if ( ilb_empty != true ) {");
T_b("\n");
T_b("    ");
T_b("do {");
T_b("\n");
T_b("      ");
T_b(enable_interrupts->result);
T_b("\n");
if ( te_thread->enabled ) {
T_b("      ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
if ( te_thread->serialize ) {
T_b("      ");
T_b("#ifdef ESCHER_SERIALIZE_DISPATCH");
T_b("\n");
T_b("      ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_DISPATCH );");
T_b("\n");
T_b("      ");
T_b("#endif");
T_b("\n");
}
T_b("      ");
T_b("interleaved_bridges[ ilb_tail ]();  /* Run with interrupts enabled.  */");
T_b("\n");
if ( te_thread->serialize ) {
T_b("      ");
T_b("#ifdef ESCHER_SERIALIZE_DISPATCH");
T_b("\n");
T_b("      ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_DISPATCH );");
T_b("\n");
T_b("      ");
T_b("#endif");
T_b("\n");
}
if ( te_thread->enabled ) {
T_b("      ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
T_b("      ");
T_b(disable_interrupts->result);
T_b("\n");
T_b("      ");
T_b("/* Bump the tail of the circular list.  */");
T_b("\n");
T_b("      ");
T_b("ilb_tail = ( ilb_tail == (");
T_b(te_ilb->define_name);
T_b(" - 1) ) ? 0 : ilb_tail + 1;");
T_b("\n");
T_b("    ");
T_b("} while ( ilb_head != ilb_tail );");
T_b("\n");
T_b("    ");
T_b("ilb_empty = true;");
T_b("\n");
T_b("  ");
T_b("}");
T_b("\n");
T_b("  ");
T_b(enable_interrupts->result);
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
T_b("}");
T_b("\n");
T_b("/*");
T_b("\n");
T_b(" ");
T_b("* Get a pointer to the data for the current interleaved bridge.");
T_b("\n");
T_b(" ");
T_b("*/");
T_b("\n");
T_b("void *");
T_b("\n");
T_b(te_ilb->get_data);
T_b("( void )");
T_b("\n");
T_b("{ ");
T_b("\n");
T_b("  ");
T_b("void * ilb;");
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_lock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
T_b("  ");
T_b("ilb = (void *) &ilb_data[ ilb_tail ];");
T_b("\n");
if ( te_thread->enabled ) {
T_b("  ");
T_b(te_thread->mutex_unlock);
T_b("( SEMAPHORE_FLAVOR_ILB );");
T_b("\n");
}
T_b("  ");
T_b("return ilb;");
T_b("\n");
T_b("}");
T_b("\n");
