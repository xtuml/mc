-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES ("d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ooapopulation',
	3801,
	'ooapopulation',
	'',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("89d3a97e-cc53-4a5c-99c9-14ffd283e711",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Association_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_rel = param.r_rel;

relNumber = STRING::atoi(s:self.current_rel.number);
r_rel.Numb = relNumber;',
	1,
	'',
	"00000000-0000-0000-0000-000000000000",
	0);
INSERT INTO O_TPARM
	VALUES ("a78b4931-9928-4872-9830-af4bc18f5bfe",
	"89d3a97e-cc53-4a5c-99c9-14ffd283e711",
	'r_rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4480b008-8c74-4f57-9256-08b7365520bc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("703ce8fc-db22-422b-b958-27b0a3abf6ab",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'AttributeReferenceInClass_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_ref = param.o_ref;

select one next_ref related by o_ref->O_REF[R112.''precedes''];
select one prior_ref related by o_ref->O_REF[R112.''succeeds''];
if ( not_empty next_ref and not_empty prior_ref )
  // in the middle of the chain
  unrelate o_ref from next_ref across R112.''precedes'';
  unrelate prior_ref from o_ref across R112.''precedes'';
  relate prior_ref to next_ref across R112.''precedes'';
elif ( not_empty prior_ref and empty next_ref )
  // last in list
  unrelate prior_ref from o_ref across R112.''precedes'';
elif ( empty prior_ref and not_empty next_ref )
  // first in list
  unrelate o_ref from next_ref across R112.''precedes'';
else
  // only one in the list
end if;
select one owningReferential related by o_ref->O_RATTR[R108];
if not_empty owningReferential
 unrelate o_ref from owningReferential across R108;
end if;
select one rtida related by o_ref->O_RTIDA[R111];
select one rgo related by o_ref->R_RGO[R111];
select one rto related by rtida->R_RTO[R110];
unrelate rtida from rgo across R111 using o_ref;
delete object instance o_ref;',
	1,
	'',
	"89d3a97e-cc53-4a5c-99c9-14ffd283e711",
	0);
INSERT INTO O_TPARM
	VALUES ("f202bad1-df51-4f11-a5bf-4dae8d88d5eb",
	"703ce8fc-db22-422b-b958-27b0a3abf6ab",
	'o_ref',
	"f5752494-b9cf-4fc7-b96d-4b64d6be0431",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f5752494-b9cf-4fc7-b96d-4b64d6be0431",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute Reference in Class>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("7d5543ed-1b79-4d86-b90b-7e107f680d6c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'AttributeReferenceInClass_migrateRefAttrOrDispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_ref = param.o_ref;

select many siblings related by o_ref->O_RATTR[R108]->O_REF[R108];
if (cardinality siblings == 1)
  // This referential is not going to refer to anything after this . . . 
  select one rattr related by o_ref->O_RATTR[R108];
  select any idattr related by rattr->O_ATTR[R106]->O_OIDA[R105];
  if (empty idattr)
    // this referential has no references left and it''s not part of an identifier
    // it should be removed
    select one attr related by rattr->O_ATTR[R106];
    self.Attribute_dispose(o_attr:attr);
  else
    select any rattr_ref related by idattr->O_RTIDA[R110];
    if ( not_empty rattr_ref )
      // rattr''s identifier is used to formalize another relationship
      // we need to keep it as a base attribute
      self.ReferentialAttribute_migrateToBase(o_rattr:rattr);
    else
      select one attr related by rattr->O_ATTR[R106];
      self.Attribute_dispose(o_attr:attr);
    end if;
  end if;
else
  self.AttributeReferenceInClass_dispose(o_ref:o_ref);
end if;
',
	1,
	'',
	"703ce8fc-db22-422b-b958-27b0a3abf6ab",
	0);
INSERT INTO O_TPARM
	VALUES ("545f8d06-0878-400b-9bd2-6eed3cc71f36",
	"7d5543ed-1b79-4d86-b90b-7e107f680d6c",
	'o_ref',
	"f5752494-b9cf-4fc7-b96d-4b64d6be0431",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("48ff23e2-0793-4d48-ad03-3be691fc7944",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Attribute_addToIdentifier',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_attr = param.o_attr;

select any oid related by o_attr->O_OBJ[R102]->O_ID[R104] where ( selected.Oid_ID == param.oid );
create object instance oida of O_OIDA;
relate o_attr to oid across R105 using oida;
select many rto_set related by oid->R_RTO[R109];
for each rto in rto_set
  self.ReferredToClassInAssoc_addAttributeToIdentifier( r_rto:rto, oida:oida );
end for;',
	1,
	'',
	"7d5543ed-1b79-4d86-b90b-7e107f680d6c",
	0);
INSERT INTO O_TPARM
	VALUES ("58ea32de-197e-46ee-ba66-32a664e900ab",
	"48ff23e2-0793-4d48-ad03-3be691fc7944",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("579b8247-e153-481d-8926-384cdc722464",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TPARM
	VALUES ("9fd3fa44-80bb-4c7b-8bd0-e567cd0893fc",
	"48ff23e2-0793-4d48-ad03-3be691fc7944",
	'oid',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"58ea32de-197e-46ee-ba66-32a664e900ab",
	'');
INSERT INTO O_TFR
	VALUES ("c8f76bbd-6619-4de5-9bc6-d4830081e5d9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Attribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_attr = param.o_attr;

// Subsystem Subsystem
select many oidas related by o_attr->O_OIDA[R105];
for each oida in oidas
  self.ClassIdentifierAttribute_dispose(o_oida:oida);
end for;
select one battr related by o_attr->O_BATTR[R106];
if (not_empty battr)
  self.BaseAttribute_dispose(o_battr:battr);
else
  select one rattr related by o_attr->O_RATTR[R106];
  if ( not_empty rattr )
    self.ReferentialAttribute_dispose(o_rattr:rattr);
  end if;
end if;
select one dt related by o_attr->S_DT[R114];
if ( not_empty dt )
  unrelate o_attr from dt across R114;
end if;
select one owningClass related by o_attr->O_OBJ[R102];
select one nextAttr related by o_attr->O_ATTR[R103.''precedes''];
if(not_empty nextAttr)
  select one prevAttr related by o_attr->O_ATTR[R103.''succeeds''];
  if ( empty prevAttr )
    // this attribute is at the top of the list
    unrelate o_attr from nextAttr across R103.''precedes'';
  else
    // otherwise this attribute is somewhere in the middle
    // or at the end
    select many attrs related by owningClass->O_ATTR[R102];
    for each attr in attrs
      select one thisAttr related by attr->O_ATTR[R103.''precedes''];
      if (o_attr == thisAttr)
        // now tell the next attribute that this is not
        // the attribute that it succeeds anymore
        unrelate o_attr from nextAttr across R103.''precedes'';
        // and tell this attribute that it no longer succeeds
        // any attribute. 
        // *NOTE* this is not really required for deletion but
        // more for restoration
        unrelate o_attr from attr across R103.''succeeds'';
        // finally connect the two attributes that this
        // attribute was between
        relate nextAttr to attr across R103.''succeeds'';
        break;
      end if;
    end for;
  end if;
else
  // we are at the end of the list
  select one priorAttr related by o_attr->O_ATTR[R103.''succeeds''];
  if ( not_empty priorAttr )
    unrelate o_attr from priorAttr across R103.''succeeds'';
  end if;
end if;
unrelate o_attr from owningClass across R102;
//
// Value Subsystem
select many selref_set related by o_attr->V_SLR[R812];
for each selref in selref_set
  unrelate o_attr from selref across R812;
end for;
select many attrvals related by o_attr->V_AVL[R806];
for each attrval in attrvals
  unrelate o_attr from attrval across R806;
end for;
//
// Finally delete o_attr
delete object instance o_attr;',
	1,
	'',
	"48ff23e2-0793-4d48-ad03-3be691fc7944",
	0);
INSERT INTO O_TPARM
	VALUES ("6521bb3a-0370-47c8-a86a-ceddd0a81b52",
	"c8f76bbd-6619-4de5-9bc6-d4830081e5d9",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("5c2fdc5a-5635-47f3-a8a0-55c3e3f15fe6",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Attribute_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_attr = param.o_attr;

// Heavily modified version of Attribute::initialize() for MASL import.  Here we do not assign a default type as in OOAofOOA.
o_attr.Prefix = "";
o_attr.Pfx_Mode = 0;
o_attr.Root_Nam = param.name;

// TODO - assign a default type to aid in testing.  When attribute types are handled on the populate interface this can be removed to the // END comment
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
relate o_attr to def_dt across R114;
// END

create object instance ba of O_BATTR;
relate o_attr to ba across R106;
create object instance nba of O_NBATTR;
relate ba to nba across R107;',
	1,
	'',
	"c8f76bbd-6619-4de5-9bc6-d4830081e5d9",
	0);
INSERT INTO O_TPARM
	VALUES ("87a9031a-3e53-4e75-bfd6-b8dee6acfe17",
	"5c2fdc5a-5635-47f3-a8a0-55c3e3f15fe6",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("3c910d30-c1d9-4c18-ab53-001823274934",
	"5c2fdc5a-5635-47f3-a8a0-55c3e3f15fe6",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"87a9031a-3e53-4e75-bfd6-b8dee6acfe17",
	'');
INSERT INTO O_TFR
	VALUES ("d7501c58-c59e-486e-a9a4-6c2faae2e642",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Attribute_migrateBaseToReferential',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_attr = param.o_attr;

select one battr related by o_attr->O_BATTR[R106];
if ( not_empty battr )
  self.BaseAttribute_dispose(o_battr:battr);
end if;
create object instance rattr of O_RATTR;
rattr.Ref_Mode = 0;  // LPS set to 0 to use local attribute name
relate o_attr to rattr across R106;

// Give referential attributes a default type of string.
// This should be changed later
select one old_s_dt related by o_attr->S_DT[R114];
if ( not_empty old_s_dt )
  unrelate old_s_dt from o_attr across R114;
end if;
globaltypes_pkg = self.globaltypes_pkg;
select any s_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
relate s_dt to o_attr across R114;',
	1,
	'',
	"5c2fdc5a-5635-47f3-a8a0-55c3e3f15fe6",
	0);
INSERT INTO O_TPARM
	VALUES ("384d8056-2871-4cd1-83f5-fe89cfb6ad65",
	"d7501c58-c59e-486e-a9a4-6c2faae2e642",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("b34fe561-f118-4739-82d6-79e3f0888d59",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Attribute_setType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_attr = param.o_attr;
type_name = param.type_name;

// NOTE: This isn''t really a copied operation from the OOAofOOA, but we''re following the same paradigm for it
//   as other functions that are from the OOA

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for attribute " + o_attr.Name);
end if;

// Get a handle to the DT that is currently associated with the attribute
select one cur_s_dt related by o_attr->S_DT[R114];

// If the new DT does not equal the existing DT and is not MASLunique, relink
if ( s_dt != cur_s_dt and cur_s_dt.Name != "MASLunique" )
  // un-relate the existing DT across R114
  unrelate o_attr from cur_s_dt across R114;
  
  // relate the new attribute across R114
  relate o_attr to s_dt across R114;
end if;',
	1,
	'',
	"d7501c58-c59e-486e-a9a4-6c2faae2e642",
	0);
INSERT INTO O_TPARM
	VALUES ("3f93ad17-7e2b-4d84-9c69-f0772722119b",
	"b34fe561-f118-4739-82d6-79e3f0888d59",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("59ae6d5b-f459-4f0c-a6fc-57283872980d",
	"b34fe561-f118-4739-82d6-79e3f0888d59",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3f93ad17-7e2b-4d84-9c69-f0772722119b",
	'');
INSERT INTO O_TFR
	VALUES ("74201b50-e2ba-4f73-8e39-0b1bd4c47d27",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'BaseAttribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_battr = param.o_battr;

select one dbattr related by o_battr->O_DBATTR[R107];
if (not_empty dbattr)
  self.DerivedBaseAttribute_dispose(o_dbattr:dbattr);
else
  select one nbattr related by o_battr->O_NBATTR[R107];
  if (not_empty nbattr)
    self.NewBaseAttribute_dispose(o_nbattr:nbattr);
  end if;
end if;
select many rattrs related by o_battr->O_RATTR[R113];
for each rattr in rattrs
  unrelate o_battr from rattr across R113;
end for;
select one attr related by o_battr->O_ATTR[R106];
if (not_empty attr)
  unrelate o_battr from attr across R106;
end if;
delete object instance o_battr;
',
	1,
	'',
	"b34fe561-f118-4739-82d6-79e3f0888d59",
	0);
INSERT INTO O_TPARM
	VALUES ("57c71092-5699-49e4-92a4-9c8fe710c4ae",
	"74201b50-e2ba-4f73-8e39-0b1bd4c47d27",
	'o_battr',
	"ffe937d5-4336-4bcd-906f-9fd5b8ec2a51",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ffe937d5-4336-4bcd-906f-9fd5b8ec2a51",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Base Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("a2b83cc7-4ada-4455-8d6f-4c1443a09329",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsAssociatedOneSide_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_aone = param.r_aone;

select one rassoc related by r_aone->R_ASSOC[R209];
unrelate r_aone from rassoc across R209;
select one rto related by r_aone->R_RTO[R204];
unrelate r_aone from rto across R204;
delete object instance r_aone;
',
	1,
	'',
	"74201b50-e2ba-4f73-8e39-0b1bd4c47d27",
	0);
INSERT INTO O_TPARM
	VALUES ("4f317d24-d3a1-4ba1-b94f-32b4012c2282",
	"a2b83cc7-4ada-4455-8d6f-4c1443a09329",
	'r_aone',
	"37e868cd-e616-45a0-aa57-7a32350b86f4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("37e868cd-e616-45a0-aa57-7a32350b86f4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class As Associated One Side>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("077dee3e-d6f0-4f5c-954a-fea3285f6b28",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsAssociatedOtherSide_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_aoth = param.r_aoth;

select one rassoc related by r_aoth->R_ASSOC[R210];
unrelate r_aoth from rassoc across R210;
select one rto related by r_aoth->R_RTO[R204];
unrelate r_aoth from rto across R204;
delete object instance r_aoth;
',
	1,
	'',
	"a2b83cc7-4ada-4455-8d6f-4c1443a09329",
	0);
INSERT INTO O_TPARM
	VALUES ("1b3fecde-bbb5-440a-ab19-c914a31aef2e",
	"077dee3e-d6f0-4f5c-954a-fea3285f6b28",
	'r_aoth',
	"ddf50731-13d8-4e02-932f-347f2ddc3444",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ddf50731-13d8-4e02-932f-347f2ddc3444",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class As Associated Other Side>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("858a3b7b-c038-4cd4-b22c-5a11685f5855",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsLink_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_assr = param.r_assr;

select one rassoc related by r_assr->R_ASSOC[R211];
if (not_empty rassoc)
  // TODO - add this in later, not needed right now.... - rassoc.migrateToSimple();
  unrelate r_assr from rassoc across R211;
end if;
select one rgo related by r_assr->R_RGO[R205];
unrelate r_assr from rgo across R205;
delete object instance r_assr;
',
	1,
	'',
	"077dee3e-d6f0-4f5c-954a-fea3285f6b28",
	0);
INSERT INTO O_TPARM
	VALUES ("0ee09c36-a63c-4f57-be69-334a97df7018",
	"858a3b7b-c038-4cd4-b22c-5a11685f5855",
	'r_assr',
	"054a18f5-5e57-449b-b46f-5da2e9690ba5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("054a18f5-5e57-449b-b46f-5da2e9690ba5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class As Link>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("f01bd981-a982-4e8c-ae42-ff80ad36c721",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsSimpleFormalizer_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	1,
	'',
	"858a3b7b-c038-4cd4-b22c-5a11685f5855",
	0);
INSERT INTO O_TPARM
	VALUES ("53a26d62-954b-43a1-8667-c6cf1be829d4",
	"f01bd981-a982-4e8c-ae42-ff80ad36c721",
	'r_form',
	"9a6e9e32-b2f0-4344-b3a3-123b16423c3d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9a6e9e32-b2f0-4344-b3a3-123b16423c3d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class As Simple Formalizer>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("729f3a31-a91d-448b-90e5-ef6972ee278e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsSimpleFormalizer_migrateToParticipant',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_form = param.r_form;

create object instance rto of R_RTO;
create object instance part of R_PART;

part.Mult = r_form.Mult;
part.Cond = r_form.Cond;
part.Txt_Phrs = r_form.Txt_Phrs;

select one rgo related by r_form->R_RGO[R205];
select one oir related by rgo->R_OIR[R203];
select one simp related by r_form->R_SIMP[R208];

relate oir to rto across R203;
relate rto to part across R204;
relate part to simp across R207;

// and dispose r_form from supertype
self.ReferringClassInAssoc_dispose(r_rgo:rgo);
',
	1,
	'',
	"f01bd981-a982-4e8c-ae42-ff80ad36c721",
	0);
INSERT INTO O_TPARM
	VALUES ("d40a9814-2d0e-4ee4-9b05-46633140f387",
	"729f3a31-a91d-448b-90e5-ef6972ee278e",
	'r_form',
	"9a6e9e32-b2f0-4344-b3a3-123b16423c3d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("ae41361e-7009-4049-9c6d-626171db69d1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsSimpleParticipant_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_part = param.r_part;

select one rsimp related by r_part->R_SIMP[R207];
unrelate r_part from rsimp across R207;
select one rto related by r_part->R_RTO[R204];
unrelate r_part from rto across R204;
delete object instance r_part;
',
	1,
	'',
	"729f3a31-a91d-448b-90e5-ef6972ee278e",
	0);
INSERT INTO O_TPARM
	VALUES ("13bef1cd-617f-41e4-b448-751134500f77",
	"ae41361e-7009-4049-9c6d-626171db69d1",
	'r_part',
	"11f40760-1dd1-4b08-9393-18b2e8520e6c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("11f40760-1dd1-4b08-9393-18b2e8520e6c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class As Simple Participant>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("7217a0ee-14d5-492b-9689-82eecec290b1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsSimpleParticipant_migrateToFormalizer',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_part = param.r_part;

create object instance rgo of R_RGO;
create object instance form of R_FORM;

form.Mult = r_part.Mult;
form.Cond = r_part.Cond;
form.Txt_Phrs = r_part.Txt_Phrs;

select one rto related by r_part->R_RTO[R204];
select one oir related by rto->R_OIR[R203];
select one simp related by r_part->R_SIMP[R207];

relate oir to rgo across R203;
relate rgo to form across R205;
relate form to simp across R208;

// and dispose r_part from supertype
self.ReferredToClassInAssoc_dispose(r_rto:rto);
',
	1,
	'',
	"ae41361e-7009-4049-9c6d-626171db69d1",
	0);
INSERT INTO O_TPARM
	VALUES ("042866a8-5ffc-4796-9e5a-d16ff1b757f1",
	"7217a0ee-14d5-492b-9689-82eecec290b1",
	'r_part',
	"11f40760-1dd1-4b08-9393-18b2e8520e6c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("9a146f41-db06-4440-816d-852c7c6c9769",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassAsSupertype_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_super = param.r_super;

select one rsubsup related by r_super->R_SUBSUP[R212];
unrelate r_super from rsubsup across R212;
select one rto related by r_super->R_RTO[R204];
unrelate r_super from rto across R204;
delete object instance r_super;
',
	1,
	'',
	"7217a0ee-14d5-492b-9689-82eecec290b1",
	0);
INSERT INTO O_TPARM
	VALUES ("079050a2-6d75-4bba-8f93-7999d418f7d9",
	"9a146f41-db06-4440-816d-852c7c6c9769",
	'r_super',
	"558a05a8-1353-47b4-8d4d-04018ea4b537",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("558a05a8-1353-47b4-8d4d-04018ea4b537",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class As Supertype>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("bdd63045-419f-4d0c-b660-d332a2203d21",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassIdentifierAttribute_addReference',
	'',
	"9bb4b389-b488-46e0-aeca-fc90df7b856a",
	1,
	'oida = param.o_oida;
rel = param.rel;
rto = param.part_rto;
rto_obj = param.part_obj;
rgo = param.form_rgo;
rgo_obj = param.form_obj;
id = param.id;

// This is a heavily modified version of the function from OOA
// TODO - fix up, clean up
//select any rel from instances of R_REL where selected.Rel_ID == param.rel_id;
//select any rgo related by rel->R_OIR[R201]->R_RGO[R203] 
//    where selected.Obj_ID == param.rgo_obj_id and selected.OIR_ID == param.rgo_oir_id;
//select one rgo_obj related by rgo->R_OIR[R203]->O_OBJ[R201];

/*
newAttr_id = rgo_obj.newReferentialAttribute(ref_obj_id: oida.Obj_ID, 
    ref_oid_id: oida.Oid_ID, ref_attr_id: oida.Attr_ID, id: param.id );

select any ref_attr related by rgo_obj->O_ATTR[R102]->O_RATTR[R106]
    where selected.Attr_ID == newAttr_id;*/
ref_attr = self.ModelClass_newReferentialAttribute(o_obj:rgo_obj, o_oida:oida, id:param.id); 

//select any rto related by rel->R_OIR[R201]->R_RTO[R203] 
//    where selected.Obj_ID == param.rto_obj_id and selected.OIR_ID == param.rto_oir_id;

// An rtida instance may already exist if we''re adding 
// the second (or subsequent) subtype to an inheritance 
// association
select any rtida related by oida->O_RTIDA[R110] 
    where selected.Rel_ID == rel.Rel_ID and selected.OIR_ID == rto.OIR_ID;
if ( empty rtida )
  create object instance rtida of O_RTIDA;
  relate oida to rto across R110 using rtida;
end if;

create object instance ref of O_REF;
relate ref to ref_attr across R108;
relate rtida to rgo across R111 using ref;

return ref_attr;
',
	1,
	'',
	"9a146f41-db06-4440-816d-852c7c6c9769",
	0);
INSERT INTO O_TPARM
	VALUES ("5e50bb99-50c2-4c20-ba45-e72986708532",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"2661c4bb-bda5-412e-b5c7-967832eefdc6",
	'');
INSERT INTO O_TPARM
	VALUES ("61469d87-0a9b-40c5-8e40-ad51085346b1",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'part_rto',
	"893ea6d3-466d-498e-b58a-cf5966da5549",
	0,
	'',
	"5e50bb99-50c2-4c20-ba45-e72986708532",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("893ea6d3-466d-498e-b58a-cf5966da5549",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Referred To Class in Assoc>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TPARM
	VALUES ("929bdc4a-0f87-47ec-a44d-b81b4bc0d8cc",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'part_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"61469d87-0a9b-40c5-8e40-ad51085346b1",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TPARM
	VALUES ("7b939d09-32c1-461b-b0bc-bfb3edbfeddc",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'form_rgo',
	"f6b00fbb-5d4e-4e79-bd36-f3289da7ee17",
	0,
	'',
	"929bdc4a-0f87-47ec-a44d-b81b4bc0d8cc",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6b00fbb-5d4e-4e79-bd36-f3289da7ee17",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Referring Class In Assoc>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TPARM
	VALUES ("27e5d51d-9da4-4325-a14f-251ef37c1233",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'form_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"7b939d09-32c1-461b-b0bc-bfb3edbfeddc",
	'');
INSERT INTO O_TPARM
	VALUES ("2661c4bb-bda5-412e-b5c7-967832eefdc6",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'o_oida',
	"08de18fb-cb5f-4d53-9826-375c4dad56f7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("08de18fb-cb5f-4d53-9826-375c4dad56f7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class Identifier Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TPARM
	VALUES ("149014e7-1a35-4847-a51e-345befa495c5",
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	'id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"27e5d51d-9da4-4325-a14f-251ef37c1233",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9bb4b389-b488-46e0-aeca-fc90df7b856a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Referential Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("58e7c8ba-1dfc-4017-b5c5-883bc432d82b",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ClassIdentifierAttribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_oida = param.o_oida;

select one attr related by o_oida->O_ATTR[R105];
select one id related by o_oida->O_ID[R105];
unrelate attr from id across R105 using o_oida;
select many rtidas related by o_oida->O_RTIDA[R110];
for each rtida in rtidas
  self.ReferredToIdentifierAttribute_dispose(o_rtida:rtida);
end for;
delete object instance o_oida;',
	1,
	'',
	"bdd63045-419f-4d0c-b660-d332a2203d21",
	0);
INSERT INTO O_TPARM
	VALUES ("c405d7b0-df3b-49d5-b922-39c94df94e58",
	"58e7c8ba-1dfc-4017-b5c5-883bc432d82b",
	'o_oida',
	"08de18fb-cb5f-4d53-9826-375c4dad56f7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("be99cd68-08b6-44d2-bc31-863da9358931",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ComponentReference_assignToComp',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// This function is heavily modified from the OOAofOOA version.  Notably, a huge block of code to handle the case
// where the component reference is already assigned to a component is removed as we are only using this for 
// fresh component reference creation.

cl_ic = param.cl_ic;  // TODO - This needs Component Reference to have it''s inst_ref published and the parameter type fixed
comp = param.c_c;

select one packageableElem related by cl_ic->PE_PE[R8001]; 
select one contPackage related by packageableElem->EP_PKG[R8000];
select one contComponent related by packageableElem->C_C[R8003];
if(not_empty comp)
  relate cl_ic to comp across R4201;
  select many formalInterfaces related by comp->C_PO[R4010]->C_IR[R4016];
  for each formalInterface in formalInterfaces
    // If the association between self and C_I is set up
    // then this reference is formal
    // TODO - SKB: here I skipped a function call because it would require published ref on C_IR, maybe should use
    //   that for consistency...
    select one c_i related by formalInterface->C_I[R4012];
    if(not_empty c_i)
      select any existingImportRef related by cl_ic->CL_POR[R4707]->CL_IIR[R4708]->C_IR[R4701]
                                      where (selected.Id == formalInterface.Id);
      if(empty existingImportRef)
        select one provision related by formalInterface->C_P[R4009];
        create object instance newImportedRef of CL_IIR;
        if(not_empty provision)
          create object instance importedPro of CL_IP;
          relate importedPro to newImportedRef across R4703;
        else
          create object instance importedReq of CL_IR;
          relate importedReq to newImportedRef across R4703;
        end if;
        create object instance portRef of CL_POR;
        select one existingPort related by formalInterface->C_PO[R4016];
        relate existingPort to portRef across R4709;
        relate portRef to cl_ic across R4707;
        relate portRef to newImportedRef across R4708;
        relate newImportedRef to formalInterface across R4701;
      end if;
    end if;
  end for; 
end if;
',
	1,
	'',
	"58e7c8ba-1dfc-4017-b5c5-883bc432d82b",
	0);
INSERT INTO O_TPARM
	VALUES ("05775bc3-8482-4115-926f-7aacb600b678",
	"be99cd68-08b6-44d2-bc31-863da9358931",
	'cl_ic',
	"4bf19d7e-1bcd-469a-b056-4523dd59dc1d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4bf19d7e-1bcd-469a-b056-4523dd59dc1d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Reference>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component Library/Component Library.xtuml');
INSERT INTO O_TPARM
	VALUES ("eb11c2cc-eea9-439b-9afa-44070cecbcc8",
	"be99cd68-08b6-44d2-bc31-863da9358931",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"05775bc3-8482-4115-926f-7aacb600b678",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TFR
	VALUES ("be72655f-94e4-432f-9935-c7d22a75f63a",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Component_getRootComponentId',
	'',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'c_c = param.c_c;

// Component.getRootComponentId
// NOTE: Only intended for use in a generic package context
// Ascends the Component hierarchy to find the top component.
// The "top component" is the first component in this package. Note that
// this package may be nested.  The package could also by under a 
// component.  However, this routine finds the first component in 
// this package.  It does NOT search beyond the package boundary.
select one parentComponent related by c_c->PE_PE[R8001]->C_C[R8003];
if not_empty parentComponent
  return self.Component_getRootComponentId(c_c:parentComponent);
end if;
return c_c.Id;',
	1,
	'',
	"be99cd68-08b6-44d2-bc31-863da9358931",
	0);
INSERT INTO O_TPARM
	VALUES ("cccce37c-4e36-4136-b07c-a68638779879",
	"be72655f-94e4-432f-9935-c7d22a75f63a",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("535ff240-f4a8-43de-96ee-38207b97fdeb",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Component_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'param.c_c.Name = param.name;',
	1,
	'',
	"be72655f-94e4-432f-9935-c7d22a75f63a",
	0);
INSERT INTO O_TPARM
	VALUES ("f841e173-eda2-49cd-800f-4b49bb727f3c",
	"535ff240-f4a8-43de-96ee-38207b97fdeb",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("d45a16ea-e542-4e62-a017-cc9187b67cb0",
	"535ff240-f4a8-43de-96ee-38207b97fdeb",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f841e173-eda2-49cd-800f-4b49bb727f3c",
	'');
INSERT INTO O_TFR
	VALUES ("ad961ff7-d30f-46cf-9141-750c602faee4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Component_initializeProvision',
	'',
	"3068be83-fc38-4a02-a09f-a2dc428b84f6",
	1,
	'c_c = param.c_c;

// The OOA version of this function does _a lot_ more work than we have to do here.
create object instance provision of C_P;
create object instance interfaceRef of C_IR;
create object instance port of C_PO;
relate provision to interfaceRef across R4009;
relate interfaceRef to port across R4016;
relate port to c_c across R4010;
if ( "" == param.if_name )
  provision.InformalName = "Unnamed_Interface";
else
  provision.InformalName = param.if_name;
end if;

self.Port_initialize(c_po:port, name:param.port_name);

return interfaceRef;',
	1,
	'',
	"535ff240-f4a8-43de-96ee-38207b97fdeb",
	0);
INSERT INTO O_TPARM
	VALUES ("13a016d4-48c1-4dbb-b2b7-7ad8ec3d392d",
	"ad961ff7-d30f-46cf-9141-750c602faee4",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("87128fbf-484f-4ee9-9e07-8928be7bc749",
	"ad961ff7-d30f-46cf-9141-750c602faee4",
	'port_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"13a016d4-48c1-4dbb-b2b7-7ad8ec3d392d",
	'');
INSERT INTO O_TPARM
	VALUES ("03e6c978-77cf-4ea0-8688-9db70a9a1f06",
	"ad961ff7-d30f-46cf-9141-750c602faee4",
	'if_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"87128fbf-484f-4ee9-9e07-8928be7bc749",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3068be83-fc38-4a02-a09f-a2dc428b84f6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface Reference>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TFR
	VALUES ("e109e395-26df-4df1-9532-249ae505daa0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Component_initializeRequirement',
	'',
	"3068be83-fc38-4a02-a09f-a2dc428b84f6",
	1,
	'c_c = param.c_c;

// The OOA version of this function does _a lot_ more work than we have to do here.
create object instance requirement of C_R;
create object instance interfaceRef of C_IR;
create object instance port of C_PO;
relate requirement to interfaceRef across R4009;
relate interfaceRef to port across R4016;
relate port to c_c across R4010;
if ( "" == param.if_name )
  requirement.InformalName = "Unnamed_Interface";
else
  requirement.InformalName = param.if_name;
end if;
self.Port_initialize(c_po:port, name:param.port_name);

if ( self.processingProject )
  // Add "masl_formalize" to the description so the MASL
  // import processor knows to formalize this interface
  requirement.Descrip = requirement.Descrip + "masl_formalize";
end if;

return interfaceRef;',
	1,
	'',
	"ad961ff7-d30f-46cf-9141-750c602faee4",
	0);
INSERT INTO O_TPARM
	VALUES ("8e962427-adbd-40a6-92bf-023e20a392d3",
	"e109e395-26df-4df1-9532-249ae505daa0",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("ef3bd654-ce08-4da6-a83f-2d9a4a902a32",
	"e109e395-26df-4df1-9532-249ae505daa0",
	'port_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"8e962427-adbd-40a6-92bf-023e20a392d3",
	'');
INSERT INTO O_TPARM
	VALUES ("46c077b2-9834-4b74-82a9-f8a91f7e9ea2",
	"e109e395-26df-4df1-9532-249ae505daa0",
	'if_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ef3bd654-ce08-4da6-a83f-2d9a4a902a32",
	'');
INSERT INTO O_TFR
	VALUES ("7f25bf4b-1246-42f4-8a5c-8cb79700a261",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Component_newPackage',
	'',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	1,
	'c_c = param.c_c;

create object instance package of EP_PKG;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate package to pe across R8001;
rootCompIdInPkg = self.Component_getRootComponentId(c_c:c_c);
select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
relate package to system across R1405;
relate c_c to pe across R8003;
self.Package_initialize(ep_pkg:package, name:param.pkg_name);
pe.type = ElementTypeConstants::PACKAGE;
self.PackageableElement_initialize(pe_pe:pe);

return package;',
	1,
	'',
	"e109e395-26df-4df1-9532-249ae505daa0",
	0);
INSERT INTO O_TPARM
	VALUES ("85452da4-6552-4b3f-b4c6-c79f282f41f9",
	"7f25bf4b-1246-42f4-8a5c-8cb79700a261",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("6d942d71-7c36-4988-8659-557d9a74977c",
	"7f25bf4b-1246-42f4-8a5c-8cb79700a261",
	'pkg_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"85452da4-6552-4b3f-b4c6-c79f282f41f9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO O_TFR
	VALUES ("074ccedb-b70c-456f-8137-24ee7c4eb4f6",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Datatype_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'param.s_dt.Name = param.name;',
	1,
	'',
	"7f25bf4b-1246-42f4-8a5c-8cb79700a261",
	0);
INSERT INTO O_TPARM
	VALUES ("5d42164c-5ddc-4043-8707-aa50de37bea4",
	"074ccedb-b70c-456f-8137-24ee7c4eb4f6",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO O_TPARM
	VALUES ("d662b3fe-90d3-4bcb-9d0b-b25837824ea4",
	"074ccedb-b70c-456f-8137-24ee7c4eb4f6",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5d42164c-5ddc-4043-8707-aa50de37bea4",
	'');
INSERT INTO O_TFR
	VALUES ("c63811ab-6088-4430-8f40-23d88038178a",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'DerivedBaseAttribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_dbattr = param.o_dbattr;

select one battr related by o_dbattr->O_BATTR[R107];
unrelate o_dbattr from battr across R107;
//Body Subsystem
select one body related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698];
if (not_empty body)
  // TODO - not sure if this really needs to be called... If it does then it sets off a 
  //   chain of a lot more dispose operations for bodies that will also need to be implemented
  //   and called.  For now I''m skipping it.
  //body.dispose();
end if;
//
// Finally delete o_dbattr
delete object instance o_dbattr;
',
	1,
	'',
	"074ccedb-b70c-456f-8137-24ee7c4eb4f6",
	0);
INSERT INTO O_TPARM
	VALUES ("580eb8a1-4381-449e-99e8-c3ad7b3311f6",
	"c63811ab-6088-4430-8f40-23d88038178a",
	'o_dbattr',
	"4f9e319a-3e53-416e-834c-97575e36b5fd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4f9e319a-3e53-416e-834c-97575e36b5fd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Derived Base Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("72d934c1-e42c-4a87-956b-e38b463eb6f1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ExecutableProperty_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// copied from the OOAofOOA - LPS
c_ep = param.c_ep;

select one asynchronousSignal related by c_ep->C_AS[R4004];
select one synchronousSignal related by c_ep->C_IO[R4004];
if(not_empty asynchronousSignal)
  unrelate c_ep from asynchronousSignal across R4004;
  self.InterfaceSignal_dispose( c_as:asynchronousSignal );
elif(not_empty synchronousSignal)
  unrelate c_ep from synchronousSignal across R4004;
  self.InterfaceOperation_dispose( c_io:synchronousSignal );
end if;
select many parms related by c_ep->C_PP[R4006];
for each parm in parms
  unrelate c_ep from parm across R4006;
  self.PropertyParameter_dispose( c_pp:parm );
end for;
select one interface related by c_ep->C_I[R4003];
if(not_empty interface)
  unrelate c_ep from interface across R4003;
end if;
delete object instance c_ep;',
	1,
	'',
	"c63811ab-6088-4430-8f40-23d88038178a",
	0);
INSERT INTO O_TPARM
	VALUES ("11135b4e-b7da-4deb-8790-991fbd35e095",
	"72d934c1-e42c-4a87-956b-e38b463eb6f1",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TFR
	VALUES ("19091501-adf4-4d19-9744-6772140af7d8",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ExecutableProperty_getSignature',
	'',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'/**
 *  Return a string representation of this functions signature
 *  Heavily adapted from OOAofOOA - LPS
 */
c_ep = param.c_ep;
 
signature = "";

// Get return type
select one returntype related by c_ep->C_IO[R4004]->S_DT[R4008];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + c_ep.Name;

// Get parameters
// Get the first parameter.
select any parameter related by c_ep->C_PP[R4006];
first_param = parameter;
while ( not_empty parameter )
  first_param = parameter;
  select one parameter related by parameter->C_PP[R4021.''succeeds''];
end while;

if( not_empty first_param )
  signature = signature + "(";
end if;
separator = "";
parameter = first_param;
while ( not_empty parameter )
  select one type related by parameter->S_DT[R4007];
  signature = signature + separator + type.Name;
  separator = " ";
  select one parameter related by parameter->C_PP[R4021.''precedes''];
end while;
if( not_empty first_param )
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	"72d934c1-e42c-4a87-956b-e38b463eb6f1",
	0);
INSERT INTO O_TPARM
	VALUES ("3d9b63fe-c87f-422f-9ba8-c3228c908696",
	"19091501-adf4-4d19-9744-6772140af7d8",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("927f57c1-b1ea-4cbb-a78b-749c28bf954d",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'FunctionParameter_dispose',
	'The dispose operation for this class.',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Copied from OOAofOOA - LPS
// Function Parameter.dispose()
//
s_sparm = param.s_sparm;

// Domain Subsystem
select one func related by s_sparm->S_SYNC[R24];
unrelate s_sparm from func across R24;
select one dt related by s_sparm->S_DT[R26];
unrelate s_sparm from dt across R26;
//
select one successor related by s_sparm->S_SPARM[R54.''precedes''];
select one predecessor related by s_sparm->S_SPARM[R54.''succeeds''];
if (not empty successor)
  unrelate s_sparm from successor across R54.''precedes'';
end if;
if (not empty predecessor)
  unrelate s_sparm from predecessor across R54.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R54.''succeeds'';
end if;
/*
//
// Value Subsystem
select many pvs related by s_sparm->V_PVL[R832];
for each pv in pvs
  unrelate s_sparm from pv across R832;
end for;
//
// Local Subsystem
select many lcls related by s_sparm->L_LCL[R3007];
for each lcl in lcls
  unrelate s_sparm from lcl across R3007;
  lcl.dispose();
end for;
// dispose each message argument
// associated with this parm
select many args related by s_sparm->MSG_FA[R1016];
for each arg in args
  arg.dispose();
end for;
*/
select many dims related by s_sparm->S_DIM[R52];
for each dim in dims
  unrelate s_sparm from dim across R52;
  delete object instance dim;
end for;
//
// Finally, delete s_sparm
delete object instance s_sparm;',
	1,
	'',
	"19091501-adf4-4d19-9744-6772140af7d8",
	0);
INSERT INTO O_TPARM
	VALUES ("cbf5e15a-2011-410f-b4e6-e2d336355035",
	"927f57c1-b1ea-4cbb-a78b-749c28bf954d",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a01a1995-8ff8-44fe-abb1-b11213d98016",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO O_TFR
	VALUES ("e54ee347-5edb-465e-a2bc-376f2b9b06c6",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'FunctionParameter_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sparm = param.s_sparm;

select one function related by s_sparm->S_SYNC[R24];
self.Function_addParameterToOrder(s_sync:function, s_sparm:s_sparm);

// TODO - assign a default type to aid in testing.  Do we want to keep this (to // END)?
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
// END

relate s_sparm to def_dt across R26;
s_sparm.Name = param.name;
    ',
	1,
	'',
	"927f57c1-b1ea-4cbb-a78b-749c28bf954d",
	0);
INSERT INTO O_TPARM
	VALUES ("758b3173-713c-4bb3-9364-b6fc805c9c96",
	"e54ee347-5edb-465e-a2bc-376f2b9b06c6",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("524f3d66-6fb8-4a98-953a-8be12d40ab7f",
	"e54ee347-5edb-465e-a2bc-376f2b9b06c6",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"758b3173-713c-4bb3-9364-b6fc805c9c96",
	'');
INSERT INTO O_TFR
	VALUES ("d5fc109a-12be-4303-adb3-0a8b06627eb1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'FunctionParameter_setType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sparm = param.s_sparm;
type_name = param.type_name;

// NOTE: This isn''t really a copied operation from the OOAofOOA, but we''re following the same paradigm for it
//   as other functions that are from the OOA

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for attribute " + s_sparm.Name);
end if;

// Get a handle to the DT that is currently associated with the attribute
select one cur_s_dt related by s_sparm->S_DT[R26];

// If the new DT does not equal the existing DT, continue
if ( s_dt != cur_s_dt )
  // un-relate the existing DT across R26
  unrelate s_sparm from cur_s_dt across R26;
  
  // relate the new attribute across R26
  relate s_sparm to s_dt across R26;
end if;',
	1,
	'',
	"e54ee347-5edb-465e-a2bc-376f2b9b06c6",
	0);
INSERT INTO O_TPARM
	VALUES ("3f3adea0-4ded-4503-8e13-2444fc289b62",
	"d5fc109a-12be-4303-adb3-0a8b06627eb1",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("1d15ba83-b387-461a-a581-f2ee3684e2dd",
	"d5fc109a-12be-4303-adb3-0a8b06627eb1",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3f3adea0-4ded-4503-8e13-2444fc289b62",
	'');
INSERT INTO O_TFR
	VALUES ("cea07e7d-069a-48be-8d68-3cd9674fc4fc",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_addParameterToOrder',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sync = param.s_sync;
parameter = param.s_sparm;

if(not_empty parameter)
  select many peers related by s_sync->S_SPARM[R24];
  for each peer in peers
    if (peer != parameter)
      select one predecessor related by peer->S_SPARM[R54.''precedes''];
      if (empty predecessor)
        relate parameter to peer across R54.''succeeds'';
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	"d5fc109a-12be-4303-adb3-0a8b06627eb1",
	0);
INSERT INTO O_TPARM
	VALUES ("28787d9b-22b0-4b68-8d7b-03217cf57b40",
	"cea07e7d-069a-48be-8d68-3cd9674fc4fc",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO O_TPARM
	VALUES ("40586fb7-c800-4233-bef2-bf9bf7860a69",
	"cea07e7d-069a-48be-8d68-3cd9674fc4fc",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"28787d9b-22b0-4b68-8d7b-03217cf57b40",
	'');
INSERT INTO O_TFR
	VALUES ("a0f42bb1-d72e-4312-92e5-7f159a040629",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_createMessageArgumentsForParameter',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sync = param.s_sync;
parameter = param.s_sparm;

if(not_empty parameter)
  // for each message associated with this function
  // create a message argument
  select many messages related by s_sync->MSG_F[R1010]->MSG_SM[R1020]->MSG_M[R1018];
  for each message in messages
    create object instance arg of MSG_A;
    create object instance fa of MSG_FA;
    relate fa to parameter across R1016;
    relate fa to arg across R1013;
    relate message to arg across R1001;  
  end for;
end if;',
	1,
	'',
	"cea07e7d-069a-48be-8d68-3cd9674fc4fc",
	0);
INSERT INTO O_TPARM
	VALUES ("467c781f-dc33-4c06-8725-51c607bd8d86",
	"a0f42bb1-d72e-4312-92e5-7f159a040629",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("daa0ef94-409d-4a7a-8fda-6514d512d3a5",
	"a0f42bb1-d72e-4312-92e5-7f159a040629",
	's_sparm',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	0,
	'',
	"467c781f-dc33-4c06-8725-51c607bd8d86",
	'');
INSERT INTO O_TFR
	VALUES ("54b7e196-537e-494c-9dc3-41d254b1bef3",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_dispose',
	'The dispose operation for this class.  It also disposes of the associated Function in Package.',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Copied from OOAofOOA - LPS
s_sync = param.s_sync;

// Domain Subsystem
select one pe related by s_sync->PE_PE[R8001];
if(not_empty pe)
  // PE_PE.dispose() will call back into this function at which time the
  // rest of the activity will execute.
  self.PackageableElement_dispose(pe_pe:pe);
  return;
end if;
select many fparms related by s_sync->S_SPARM[R24];
for each fparm in fparms
  self.FunctionParameter_dispose(s_sparm:fparm);
end for;
select one dt related by s_sync->S_DT[R25];
unrelate s_sync from dt across R25;
//
//Body Subsystem
/*
select one body related by s_sync->ACT_FNB[R695]->ACT_ACT[R698];
if (not_empty body)
  body.dispose();
end if;
//
// Invocation Subsystem
select many invs related by s_sync->ACT_FNC[R675];
for each inv in invs
  unrelate s_sync from inv across R675;
end for;
//
// Value Subsystem
select many fvs related by s_sync->V_FNV[R827];
for each fv in fvs
  unrelate s_sync from fv across R827;
end for;
//
// for each message that this function
// is associated with
select many fms related by s_sync->MSG_F[R1010];
for each fm in fms
  select one message related by fm->MSG_SM[R1020];
  message.unformalize();
end for;
*/
select many dims related by s_sync->S_DIM[R51];
for each dim in dims
  unrelate s_sync from dim across R51;
  delete object instance dim;
end for;
//
// Finally delete s_sync
delete object instance s_sync;',
	1,
	'',
	"a0f42bb1-d72e-4312-92e5-7f159a040629",
	0);
INSERT INTO O_TPARM
	VALUES ("f264463f-b294-4c06-8167-b7f5184bb84d",
	"54b7e196-537e-494c-9dc3-41d254b1bef3",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("03d0a6fa-5878-4fe5-a205-e0551b547d7e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_getSignature',
	'',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'/**
 *  Return a string representation of this functions signature
 *  Heavily adapted from OOAofOOA - LPS
 */
s_sync = param.s_sync;
 
signature = "";

// Get return type
select one returntype related by s_sync->S_DT[R25];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + s_sync.Name;

// Get parameters
// Get the first parameter.
select any parameter related by s_sync->S_SPARM[R24];
first_param = parameter;
while ( not_empty parameter )
  first_param = parameter;
  select one parameter related by parameter->S_SPARM[R54.''succeeds''];
end while;

if( not_empty first_param )
  signature = signature + "(";
end if;
separator = "";
parameter = first_param;
while ( not_empty parameter )
  select one type related by parameter->S_DT[R26];
  signature = signature + separator + type.Name;
  separator = " ";
  select one parameter related by parameter->S_SPARM[R54.''precedes''];
end while;
if( not_empty first_param )
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	"54b7e196-537e-494c-9dc3-41d254b1bef3",
	0);
INSERT INTO O_TPARM
	VALUES ("4cb18bc1-758a-4495-9b72-a4cbf5ce7ad7",
	"03d0a6fa-5878-4fe5-a205-e0551b547d7e",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("04105c47-d100-4b3a-8313-ab3ebf6cfcbd",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sync = param.s_sync;

// Heavily modified version of OOAofOOA''s Function::initialize()
select one packageableElem related by s_sync->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];

// Since this operation handles both functions and services, and services have void return types, we default to void here.
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "void" );
relate s_sync to def_dt across R25;

s_sync.Name = param.name;
s_sync.Suc_Pars = ParseStatus::parseInitial;

// Initialize Dialect to C (realized C code).  This will get changed
// to MASL when a codeblock is supplied.  If no codeblock is supplied,
// it means that the routine is implemented as C.
s_sync.Dialect = ActionDialect::c;
',
	1,
	'',
	"03d0a6fa-5878-4fe5-a205-e0551b547d7e",
	0);
INSERT INTO O_TPARM
	VALUES ("301c2345-663e-4765-b30e-c89f7c6d8122",
	"04105c47-d100-4b3a-8313-ab3ebf6cfcbd",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("84b5c25e-e117-4e02-87af-488defcb09ed",
	"04105c47-d100-4b3a-8313-ab3ebf6cfcbd",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"301c2345-663e-4765-b30e-c89f7c6d8122",
	'');
INSERT INTO O_TFR
	VALUES ("d4e35852-faeb-4278-ae1d-90f04a4710b7",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_newParameter',
	'',
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	1,
	's_sync = param.s_sync;

select any parm related by s_sync->S_SPARM[R24] where ( selected.Name == param.parameter_name );

if ( empty parm )
  create object instance parm of S_SPARM;
  relate s_sync to parm across R24;
  self.FunctionParameter_initialize(s_sparm:parm, name:param.parameter_name);
  self.Function_createMessageArgumentsForParameter(s_sync:s_sync, s_sparm:parm);
end if;

return parm;',
	1,
	'',
	"04105c47-d100-4b3a-8313-ab3ebf6cfcbd",
	0);
INSERT INTO O_TPARM
	VALUES ("db59fdeb-bf14-410b-81a5-63a56a98b1f2",
	"d4e35852-faeb-4278-ae1d-90f04a4710b7",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("d8879335-c714-4476-9d49-b7d1bb8c4022",
	"d4e35852-faeb-4278-ae1d-90f04a4710b7",
	'parameter_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"db59fdeb-bf14-410b-81a5-63a56a98b1f2",
	'');
INSERT INTO O_TFR
	VALUES ("557a4674-5317-48f0-9d8f-f66b98d27ec4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Function_setReturnType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sync = param.s_sync;
type_name = param.type_name;

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for function " + s_sync.Name);
else

  // unrelated the old return type type
  select one old_s_dt related by s_sync->S_DT[R25];
  if ( not_empty old_s_dt )
	unrelate old_s_dt from s_sync across R25;
  end if;
  
  // relate the new return type
  relate s_dt to s_sync across R25;

end if;',
	1,
	'',
	"d4e35852-faeb-4278-ae1d-90f04a4710b7",
	0);
INSERT INTO O_TPARM
	VALUES ("30fef1a8-2a4e-454b-a3e0-1f5a0b4cc226",
	"557a4674-5317-48f0-9d8f-f66b98d27ec4",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("34d41061-d9f5-4053-aee2-ade908814440",
	"557a4674-5317-48f0-9d8f-f66b98d27ec4",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"30fef1a8-2a4e-454b-a3e0-1f5a0b4cc226",
	'');
INSERT INTO O_TFR
	VALUES ("5811e27c-93dd-4d36-ab32-26236cf4df16",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceOperation_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// copied from the OOAofOOA - LPS
c_io = param.c_io;

select one dt related by c_io->S_DT[R4008];
if(not_empty dt)
  unrelate c_io from dt across R4008;
end if;
select one ep related by c_io->C_EP[R4004];
if(not_empty ep)
  self.ExecutableProperty_dispose( c_ep:ep );
end if;
select one successor related by c_io->C_IO[R4019.''precedes''];
select one predecessor related by c_io->C_IO[R4019.''succeeds''];
if (not empty successor)
  unrelate c_io from successor across R4019.''precedes'';
end if;
if (not empty predecessor)
  unrelate c_io from predecessor across R4019.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R4019.''succeeds'';
end if;
/*
select many msgs related by c_io->MSG_IOP[R1022]->MSG_SM[R1020]->MSG_M[R1018];
for each msg in msgs
  msg.dispose();
end for;
*/
select many dims related by c_io->S_DIM[R4018];
for each dim in dims
  unrelate c_io from dim across R4018;
  delete object instance dim;
end for;
delete object instance c_io;',
	1,
	'',
	"557a4674-5317-48f0-9d8f-f66b98d27ec4",
	0);
INSERT INTO O_TPARM
	VALUES ("5a741441-7222-4539-841f-72024e6ec3d5",
	"5811e27c-93dd-4d36-ab32-26236cf4df16",
	'c_io',
	"4e59980a-6ac2-4a28-8ad8-7f1ada83c53a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4e59980a-6ac2-4a28-8ad8-7f1ada83c53a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface Operation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TFR
	VALUES ("f939c71b-a29c-41a9-ba3f-c4f555943e4a",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceOperation_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_io = param.c_io;

// This is a heavily modified version  of OOAofOOA''s Interface Operation::initialize()
select one packageableElem related by c_io->C_EP[R4004]->C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];

select one interface related by c_io->C_EP[R4004]->C_I[R4003];
self.Interface_addInterfaceOperationToOrder(c_i:interface, c_io:c_io);

globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "void" );
relate c_io to def_dt across R4008;

c_io.Name = param.name;
c_io.Direction = IFDirectionType::ClientServer;  // Note: in MASL convert we just always default the direction.
',
	1,
	'',
	"5811e27c-93dd-4d36-ab32-26236cf4df16",
	0);
INSERT INTO O_TPARM
	VALUES ("c6290c88-56a7-43a9-95e7-5f3796276993",
	"f939c71b-a29c-41a9-ba3f-c4f555943e4a",
	'c_io',
	"4e59980a-6ac2-4a28-8ad8-7f1ada83c53a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("79191ca0-38b9-41ca-bb2c-d11151ac8d72",
	"f939c71b-a29c-41a9-ba3f-c4f555943e4a",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c6290c88-56a7-43a9-95e7-5f3796276993",
	'');
INSERT INTO O_TFR
	VALUES ("0669398f-2964-45ed-af75-3bde519f5156",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceOperation_setReturnType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_io = param.c_io;
type_name = param.type_name;

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for function " + c_io.Name);
else

  // unrelated the old return type type
  select one old_s_dt related by c_io->S_DT[R4008];
  if ( not_empty old_s_dt )
	unrelate old_s_dt from c_io across R4008;
  end if;
  
  // relate the new return type
  relate s_dt to c_io across R4008;

end if;',
	1,
	'',
	"f939c71b-a29c-41a9-ba3f-c4f555943e4a",
	0);
INSERT INTO O_TPARM
	VALUES ("dd0fb07c-2e32-4a0a-a852-dca5506c4018",
	"0669398f-2964-45ed-af75-3bde519f5156",
	'c_io',
	"4e59980a-6ac2-4a28-8ad8-7f1ada83c53a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("054d4de7-88ea-4527-8d3b-0a3e2102793e",
	"0669398f-2964-45ed-af75-3bde519f5156",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"dd0fb07c-2e32-4a0a-a852-dca5506c4018",
	'');
INSERT INTO O_TFR
	VALUES ("4cb09a0b-9065-4b08-b675-4afe52483446",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceParameter_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_pp = param.c_pp;

select one c_ep related by c_pp->C_EP[R4006];
self.Interface_addParameterToOrder(c_ep:c_ep, c_pp:c_pp);

// TODO - assign a default type to aid in testing.  Do we want to keep this (to // END)?
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
// END

relate c_pp to def_dt across R4007;
c_pp.Name = param.name;
    ',
	1,
	'',
	"0669398f-2964-45ed-af75-3bde519f5156",
	0);
INSERT INTO O_TPARM
	VALUES ("02233d55-ebeb-4959-8dab-ed7f441db6a8",
	"4cb09a0b-9065-4b08-b675-4afe52483446",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TPARM
	VALUES ("5d2e607e-240a-4fb1-862b-bc722e49a653",
	"4cb09a0b-9065-4b08-b675-4afe52483446",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"02233d55-ebeb-4959-8dab-ed7f441db6a8",
	'');
INSERT INTO O_TFR
	VALUES ("1a6bf3c5-8357-4fee-8371-0acc409099c1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceParameter_setType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_pp = param.c_pp;
type_name = param.type_name;

// NOTE: This isn''t really a copied operation from the OOAofOOA, but we''re following the same paradigm for it
//   as other functions that are from the OOA

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for attribute " + c_pp.Name);
end if;

// Get a handle to the DT that is currently associated with the attribute
select one cur_s_dt related by c_pp->S_DT[R4007];

// If the new DT does not equal the existing DT, continue
if ( s_dt != cur_s_dt )
  // un-relate the existing DT across R4007
  unrelate c_pp from cur_s_dt across R4007;
  
  // relate the new attribute across R4007
  relate c_pp to s_dt across R4007;
end if;',
	1,
	'',
	"4cb09a0b-9065-4b08-b675-4afe52483446",
	0);
INSERT INTO O_TPARM
	VALUES ("918f2157-6dc5-402e-b5d6-aae708f4fa8d",
	"1a6bf3c5-8357-4fee-8371-0acc409099c1",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("ffd7f614-b070-41f4-93d4-684376d96361",
	"1a6bf3c5-8357-4fee-8371-0acc409099c1",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"918f2157-6dc5-402e-b5d6-aae708f4fa8d",
	'');
INSERT INTO O_TFR
	VALUES ("6835a66c-8a7a-4863-85b2-2101098d08b6",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceReference_createSignalsAndOperations',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'interface = param.c_i;
c_ir = param.c_ir;

if(not_empty interface)
  select many operations related by interface->C_EP[R4003]->C_IO[R4004];
  select many signals related by interface->C_EP[R4003]->C_AS[R4004];
  select one requirement related by c_ir->C_R[R4009];
  if(not_empty requirement)
    for each signal in signals
      select one ep related by signal->C_EP[R4004];
      create object instance req_ep of SPR_REP;
      create object instance req_signal of SPR_RS;
      req_signal.Suc_Pars = ParseStatus::parseInitial;
      // Initialize Dialect to C (realized C code).  This will get changed
      // to MASL when a codeblock is supplied.  If no codeblock is supplied,
      // it means that the routine is implemented as C.
      req_signal.Dialect = ActionDialect::c;
      relate requirement to ep across R4500 using req_ep;
      relate req_signal to req_ep across R4502;
    end for;
    for each operation in operations
      select one ep related by operation->C_EP[R4004];
      create object instance req_ep of SPR_REP;
      create object instance req_operation of SPR_RO;
      req_operation.Suc_Pars = ParseStatus::parseInitial;
      // Initialize Dialect to C (realized C code).  This will get changed
      // to MASL when a codeblock is supplied.  If no codeblock is supplied,
      // it means that the routine is implemented as C.
      req_operation.Dialect = ActionDialect::c;
      relate requirement to ep across R4500 using req_ep;
      relate req_operation to req_ep across R4502;
    end for;
  else
    select one provision related by c_ir->C_P[R4009];
    for each signal in signals
      select one ep related by signal->C_EP[R4004];
      create object instance pro_ep of SPR_PEP;
      create object instance pro_signal of SPR_PS;
      pro_signal.Suc_Pars = ParseStatus::parseInitial;
      relate provision to ep across R4501 using pro_ep;
      relate pro_signal to pro_ep across R4503;
    end for;
    for each operation in operations
      select one ep related by operation->C_EP[R4004];
      create object instance pro_ep of SPR_PEP;
      create object instance pro_operation of SPR_PO;
      pro_operation.Suc_Pars = ParseStatus::parseInitial;
      relate provision to ep across R4501 using pro_ep;
      relate pro_operation to pro_ep across R4503;
    end for;
  end if;
end if;',
	1,
	'',
	"1a6bf3c5-8357-4fee-8371-0acc409099c1",
	0);
INSERT INTO O_TPARM
	VALUES ("32e0815d-f086-4a65-bb42-d7dc6551abff",
	"6835a66c-8a7a-4863-85b2-2101098d08b6",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("80698720-cc57-44ba-8aa5-600c524db338",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TPARM
	VALUES ("77a80229-fd7d-4b95-b541-aedddc453c31",
	"6835a66c-8a7a-4863-85b2-2101098d08b6",
	'c_ir',
	"3068be83-fc38-4a02-a09f-a2dc428b84f6",
	0,
	'',
	"32e0815d-f086-4a65-bb42-d7dc6551abff",
	'');
INSERT INTO O_TFR
	VALUES ("57062b34-c538-41d6-a7cf-0e01b0c779b9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceReference_formalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_i = param.c_i;
c_ir = param.c_ir;

// This version is nothing like the OOAofOOA InterfaceReference::formalize().  We have cut out functionality that isn''t needed for MASL
// convert (e.g. handling of delegations, formalizing the other side of a satisfaction, etc)

if ( not_empty c_i and not_empty c_ir )
  self.InterfaceReference_createSignalsAndOperations(c_i:c_i, c_ir:c_ir);
  relate c_i to c_ir across R4012;
end if;
',
	1,
	'',
	"6835a66c-8a7a-4863-85b2-2101098d08b6",
	0);
INSERT INTO O_TPARM
	VALUES ("4651a83e-fab3-439d-a521-f14029ed2446",
	"57062b34-c538-41d6-a7cf-0e01b0c779b9",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("efa2e326-7f57-4570-86ca-f1ceafbcb920",
	"57062b34-c538-41d6-a7cf-0e01b0c779b9",
	'c_ir',
	"3068be83-fc38-4a02-a09f-a2dc428b84f6",
	0,
	'',
	"4651a83e-fab3-439d-a521-f14029ed2446",
	'');
INSERT INTO O_TFR
	VALUES ("d2b67909-2d68-40f2-b809-91634e22a88d",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceReference_isFormal',
	'',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'// TODO - populate this activity
return false;',
	1,
	'',
	"57062b34-c538-41d6-a7cf-0e01b0c779b9",
	0);
INSERT INTO O_TPARM
	VALUES ("bf5d7e39-85c4-4691-97bd-3b475ef7fd92",
	"d2b67909-2d68-40f2-b809-91634e22a88d",
	'c_ir',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("1c58ade2-c3b9-464c-ad57-033ecc2e32d4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'InterfaceSignal_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// copied from the OOAofOOA - LPS
c_as = param.c_as;

select one ep related by c_as->C_EP[R4004];
if(not_empty ep)
  self.ExecutableProperty_dispose( c_ep:ep );
end if;
select one successor related by c_as->C_AS[R4020.''precedes''];
select one predecessor related by c_as->C_AS[R4020.''succeeds''];
if (not empty successor)
  unrelate c_as from successor across R4020.''precedes'';
end if;
if (not empty predecessor)
  unrelate c_as from predecessor across R4020.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R4020.''succeeds'';
end if;
/*
select many msgs related by c_as->MSG_SIG[R1021]->MSG_AM[R1019]->MSG_M[R1018];
for each msg in msgs
  msg.dispose();
end for;
*/
delete object instance c_as;',
	1,
	'',
	"d2b67909-2d68-40f2-b809-91634e22a88d",
	0);
INSERT INTO O_TPARM
	VALUES ("6129ac8d-c84f-4109-936e-087523d14b1f",
	"1c58ade2-c3b9-464c-ad57-033ecc2e32d4",
	'c_as',
	"50196fb3-a630-4359-b9d2-adf4b3946cbc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("50196fb3-a630-4359-b9d2-adf4b3946cbc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface Signal>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TFR
	VALUES ("aee3868e-6169-47d8-be8f-b8a583b06894",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Interface_addInterfaceOperationToOrder',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_i = param.c_i;
interfaceOperation = param.c_io;

// Slightly modified version compared to OOA
if(not_empty interfaceOperation)
  select many peers related by c_i->C_EP[R4003]->C_IO[R4004];
  for each peer in peers
    if (peer != interfaceOperation)
      select one predecessor related by peer->C_IO[R4019.''precedes''];
      if (empty predecessor)
        relate interfaceOperation to peer across R4019.''succeeds'';
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	"1c58ade2-c3b9-464c-ad57-033ecc2e32d4",
	0);
INSERT INTO O_TPARM
	VALUES ("1b56be93-b44c-451c-acda-b0c11d5c79d0",
	"aee3868e-6169-47d8-be8f-b8a583b06894",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("7d7c00c8-1f27-430b-a6b1-1e3038b31a63",
	"aee3868e-6169-47d8-be8f-b8a583b06894",
	'c_io',
	"4e59980a-6ac2-4a28-8ad8-7f1ada83c53a",
	0,
	'',
	"1b56be93-b44c-451c-acda-b0c11d5c79d0",
	'');
INSERT INTO O_TFR
	VALUES ("4b00d955-7b6d-4e74-a420-540a623dee8f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Interface_addParameterToOrder',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_ep = param.c_ep;
parameter = param.c_pp;

if(not_empty parameter)
  select many peers related by c_ep->C_PP[R4006];
  for each peer in peers
    if (peer != parameter)
      select one predecessor related by peer->C_PP[R4021.''precedes''];
      if (empty predecessor)
        relate parameter to peer across R4021.''succeeds'';
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	"aee3868e-6169-47d8-be8f-b8a583b06894",
	0);
INSERT INTO O_TPARM
	VALUES ("005aeabd-91db-4ce1-b467-d937c484127a",
	"4b00d955-7b6d-4e74-a420-540a623dee8f",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("7ccb51e4-6ed2-4968-a790-b4904bcdc7f2",
	"4b00d955-7b6d-4e74-a420-540a623dee8f",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"005aeabd-91db-4ce1-b467-d937c484127a",
	'');
INSERT INTO O_TFR
	VALUES ("17976bb5-fe5c-4cd0-9988-c3c17d9431be",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Interface_createMessageArgumentsForParameter',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_ep = param.c_ep;
parameter = param.c_pp;

if(not_empty parameter)
  // for each message associated with this interface
  // create a message argument
  select many messages related by c_ep->C_AS[R4004]->MSG_SIG[R1021]->
                                                    MSG_AM[R1019]->MSG_M[R1018];
  if(empty messages)
    select many messages related by c_ep->C_IO[R4004]->MSG_IOP[R1022]->
    											    MSG_SM[R1020]->MSG_M[R1018];
  end if;
  for each message in messages
    create object instance arg of MSG_A;
    create object instance oa of MSG_EPA;
    relate oa to parameter across R1023;
    relate oa to arg across R1013;
    relate message to arg across R1001;
  end for;
end if;',
	1,
	'',
	"4b00d955-7b6d-4e74-a420-540a623dee8f",
	0);
INSERT INTO O_TPARM
	VALUES ("b9d699bc-aea9-4882-a3a7-0a154a670d32",
	"17976bb5-fe5c-4cd0-9988-c3c17d9431be",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("ee254343-4ac7-4d14-a7d2-4ba95fb2a038",
	"17976bb5-fe5c-4cd0-9988-c3c17d9431be",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"b9d699bc-aea9-4882-a3a7-0a154a670d32",
	'');
INSERT INTO O_TFR
	VALUES ("4bcee4ef-3c97-4a34-b6c7-6ff325a72ffb",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Interface_newExecutableProperty',
	'',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	1,
	'c_i = param.c_i;

create object instance signal of C_EP;
signal.Name = param.ep_name;
relate c_i to signal across R4003;
select many references related by c_i->C_IR[R4012];
if(param.asynchronous)
  //create object instance asignal of C_AS;
  //relate signal to asignal across R4004;
  //asignal.initialize();
else
  create object instance ssignal of C_IO;
  relate signal to ssignal across R4004;
  self.InterfaceOperation_initialize(c_io:ssignal, name:param.ep_name);
end if;

return signal;',
	1,
	'',
	"17976bb5-fe5c-4cd0-9988-c3c17d9431be",
	0);
INSERT INTO O_TPARM
	VALUES ("844f44cb-2b89-476a-bb92-7f9a4d024f53",
	"4bcee4ef-3c97-4a34-b6c7-6ff325a72ffb",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("ea50d552-3ba0-4a01-837a-2ae7da44af51",
	"4bcee4ef-3c97-4a34-b6c7-6ff325a72ffb",
	'ep_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"844f44cb-2b89-476a-bb92-7f9a4d024f53",
	'');
INSERT INTO O_TPARM
	VALUES ("201ae79d-9e88-411c-b22e-a0b283018f7b",
	"4bcee4ef-3c97-4a34-b6c7-6ff325a72ffb",
	'asynchronous',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"ea50d552-3ba0-4a01-837a-2ae7da44af51",
	'');
INSERT INTO O_TFR
	VALUES ("9b3a32dd-00ad-426d-a28c-1953c0c94bb4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Interface_newParameter',
	'',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	1,
	'c_ep = param.c_ep;

select any parm related by c_ep->C_PP[R4006] where ( selected.Name == param.parameter_name );

if ( empty parm )
  create object instance parm of C_PP;
  relate c_ep to parm across R4006;
  self.InterfaceParameter_initialize(c_pp:parm, name:param.parameter_name);
  self.Interface_createMessageArgumentsForParameter(c_ep:c_ep, c_pp:parm);
end if;

return parm;',
	1,
	'',
	"4bcee4ef-3c97-4a34-b6c7-6ff325a72ffb",
	0);
INSERT INTO O_TPARM
	VALUES ("b7440957-452b-41a4-ba86-5056ccf69b79",
	"9b3a32dd-00ad-426d-a28c-1953c0c94bb4",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("6c50318c-b91f-469d-8df9-430ceb8e4190",
	"9b3a32dd-00ad-426d-a28c-1953c0c94bb4",
	'parameter_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"b7440957-452b-41a4-ba86-5056ccf69b79",
	'');
INSERT INTO O_TFR
	VALUES ("61427e63-3aba-40a8-b912-954084233992",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'LinkedAssociation_formalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_assoc = param.r_assoc;

if ( self.LinkedAssociation_isFormalized(r_assoc:r_assoc) )
  self.LinkedAssociation_unformalize(r_assoc:r_assoc);
end if;

select one aone_rto related by r_assoc->R_AONE[R209]->R_RTO[R204];
select one aone_obj related by aone_rto->R_OIR[R203]->O_OBJ[R201];
select any aone_oid related by aone_obj->O_ID[R104] where selected.Oid_ID == param.one_id;
relate aone_oid to aone_rto across R109;

select one aoth_rto related by r_assoc->R_AOTH[R210]->R_RTO[R204];
select one aoth_obj related by aoth_rto->R_OIR[R203]->O_OBJ[R201];
select any aoth_oid related by aoth_obj->O_ID[R104] where selected.Oid_ID == param.oth_id;
relate aoth_oid to aoth_rto across R109;

select one assr_rgo related by r_assoc->R_ASSR[R211]->R_RGO[R205];
select one assr_obj related by assr_rgo->R_OIR[R203]->O_OBJ[R201];
// unused_oid = assr_obj.findUnusedIdentifier(); LPS - we do not need to automatically ad to an identifier because this
// will be done later by the rest of the MASL convert

select one rel related by r_assoc->R_REL[R206];
select many aone_oida_set related by aone_oid->O_OIDA[R105];
for each oida in aone_oida_set
    newAttr = self.ClassIdentifierAttribute_addReference(o_oida:oida, rel:rel,
        part_rto: aone_rto, part_obj: aone_obj, 
        form_rgo: assr_rgo, form_obj: assr_obj,
        id: -1);
        //id: unused_oid);
end for;

select many aoth_oida_set related by aoth_oid->O_OIDA[R105];
for each oida in aoth_oida_set
    newAttr = self.ClassIdentifierAttribute_addReference(o_oida:oida, rel:rel,
        part_rto: aoth_rto, part_obj: aoth_obj, 
        form_rgo: assr_rgo, form_obj: assr_obj,
        id: -1);
        //id: unused_oid);
end for;
',
	1,
	'',
	"9b3a32dd-00ad-426d-a28c-1953c0c94bb4",
	0);
INSERT INTO O_TPARM
	VALUES ("86ee62ca-4c02-4d02-ab00-4860b9255258",
	"61427e63-3aba-40a8-b912-954084233992",
	'one_id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"280a5293-aff1-408a-a691-c227a46cb378",
	'');
INSERT INTO O_TPARM
	VALUES ("bd732444-0340-43f2-a328-83293e27685c",
	"61427e63-3aba-40a8-b912-954084233992",
	'oth_id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"86ee62ca-4c02-4d02-ab00-4860b9255258",
	'');
INSERT INTO O_TPARM
	VALUES ("280a5293-aff1-408a-a691-c227a46cb378",
	"61427e63-3aba-40a8-b912-954084233992",
	'r_assoc',
	"7f02c6dd-ea5d-4892-801e-a1515764350f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7f02c6dd-ea5d-4892-801e-a1515764350f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Linked Association>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("4ab081b6-31c9-4f91-a9e7-33b3421af54c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'LinkedAssociation_isFormalized',
	'',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'r_assoc = param.r_assoc;

select one rto1 related by r_assoc->R_AONE[R209]->R_RTO[R204];
select any rtida1 related by rto1->O_RTIDA[R110];
select one rto2 related by r_assoc->R_AOTH[R210]->R_RTO[R204];
select any rtida2 related by rto2->O_RTIDA[R110];
return not_empty rtida1 and not_empty rtida2;
',
	1,
	'',
	"61427e63-3aba-40a8-b912-954084233992",
	0);
INSERT INTO O_TPARM
	VALUES ("2ee60fa3-b8a5-4c95-823e-f40f120e54c7",
	"4ab081b6-31c9-4f91-a9e7-33b3421af54c",
	'r_assoc',
	"7f02c6dd-ea5d-4892-801e-a1515764350f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("9a0495d0-0627-49c7-a703-593c23b0b715",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'LinkedAssociation_unformalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_assoc = param.r_assoc;

select one aone_rto related by r_assoc->R_AONE[R209]->R_RTO[R204];
select one aone_oir related by aone_rto->R_OIR[R203];
select one aoth_rto related by r_assoc->R_AOTH[R210]->R_RTO[R204];
select one aoth_oir related by aoth_rto->R_OIR[R203];

self.ReferredToClassInAssoc_unformalize(r_rto:aone_rto);
self.ReferredToClassInAssoc_unformalize(r_rto:aoth_rto);

// have to relate again due to propagation of previous unrelates
relate aone_oir to aone_rto across R203;
relate aoth_oir to aoth_rto across R203;


',
	1,
	'',
	"4ab081b6-31c9-4f91-a9e7-33b3421af54c",
	0);
INSERT INTO O_TPARM
	VALUES ("3b1f4f64-d355-4ba3-899d-7ced4a9172f7",
	"9a0495d0-0627-49c7-a703-593c23b0b715",
	'r_assoc',
	"7f02c6dd-ea5d-4892-801e-a1515764350f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("4f78843e-d7cb-4c85-95c6-d9690d09511d",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_addAttributeToOrdering',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_obj = param.o_obj;
newAttr = param.newAttr;

select many attrs related by o_obj->O_ATTR[R102];
for each attr in attrs
 select one nextAttr related by attr->O_ATTR[R103.''precedes''];
  if (empty nextAttr)
    break;
  end if;
end for;
if (not_empty attr)
  //
  // If there was a previous last attribute link this one to the end . . .
  // NOTE: Modified from the ooa version of this function here because it turns off listeners which
  //   we don''t have to worry about during masl convert.
  relate attr to newAttr across R103.''precedes'';
end if;
',
	1,
	'',
	"9a0495d0-0627-49c7-a703-593c23b0b715",
	0);
INSERT INTO O_TPARM
	VALUES ("613f3f09-3c80-4308-be39-776fd3f198b2",
	"4f78843e-d7cb-4c85-95c6-d9690d09511d",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("31247688-0106-4571-9519-9f5efcdec684",
	"4f78843e-d7cb-4c85-95c6-d9690d09511d",
	'newAttr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"613f3f09-3c80-4308-be39-776fd3f198b2",
	'');
INSERT INTO O_TFR
	VALUES ("63cb30c9-0018-4cf8-a1b3-8a443e051294",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_addIdentifiers',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_obj = param.o_obj;

select any oid1 related by o_obj->O_ID[R104] where ( selected.Oid_ID == 0 );
if ( empty oid1 )
  create object instance oid1 of O_ID;
  oid1.Oid_ID = 0;
  relate oid1 to o_obj across R104;
end if;
select any oid2 related by o_obj->O_ID[R104] where ( selected.Oid_ID == 1 );
if ( empty oid2 )
  create object instance oid2 of O_ID;
  oid2.Oid_ID = 1;
  relate oid2 to o_obj across R104;
end if;
select any oid3 related by o_obj->O_ID[R104] where ( selected.Oid_ID == 2 );
if ( empty oid3 )
  create object instance oid3 of O_ID;
  oid3.Oid_ID = 2;
  relate oid3 to o_obj across R104;
end if;
',
	1,
	'',
	"4f78843e-d7cb-4c85-95c6-d9690d09511d",
	0);
INSERT INTO O_TPARM
	VALUES ("9bb7ddb9-f042-4b24-b014-d18258ac0feb",
	"63cb30c9-0018-4cf8-a1b3-8a443e051294",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("296a585c-74c6-4d68-921d-89403596bf71",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_addOperationToOrdering',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_obj = param.o_obj;
operation = param.newTfr;

if(not_empty operation)
  select many peers related by o_obj->O_TFR[R115];
  for each peer in peers
    if (peer != operation)
      select one predecessor related by peer->O_TFR[R125.''precedes''];
      if (empty predecessor)
        relate operation to peer across R125.''succeeds'';
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	"63cb30c9-0018-4cf8-a1b3-8a443e051294",
	0);
INSERT INTO O_TPARM
	VALUES ("77f2f767-cf2d-4412-875c-c415bccdaf79",
	"296a585c-74c6-4d68-921d-89403596bf71",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("7f42518e-e080-4dbc-9d52-8571a992de13",
	"296a585c-74c6-4d68-921d-89403596bf71",
	'newTfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"77f2f767-cf2d-4412-875c-c415bccdaf79",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("8c8f1b54-df65-4eda-b20b-b2c076be0434",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_create_sm',
	'',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	1,
	'o_obj = param.o_obj;

// This is a modified version of the OOAofOOA version of this function
if (param.sm_type == "ISM")
  select one ism related by o_obj->SM_ISM[R518];
  if (not_empty ism)
    select one sm_sm related by ism->SM_SM[R517];
    return sm_sm;
  else
    create object instance ism of SM_ISM;
    relate o_obj to ism across R518;
    create object instance sm of SM_SM;
    relate ism to sm across R517;
    create object instance moore of SM_MOORE;
    relate sm to moore across R510;
    // add current state attribute
    o_attr = self.ModelClass_newAttribute(o_obj:o_obj, attr_name:"current_state");
    globaltypes_pkg = self.globaltypes_pkg;
    select any s_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "state<State_Model>" );
    if ( not_empty s_dt )
      select one old_s_dt related by o_attr->S_DT[R114];
      unrelate o_attr from old_s_dt across R114;
      relate o_attr to s_dt across R114;
    else
      TRACE::log( flavor:"failure", id:59, message:"Unable to locate expected data type: void while creating state machine for " + o_obj.Name );
    end if;
    self.StateMachine_syncPolymorphicEvents( sm_sm:sm );
    return sm;
  end if;
elif (param.sm_type == "ASM")
  select one sm_asm related by o_obj->SM_ASM[R519];
  if(not_empty sm_asm)
    select one sm_sm related by sm_asm->SM_SM[R517];
    return sm_sm;
  else
    create object instance sm_asm of SM_ASM;
    relate o_obj to sm_asm across R519;
    create object instance sm of SM_SM;
    relate sm_asm to sm across R517;
    create object instance moore of SM_MOORE;
    relate sm to moore across R510;
    return sm;
  end if;
end if;
select any sm_sm from instances of SM_SM where ( false );
return sm_sm;',
	1,
	'',
	"296a585c-74c6-4d68-921d-89403596bf71",
	0);
INSERT INTO O_TPARM
	VALUES ("b6443715-e0d8-4ec5-b6e5-c96e21924af6",
	"8c8f1b54-df65-4eda-b20b-b2c076be0434",
	'sm_type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"dbe2b015-3dc2-4e8e-8f08-3cb58406ba86",
	'');
INSERT INTO O_TPARM
	VALUES ("dbe2b015-3dc2-4e8e-8f08-3cb58406ba86",
	"8c8f1b54-df65-4eda-b20b-b2c076be0434",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6562655-0940-4f4f-a1ae-7094b79949a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TFR
	VALUES ("4b661a12-80d7-43b7-a706-6bfcf75f4aa0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_obj = param.o_obj;
o_obj.Name = param.name;

select one packageableElem related by o_obj->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];

// Note that this is here just to get the variable classes into context.
select many classes related by package->PE_PE[R8000]->O_OBJ[R8001];

  if (not_empty package)
    // we''re in a package, get the classes in the package and set the class number
    select many classes related by package->PE_PE[R8000]->O_OBJ[R8001];
    if ( package.Num_Rng == 0 )
      o_obj.Numb = 1;
    else
      o_obj.Numb = package.Num_Rng;
    end if;
  else
    rootCompIdInPkg = self.Component_getRootComponentId(c_c:component);
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
    
    if ( package.Num_Rng == 0 )
      o_obj.Numb = 1;
    else
      o_obj.Numb = package.Num_Rng;
    end if;
  end if;

// for each model-class associated with this model-class''s
// owning subsystem or package
for each clazz in classes
  // if this class equals self, skip it
  if (clazz.Obj_ID == o_obj.Obj_ID) continue; end if;

  // if this other class''s number is greater than this model-class''s number
  if (clazz.Numb >= o_obj.Numb)
    // have this model-class''s number be just greater
    // than this other class''s number
    o_obj.Numb = clazz.Numb + 1;
  end if;
end for;

// MASL object names are not allowed to have spaces, so we can just use the name as the default key letters
o_obj.Key_Lett = o_obj.Name;
self.ModelClass_addIdentifiers(o_obj:o_obj);

// For MASL convert we want to go ahead and "Publish References" for the new class
self.ModelClass_newInstanceReferenceDataType(o_obj:o_obj);
',
	1,
	'',
	"8c8f1b54-df65-4eda-b20b-b2c076be0434",
	0);
INSERT INTO O_TPARM
	VALUES ("7ed39619-c183-4b4b-b89e-60a814d20d9f",
	"4b661a12-80d7-43b7-a706-6bfcf75f4aa0",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("9bcbf047-1c76-4611-902c-5d69d2cfb42a",
	"4b661a12-80d7-43b7-a706-6bfcf75f4aa0",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"7ed39619-c183-4b4b-b89e-60a814d20d9f",
	'');
INSERT INTO O_TFR
	VALUES ("a9cb917f-5334-4e4d-8fb3-bd57ca5352bc",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_newAttribute',
	'',
	"579b8247-e153-481d-8926-384cdc722464",
	1,
	'o_obj = param.o_obj;

// NOTE: This is a heavily modified version of Model Class::newAttribute.  That function in the OOAofOOA does
//   extra work for classes in Sequence Diagrams that we don''t have to deal with here in masl convert.

//
// Find the last attribute currently in the list
//
create object instance newAttr of O_ATTR;
self.ModelClass_addAttributeToOrdering(o_obj:o_obj, newAttr:newAttr);
relate o_obj to newAttr across R102;
self.Attribute_initialize(o_attr:newAttr, name:param.attr_name);
return newAttr;
',
	1,
	'',
	"4b661a12-80d7-43b7-a706-6bfcf75f4aa0",
	0);
INSERT INTO O_TPARM
	VALUES ("5d60f8bb-16d9-4de8-8023-daad30a48096",
	"a9cb917f-5334-4e4d-8fb3-bd57ca5352bc",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("d2a48b40-d5b9-4c1f-b4a9-ac8b4bc5fc67",
	"a9cb917f-5334-4e4d-8fb3-bd57ca5352bc",
	'attr_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5d60f8bb-16d9-4de8-8023-daad30a48096",
	'');
INSERT INTO O_TFR
	VALUES ("c6de4c5b-7eec-47d7-b72d-9dc91b1f2977",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_newInstanceReferenceDataType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_obj = param.o_obj;

// Model Class::newInstanceReferenceDataType()
select one packageableElem related by o_obj->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];

  // Make sure the IRDTs don''t already exist before creating new ones.  Check
  // the single and set version and create whatever does not exist.
  select any existing_irdt related by o_obj->S_IRDT[R123] where selected.isSet == false;
  if (empty existing_irdt)
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    self.PackageableElement_initialize(pe_pe:pe);
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt of S_DT;
    relate pe to dt across R8001;
    create object instance irdt of S_IRDT;
    irdt.isSet = false;
    relate dt to irdt across R17;

    self.Datatype_initialize(s_dt:dt, name:"inst_ref<" + o_obj.Name + ">");
    relate o_obj to irdt across R123;
  end if;

  select any existing_irdt_set related by o_obj->S_IRDT[R123] where selected.isSet == true;
  if (empty existing_irdt_set)
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    self.PackageableElement_initialize(pe_pe:pe);
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt2 of S_DT;
    relate pe to dt2 across R8001;
    create object instance irsdt of S_IRDT;
    irsdt.isSet = true;
    relate irsdt to dt2 across R17;

    self.Datatype_initialize(s_dt:dt2, name:"inst_ref_set<" + o_obj.Name + ">");
    relate o_obj to irsdt across R123;
  end if;  

',
	1,
	'',
	"a9cb917f-5334-4e4d-8fb3-bd57ca5352bc",
	0);
INSERT INTO O_TPARM
	VALUES ("f5f8713e-db7d-41ba-bee6-6113d0bb492d",
	"c6de4c5b-7eec-47d7-b72d-9dc91b1f2977",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("16ec61e1-b02a-4dd2-9db4-532ca973a8b8",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_newOperation',
	'',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	1,
	'o_obj = param.o_obj;

create object instance operation of O_TFR;
relate o_obj to operation across R115;
self.Operation_initialize(o_tfr:operation, name:param.op_name);

return operation;
',
	1,
	'',
	"c6de4c5b-7eec-47d7-b72d-9dc91b1f2977",
	0);
INSERT INTO O_TPARM
	VALUES ("e9d70a97-ecf2-4d93-a706-3e55ffb077a4",
	"16ec61e1-b02a-4dd2-9db4-532ca973a8b8",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("21ef9e4a-0b06-4cde-b718-1e4b8a23c64b",
	"16ec61e1-b02a-4dd2-9db4-532ca973a8b8",
	'op_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e9d70a97-ecf2-4d93-a706-3e55ffb077a4",
	'');
INSERT INTO O_TFR
	VALUES ("6fa6b354-af9f-4399-a98d-fccf1d354ac1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_newReferentialAttribute',
	'',
	"9bb4b389-b488-46e0-aeca-fc90df7b856a",
	1,
	'o_obj = param.o_obj;
ref_oida = param.o_oida;
id = param.id;

//select any ref_obj related by o_obj->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
//    where selected.Obj_ID == param.ref_obj_id;

    
//select any ref_oid related by ref_obj->O_ID[R104] 
//    where selected.Oid_ID == param.ref_oid_id;
//select any ref_oida related by ref_oid->O_OIDA[R105] 
//    where selected.Attr_ID == param.ref_attr_id;
select one ref_oid related by ref_oida->O_ID[R105];

select one id_attr related by ref_oida->O_ATTR[R105];

select one base_attr related by id_attr->O_BATTR[R106];
if ( empty base_attr )
  select one base_attr related by id_attr->O_RATTR[R106]->O_BATTR[R113];
end if;

//newAttr_id = o_obj.newAttribute();
//select any attr related by o_obj->O_ATTR[R102] where selected.Attr_ID == newAttr_id;
attr = self.ModelClass_newAttribute( o_obj:o_obj, attr_name:"placeholder" );
self.Attribute_migrateBaseToReferential( o_attr:attr );
attr.Root_Nam = id_attr.Root_Nam;

select one ref_attr related by attr->O_RATTR[R106];
if ( not_empty base_attr )
  relate ref_attr to base_attr across R113;
else
  // baseless referential - get the data type from the referred-to identifier attribute
  select one id_s_dt related by id_attr->S_DT[R114];
  select one ref_s_dt related by attr->S_DT[R114];
  if ( not_empty ref_s_dt )
    unrelate ref_s_dt from attr across R114;
  end if;
  relate id_s_dt to attr across R114;
end if;

if ( param.id != -1 )
  select any assr_id related by o_obj->O_ID[R104] where selected.Oid_ID == param.id;
  create object instance assr_oida of O_OIDA;
   relate attr to assr_id across R105 using assr_oida;
end if;
return ref_attr;
',
	1,
	'',
	"16ec61e1-b02a-4dd2-9db4-532ca973a8b8",
	0);
INSERT INTO O_TPARM
	VALUES ("9fc9db6f-bfec-4ef7-8036-d9caeae530ef",
	"6fa6b354-af9f-4399-a98d-fccf1d354ac1",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("a27a5a20-e6cf-4d8d-9e68-b7d9fc320c18",
	"6fa6b354-af9f-4399-a98d-fccf1d354ac1",
	'o_oida',
	"08de18fb-cb5f-4d53-9826-375c4dad56f7",
	0,
	'',
	"9fc9db6f-bfec-4ef7-8036-d9caeae530ef",
	'');
INSERT INTO O_TPARM
	VALUES ("75afd240-8f4f-42c9-a149-c164b4dcad99",
	"6fa6b354-af9f-4399-a98d-fccf1d354ac1",
	'id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"a27a5a20-e6cf-4d8d-9e68-b7d9fc320c18",
	'');
INSERT INTO O_TFR
	VALUES ("ea1ce3ec-1a63-40a3-9813-07b776b65c1c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ModelClass_removeDuplicateAttrs',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// This is not from the OOAofOOA. This is to support formalization
o_obj = param.o_obj;

// post processing for the formalizing object
// * remove any base attributes that have a referential attribute of the same name
select many battrs related by o_obj->O_ATTR[R102]->O_BATTR[R106]->O_ATTR[R106];
select many rattrs related by o_obj->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106];
for each battr in battrs
  for each rattr in rattrs
    if ( rattr.Root_Nam == battr.Root_Nam )
      // Copy over the description field from the original attribute
      if ( ( "" != battr.Descrip ) and ( rattr.Descrip != battr.Descrip ) )
        rattr.Descrip = rattr.Descrip + battr.Descrip;
      end if;
      
      // copy the data type from the original attribute
      select one s_dt related by battr->S_DT[R114];
      select one old_dt related by rattr->S_DT[R114];
      if ( not_empty old_dt )
        unrelate old_dt from rattr across R114;
      end if;
      if ( not_empty s_dt )
        relate s_dt to rattr across R114;
      end if;

      // copy the ordering information to the new referential attribute

      // remove rattr from ordering (logic borrowed from Attribute_dispose)
	  select one rattr_next related by rattr->O_ATTR[R103.''precedes''];
	  if(not_empty rattr_next)
		select one rattr_prev related by rattr->O_ATTR[R103.''succeeds''];
		if ( empty rattr_prev )
		  // this attribute is at the top of the list
		  unrelate rattr from rattr_next across R103.''precedes'';
		else
		  // otherwise this attribute is somewhere in the middle
		  // or at the end
		  select many attrs related by o_obj->O_ATTR[R102];
		  for each attr in attrs
			select one thisAttr related by attr->O_ATTR[R103.''precedes''];
			if (rattr == thisAttr)
			  // now tell the next attribute that this is not
			  // the attribute that it succeeds anymore
			  unrelate rattr from rattr_next across R103.''precedes'';
			  // and tell this attribute that it no longer succeeds
			  // any attribute. 
			  // *NOTE* this is not really required for deletion but
			  // more for restoration
			  unrelate rattr from attr across R103.''succeeds'';
			  // finally connect the two attributes that this
			  // attribute was between
			  relate rattr_next to attr across R103.''succeeds'';
			  break;
			end if;
		  end for;
		end if;
	  else
		// we are at the end of the list
		select one rattr_prev related by rattr->O_ATTR[R103.''succeeds''];
		if ( not_empty rattr_prev )
		  unrelate rattr from rattr_prev across R103.''succeeds'';
		end if;
	  end if;
	  unrelate rattr from o_obj across R102; // have to remove from object to prevent problems deleting the attribute with unordered attributes present

      // select the base attributes previous and next
      select one battr_prev related by battr->O_ATTR[R103.''succeeds''];
      select one battr_next related by battr->O_ATTR[R103.''precedes''];

      // delete any base attribute that has the same name as a referential attribute
      self.Attribute_dispose( o_attr:battr );

      // reintroduce the referential attribute into the order
      relate rattr to o_obj across R102;
      select one battr_prev_next related by battr_prev->O_ATTR[R103.''precedes''];
      if ( not_empty battr_prev_next )
        unrelate battr_prev from battr_prev_next across R103.''precedes'';
      end if;
      select one battr_next_prev related by battr_next->O_ATTR[R103.''succeeds''];
      if ( not_empty battr_next_prev )
        unrelate battr_next from battr_next_prev across R103.''succeeds'';
      end if;
      if ( not_empty battr_prev )
        relate rattr to battr_prev across R103.''succeeds'';
      end if;
      if ( not_empty battr_next )
        relate rattr to battr_next across R103.''precedes'';
      end if;

      break;
    end if;
  end for;
end for;',
	1,
	'',
	"6fa6b354-af9f-4399-a98d-fccf1d354ac1",
	0);
INSERT INTO O_TPARM
	VALUES ("f7b496a8-e1f9-4087-8b2d-d17a5b5d3488",
	"ea1ce3ec-1a63-40a3-9813-07b776b65c1c",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("afc41b81-6817-4fc1-93c2-b97272ef30ba",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'NewBaseAttribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_nbattr = param.o_nbattr;

select one battr related by o_nbattr->O_BATTR[R107];
unrelate o_nbattr from battr across R107;
delete object instance o_nbattr;
',
	1,
	'',
	"ea1ce3ec-1a63-40a3-9813-07b776b65c1c",
	0);
INSERT INTO O_TPARM
	VALUES ("5d91bc20-a02e-42a9-bea2-5e5150a5ebbc",
	"afc41b81-6817-4fc1-93c2-b97272ef30ba",
	'o_nbattr',
	"7e942884-55b0-420b-97d7-19d2928132e8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7e942884-55b0-420b-97d7-19d2928132e8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<New Base Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("3d7ad752-84ff-4ae4-8b6a-40ecac67b232",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'OperationParameter_dispose',
	'Dispose this Operation Parameter.
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// copied from the OOAofOOA - LPS
o_tparm = param.o_tparm;

// Operation Parameter.dispose()
/*
//
// Value Subsystem
select many pvs related by o_tparm->V_PVL[R833];
for each pv in pvs
  unrelate o_tparm from pv across R833;
end for;
*/
//
// Subsystem Subsystem
select one operation related by o_tparm->O_TFR[R117];
unrelate o_tparm from operation across R117;
select one dt related by o_tparm->S_DT[R118];
unrelate o_tparm from dt across R118;
//
select one successor related by o_tparm->O_TPARM[R124.''precedes''];
select one predecessor related by o_tparm->O_TPARM[R124.''succeeds''];
if (not empty successor)
  unrelate o_tparm from successor across R124.''precedes'';
end if;
if (not empty predecessor)
  unrelate o_tparm from predecessor across R124.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R124.''succeeds'';
end if;
/*
// dispose each message argument
// associated with this parm
select many args related by o_tparm->MSG_OA[R1015];
for each arg in args
  arg.dispose();
end for;
//
// Local Subsystem
select many lcls related by o_tparm->L_LCL[R3008];
for each lcl in lcls
  unrelate o_tparm from lcl across R3008;
  lcl.dispose();
end for;
*/
select many dims related by o_tparm->S_DIM[R121];
for each dim in dims
  unrelate o_tparm from dim across R121;
  delete object instance dim;
end for;
//
// Finally delete o_tparm
delete object instance o_tparm;',
	1,
	'',
	"afc41b81-6817-4fc1-93c2-b97272ef30ba",
	0);
INSERT INTO O_TPARM
	VALUES ("420cf5ef-e7f1-4605-ad55-2f5286f321f4",
	"3d7ad752-84ff-4ae4-8b6a-40ecac67b232",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("531a542d-7d11-4927-a106-818118fff6cd",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'OperationParameter_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_tparm = param.o_tparm;

// Note: this is a heavily modified version of the function from OOAofOOA
select one operation related by o_tparm->O_TFR[R117];
self.Operation_addParameterToOrdering(o_tfr:operation, o_tparm:o_tparm);

// TODO - assign a default type to aid in testing.  Do we want to keep this (to // END)?
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
// END

relate o_tparm to def_dt across R118;
o_tparm.Name = param.name;
',
	1,
	'',
	"3d7ad752-84ff-4ae4-8b6a-40ecac67b232",
	0);
INSERT INTO O_TPARM
	VALUES ("d2514b98-1567-4d38-9fd7-56a94c18dd06",
	"531a542d-7d11-4927-a106-818118fff6cd",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("d6500566-1c01-435c-bec6-d3ae33c4895a",
	"531a542d-7d11-4927-a106-818118fff6cd",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d2514b98-1567-4d38-9fd7-56a94c18dd06",
	'');
INSERT INTO O_TFR
	VALUES ("6ffbfe92-9161-48d2-89e7-6705c645fc96",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'OperationParameter_setType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_tparm = param.o_tparm;
type_name = param.type_name;

// NOTE: This isn''t really a copied operation from the OOAofOOA, but we''re following the same paradigm for it
//   as other functions that are from the OOA

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for attribute " + o_tparm.Name);
end if;

// Get a handle to the DT that is currently associated with the attribute
select one cur_s_dt related by o_tparm->S_DT[R118];

// If the new DT does not equal the existing DT, continue
if ( s_dt != cur_s_dt )
  // un-relate the existing DT across R118
  unrelate o_tparm from cur_s_dt across R118;
  
  // relate the new attribute across R118
  relate o_tparm to s_dt across R118;
end if;',
	1,
	'',
	"531a542d-7d11-4927-a106-818118fff6cd",
	0);
INSERT INTO O_TPARM
	VALUES ("7b6f7718-776b-48d1-ae20-6182a4f1ae71",
	"6ffbfe92-9161-48d2-89e7-6705c645fc96",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("0b5acf9c-a149-44a3-a56e-36dd83ce71a5",
	"6ffbfe92-9161-48d2-89e7-6705c645fc96",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"7b6f7718-776b-48d1-ae20-6182a4f1ae71",
	'');
INSERT INTO O_TFR
	VALUES ("fa8525dd-0351-4e44-9af0-df7ce82e2034",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_addParameterToOrdering',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_tfr = param.o_tfr;
parameter = param.o_tparm;

if(not_empty parameter)
  select many peers related by o_tfr->O_TPARM[R117];
  for each peer in peers
    if (peer != parameter)
      select one predecessor related by peer->O_TPARM[R124.''precedes''];
      if (empty predecessor)
        relate parameter to peer across R124.''succeeds'';
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	"6ffbfe92-9161-48d2-89e7-6705c645fc96",
	0);
INSERT INTO O_TPARM
	VALUES ("e690d2f6-5a8c-4dec-aaac-8550308dfb8d",
	"fa8525dd-0351-4e44-9af0-df7ce82e2034",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("df588624-ebeb-4381-b8ce-47a76bae1a77",
	"fa8525dd-0351-4e44-9af0-df7ce82e2034",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"e690d2f6-5a8c-4dec-aaac-8550308dfb8d",
	'');
INSERT INTO O_TFR
	VALUES ("a73f5363-6e30-490d-bf44-d67cc4a7a3ae",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_createParameterInInteractions',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_tparm = param.o_tparm;
o_tfr = param.o_tfr;

// for each message associated with this bridge
// create a message argument
select many messages related by o_tfr->MSG_O[R1011]->MSG_SM[R1020]->MSG_M[R1018];
for each message in messages
  create object instance arg of MSG_A;
  create object instance oa of MSG_OA;
  relate oa to o_tparm across R1015;
  relate oa to arg across R1013;
  relate message to arg across R1001;
end for;
',
	1,
	'',
	"fa8525dd-0351-4e44-9af0-df7ce82e2034",
	0);
INSERT INTO O_TPARM
	VALUES ("9da45c53-f385-445d-a4a8-c009fce7eb15",
	"a73f5363-6e30-490d-bf44-d67cc4a7a3ae",
	'o_tparm',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("e7312ad5-5c42-4582-9ea2-1f737f3bba29",
	"a73f5363-6e30-490d-bf44-d67cc4a7a3ae",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"9da45c53-f385-445d-a4a8-c009fce7eb15",
	'');
INSERT INTO O_TFR
	VALUES ("38451469-eceb-42da-9680-d8f91a5b03c9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_dispose',
	'Dispose this Operation.
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// copied from the OOAofOOA - LPS
o_tfr = param.o_tfr;

// Subsytem Subsystem
select one myClass related by o_tfr->O_OBJ[R115];
unrelate o_tfr from myClass across R115;
//
select one successor related by o_tfr->O_TFR[R125.''precedes''];
select one predecessor related by o_tfr->O_TFR[R125.''succeeds''];
if (not empty successor)
  unrelate o_tfr from successor across R125.''precedes'';
end if;
if (not empty predecessor)
  unrelate o_tfr from predecessor across R125.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R125.''succeeds'';
end if;
//
select one dt related by o_tfr->S_DT[R116];
unrelate o_tfr from dt across R116;
select many oparms related by o_tfr->O_TPARM[R117];
for each oparm in oparms
  self.OperationParameter_dispose( o_tparm:oparm );
end for;
/*
//
// Body Subsystem
select one body related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
if (not_empty body)
  body.dispose();
end if;
//
// Invocation Subsystem
select many invs related by o_tfr->ACT_TFM[R673];
for each inv in invs
  unrelate o_tfr from inv across R673;
end for;
//
// Value Subsystem
select many oprVals related by o_tfr->V_TRV[R829];
for each oprVal in oprVals
  unrelate o_tfr from oprVal across R829;
end for;
// for each message that this operation
// is associated with
select many oms related by o_tfr->MSG_O[R1011];
for each om in oms
  select one message related by om->MSG_SM[R1020];
  message.unformalize();
end for;
*/
select many dims related by o_tfr->S_DIM[R122];
for each dim in dims
  unrelate o_tfr from dim across R122;
  delete object instance dim;
end for;
//
// Finally, delete o_tfr
delete object instance o_tfr;',
	1,
	'',
	"a73f5363-6e30-490d-bf44-d67cc4a7a3ae",
	0);
INSERT INTO O_TPARM
	VALUES ("73d319fe-c022-4cf4-9056-5ebaa7037fcb",
	"38451469-eceb-42da-9680-d8f91a5b03c9",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("54a1516f-ae55-43ae-a346-c23d6c80aafd",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_getSignature',
	'',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'/**
 *  Return a string representation of this functions signature
 *  Heavily adapted from OOAofOOA - LPS
 */
o_tfr = param.o_tfr;

signature = "";

// Get return type
select one returntype related by o_tfr->S_DT[R116];
signature = signature + returntype.Name + " ";
 
// Get name
signature = signature + o_tfr.Name;

// Get parameters
// Get the first parameter.
select any parameter related by o_tfr->O_TPARM[R117];
first_param = parameter;
while ( not_empty parameter )
  first_param = parameter;
  select one parameter related by parameter->O_TPARM[R124.''succeeds''];
end while;

if( not_empty first_param )
  signature = signature + "(";
end if;
separator = "";
parameter = first_param;
while ( not_empty parameter )
  select one type related by parameter->S_DT[R118];
  signature = signature + separator + type.Name;
  separator = " ";
  select one parameter related by parameter->O_TPARM[R124.''precedes''];
end while;
if( not_empty first_param )
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	"38451469-eceb-42da-9680-d8f91a5b03c9",
	0);
INSERT INTO O_TPARM
	VALUES ("db6cfec5-0f1f-4754-96f8-affb515dd6d5",
	"54a1516f-ae55-43ae-a346-c23d6c80aafd",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("2f1a7763-2458-4406-b403-61822430a294",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_tfr = param.o_tfr;

// NOTE: This is a heavily modified version of OOAofOOA''s Operation::initialize()

select one clazz related by o_tfr->O_OBJ[R115];
self.ModelClass_addOperationToOrdering(o_obj: clazz, newTfr:o_tfr);

// Since this operation handles both functions and services, and services have void return types, we default to void here.
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "void" );
relate o_tfr to def_dt across R116;

o_tfr.Name = param.name;
o_tfr.Instance_Based = Scope::Instance;
o_tfr.Suc_Pars = ParseStatus::parseInitial;
',
	1,
	'',
	"54a1516f-ae55-43ae-a346-c23d6c80aafd",
	0);
INSERT INTO O_TPARM
	VALUES ("48c3a313-c328-48f1-b316-8173fb952345",
	"2f1a7763-2458-4406-b403-61822430a294",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("2ebe041c-e245-4ee8-9b4c-a723df49693d",
	"2f1a7763-2458-4406-b403-61822430a294",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"48c3a313-c328-48f1-b316-8173fb952345",
	'');
INSERT INTO O_TFR
	VALUES ("01fea7a3-a0c1-4c37-b328-ec4ef2ec5336",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_newParameter',
	'',
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	1,
	'o_tfr = param.o_tfr;

select any parm related by o_tfr->O_TPARM[R117] where ( selected.Name == param.parameter_name );

if ( empty parm )
  create object instance parm of O_TPARM;
  relate o_tfr to parm across R117;
  self.OperationParameter_initialize(o_tparm:parm, name:param.parameter_name);
  self.Operation_createParameterInInteractions(o_tparm: parm, o_tfr:o_tfr);
end if;

return parm;',
	1,
	'',
	"2f1a7763-2458-4406-b403-61822430a294",
	0);
INSERT INTO O_TPARM
	VALUES ("736e21d9-276a-4cef-83b7-b783e2f3f025",
	"01fea7a3-a0c1-4c37-b328-ec4ef2ec5336",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("619385e4-8395-450d-b789-1c2663761ae8",
	"01fea7a3-a0c1-4c37-b328-ec4ef2ec5336",
	'parameter_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"736e21d9-276a-4cef-83b7-b783e2f3f025",
	'');
INSERT INTO O_TFR
	VALUES ("1d5100c3-b4fc-47e1-b393-353b3e8cec2b",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Operation_setReturnType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_tfr = param.o_tfr;
type_name = param.type_name;

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for operation " + o_tfr.Name);
else

  // unrelated the old return type type
  select one old_s_dt related by o_tfr->S_DT[R116];
  if ( not_empty old_s_dt )
	unrelate old_s_dt from o_tfr across R116;
  end if;
  
  // relate the new return type
  relate s_dt to o_tfr across R116;

end if;',
	1,
	'',
	"01fea7a3-a0c1-4c37-b328-ec4ef2ec5336",
	0);
INSERT INTO O_TPARM
	VALUES ("34f75707-9f6b-44b6-90a9-c1062dee5272",
	"1d5100c3-b4fc-47e1-b393-353b3e8cec2b",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("9fec6a5c-04b1-420d-aa92-4e8b9deeeb00",
	"1d5100c3-b4fc-47e1-b393-353b3e8cec2b",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"34f75707-9f6b-44b6-90a9-c1062dee5272",
	'');
INSERT INTO O_TFR
	VALUES ("96bdff54-4284-4124-a4e5-4a922efdc714",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'param.ep_pkg.Name = param.name;',
	1,
	'',
	"1d5100c3-b4fc-47e1-b393-353b3e8cec2b",
	0);
INSERT INTO O_TPARM
	VALUES ("5da99634-23c2-420d-aba1-0614f7127e59",
	"96bdff54-4284-4124-a4e5-4a922efdc714",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("aedf4005-2ae3-4ef0-a7aa-6848be59aadd",
	"96bdff54-4284-4124-a4e5-4a922efdc714",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5da99634-23c2-420d-aba1-0614f7127e59",
	'');
INSERT INTO O_TFR
	VALUES ("892f7730-6797-4bee-a3c1-5f792347a4db",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newAssociation',
	'',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	1,
	'ep_pkg = param.ep_pkg;
select any fromOOAPart from instances of ooaparticipation where (selected.isFirst == true );
select any toOOAPart from instances of ooaparticipation where (selected.isFirst == false );

// What follows is a heavily modified version of OOAofOOA''s Package::newAssociation()
  
select any fromClass related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == fromOOAPart.className);
/* TODO - not handling association to imported class, don''t think we need to.
select any fromIClass related by ep_pkg->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.from);
if (param.fromIsImported)
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;*/
select any toClass related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == toOOAPart.className);
/* TODO - not handling association to imported class, don''t think we need to.
select any toIClass related by ep_pkg->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.to);
if (param.toIsImported)
  if (not_empty toIClass)
    select one toClass related by toIClass->O_OBJ[R101];
  end if;
end if;*/
//

select any assoc from instances of R_REL where false;
if (not_empty fromClass and not_empty toClass)
  create object instance assoc of R_REL;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate assoc to pe across R8001;
  relate pe to ep_pkg across R8000;
  pe.type = ElementTypeConstants::ASSOCIATION;
  self.PackageableElement_initialize(pe_pe:pe);
  self.Association_initialize(r_rel:assoc);
  create object instance simp of R_SIMP;
  relate simp to assoc across R206;
  //
  create object instance fromOIR of R_OIR;
  relate fromClass to assoc across R201 using fromOIR;
  create object instance fromRTO of R_RTO;
  relate fromOIR to fromRTO across R203;
  create object instance fromPART of R_PART;
  relate fromPART to fromRTO across R204;
  relate fromPART to simp across R207;
  /* TODO - not handling imported class associations
  if (param.fromIsImported)
    if (not_empty fromIClass)
      relate fromOIR to fromIClass across R202;
    end if;
  end if;*/
  fromPART.Mult = toOOAPart.multiplicity;
  fromPART.Cond = toOOAPart.conditionality;
  fromPART.Txt_Phrs = toOOAPart.phrase;
  //
  create object instance toOIR of R_OIR;
  relate toClass to assoc across R201 using toOIR;
  create object instance toRTO of R_RTO;
  relate toOIR to toRTO across R203;
  create object instance toPART of R_PART;
  relate toPART to toRTO across R204;
  relate toPART to simp across R207;
  /* TODO - not handling imported class associations
  if (param.toIsImported)
    if (not_empty toIClass)
      relate toOIR to toIClass across R202;
    end if;
  end if;*/
  // TODO - set phrase, cond, mult
  toPART.Mult = fromOOAPart.multiplicity;
  toPART.Cond = fromOOAPart.conditionality;
  toPART.Txt_Phrs = fromOOAPart.phrase;
end if;

return assoc;',
	1,
	'',
	"96bdff54-4284-4124-a4e5-4a922efdc714",
	0);
INSERT INTO O_TPARM
	VALUES ("9852b0f6-c899-4b45-a72f-e9ef50c6361d",
	"892f7730-6797-4bee-a3c1-5f792347a4db",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("0e1bc23d-634f-4a97-9c5b-103ed1016073",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newAssociative',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'ep_pkg = param.ep_pkg;

// What follows is a heavily modified version of OOAofOOA''s Package::newAssociative()
select any fromClass related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == self.current_rel.usingObj);

/*  TODO - skipping imported classes for now
if (param.fromIsImportedClass)
  select any fromIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.from);
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;*/
relNumber = STRING::atoi(s:self.current_rel.number); 
select any toAssoc related by ep_pkg->PE_PE[R8000]->R_REL[R8001] where (selected.Numb == relNumber);
// get the already related class in relationship instances
select many classes related by toAssoc->R_OIR[R201]->O_OBJ[R201];
for each clazz in classes
  if (clazz == fromClass)
    // A class cannot be it''s own link class
    // TODO - not doing anything with return value, should we?  - return false;
    return;
  end if;
end for;
if (empty fromClass or empty toAssoc)
  // One of the elements was not found
  // TODO - not doing anything with return value, should we?  - return false;
  return;
end if;
select one simp related by toAssoc->R_SIMP[R206];
if (empty simp)
  // Only simple associations can have link classes attached. 
  // TODO - not doing anything with return value, should we?  - return false;
  return;
else
  /* TODO - not handling imported link classes
  if (param.fromIsImportedClass)
    simp.migrateToLinked(using: fromClass.Obj_ID, imported_id: param.from);
  else*/
    select any usingClass related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == self.current_rel.usingObj);
    self.SimpleAssociation_migrateToLinked(r_simp:simp, using: usingClass);
  //end if;
  // TODO - not doing anything with return value, should we?  - return true;
  return;
end if;',
	1,
	'',
	"892f7730-6797-4bee-a3c1-5f792347a4db",
	0);
INSERT INTO O_TPARM
	VALUES ("b6a69d04-4fe2-43b8-9a29-8884c1fc4019",
	"0e1bc23d-634f-4a97-9c5b-103ed1016073",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("87e4177c-b10c-4cd8-9126-6b7741b3d822",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newClass',
	'',
	"63f4ff99-f127-443b-a678-30ace41da702",
	1,
	'ep_pkg = param.ep_pkg;

create object instance cl of O_OBJ;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate cl to pe across R8001;
pe.type = ElementTypeConstants::CLASS;
self.PackageableElement_initialize(pe_pe:pe);

relate ep_pkg to pe across R8000;
self.ModelClass_initialize(o_obj:cl, name:param.class_name);

return cl;',
	1,
	'',
	"0e1bc23d-634f-4a97-9c5b-103ed1016073",
	0);
INSERT INTO O_TPARM
	VALUES ("59d0e0cd-6292-47c4-ad52-35961bf39c0c",
	"87e4177c-b10c-4cd8-9126-6b7741b3d822",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("72f8784d-04eb-4b49-ab2c-73f7d948e805",
	"87e4177c-b10c-4cd8-9126-6b7741b3d822",
	'class_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"59d0e0cd-6292-47c4-ad52-35961bf39c0c",
	'');
INSERT INTO O_TFR
	VALUES ("920bb968-0d03-43d2-859e-0ee444c9e3b4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newComponent',
	'',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	1,
	'ep_pkg = param.ep_pkg;

create object instance component of C_C;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate component to pe across R8001;
relate pe to ep_pkg across R8000;
pe.type = ElementTypeConstants::COMPONENT;
self.PackageableElement_initialize(pe_pe:pe);
self.Component_initialize(c_c:component, name:param.component_name);

return component;',
	1,
	'',
	"87e4177c-b10c-4cd8-9126-6b7741b3d822",
	0);
INSERT INTO O_TPARM
	VALUES ("e1ef445f-799d-455b-a4a7-48366c581217",
	"920bb968-0d03-43d2-859e-0ee444c9e3b4",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("6a177f52-0d8b-4fa1-be37-b525838a80bf",
	"920bb968-0d03-43d2-859e-0ee444c9e3b4",
	'component_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e1ef445f-799d-455b-a4a7-48366c581217",
	'');
INSERT INTO O_TFR
	VALUES ("c6b666c4-3808-4b5c-bd7a-0a0ef1c4f955",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newDatatype',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'ep_pkg = param.ep_pkg;

// Create the new data type
create object instance dt of S_DT;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate dt to pe across R8001;
relate pe to ep_pkg across R8000;

create object instance udt of S_UDT;
relate dt to udt across R17;

self.Datatype_initialize(s_dt:dt, name:param.type_name);
pe.type = ElementTypeConstants::DATATYPE;
self.PackageableElement_initialize(pe_pe:pe);

// Link ID to appropriate xtUML core type.
globaltypes_pkg = self.globaltypes_pkg;
systypes_pkg = self.systypes_pkg;
if ( "character" == param.type_name or
     "wcharacter" == param.type_name or
     "byte" == param.type_name or
     "long_integer" == param.type_name or
     "duration" == param.type_name )
  select any integer_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "integer" );
  relate integer_dt to udt across R18;
elif ( "wstring" == param.type_name or
       "MASLtype" == param.type_name )
  select any string_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
  relate string_dt to udt across R18;
else
  select any masl_dt related by systypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "MASLtype" );
  relate masl_dt to udt across R18;
end if;

// For complex MASL types we store the definition in the description
if ( "" != param.definition )
  udt.Definition = param.definition;
end if;',
	1,
	'',
	"920bb968-0d03-43d2-859e-0ee444c9e3b4",
	0);
INSERT INTO O_TPARM
	VALUES ("ddfec09a-b595-4258-adf5-7ca771d72800",
	"c6b666c4-3808-4b5c-bd7a-0a0ef1c4f955",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("3f8b73d9-4f8b-4ff8-8208-c189e31a9f20",
	"c6b666c4-3808-4b5c-bd7a-0a0ef1c4f955",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ddfec09a-b595-4258-adf5-7ca771d72800",
	'');
INSERT INTO O_TPARM
	VALUES ("d9d1d791-34bf-4d25-a4d4-686ccda0f935",
	"c6b666c4-3808-4b5c-bd7a-0a0ef1c4f955",
	'definition',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3f8b73d9-4f8b-4ff8-8208-c189e31a9f20",
	'');
INSERT INTO O_TFR
	VALUES ("71be15c4-2437-4146-843c-f34984b74371",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newException',
	'',
	"47b02a5f-ecfb-49c6-bf1a-6e4a2ff6de02",
	1,
	'ep_pkg = param.ep_pkg;
name = param.name;

create object instance exp of S_EXP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate exp to pe across R8001;
relate pe to ep_pkg across R8000;
pe.type = ElementTypeConstants::EXCEPTION;
self.PackageableElement_initialize(pe_pe:pe);
exp.Name = name;

return exp;',
	1,
	'',
	"c6b666c4-3808-4b5c-bd7a-0a0ef1c4f955",
	0);
INSERT INTO O_TPARM
	VALUES ("46244022-9865-48b8-bc96-d1d5213a33fe",
	"71be15c4-2437-4146-843c-f34984b74371",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("b61c8313-e72f-4b62-b69c-18dd1ae7bb2b",
	"71be15c4-2437-4146-843c-f34984b74371",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"46244022-9865-48b8-bc96-d1d5213a33fe",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("47b02a5f-ecfb-49c6-bf1a-6e4a2ff6de02",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Exception>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO O_TFR
	VALUES ("c36e2b51-4953-48be-bbe5-c8806cc78c9a",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newFunction',
	'',
	"60690409-5a69-45db-896b-5a63a9103c18",
	1,
	'ep_pkg = param.ep_pkg;

create object instance fn of S_SYNC;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate fn to pe across R8001;
relate pe to ep_pkg across R8000;
pe.type = ElementTypeConstants::FUNCTION;
self.PackageableElement_initialize(pe_pe:pe);

self.Function_initialize(s_sync:fn, name:param.function_name);

return fn;',
	1,
	'',
	"71be15c4-2437-4146-843c-f34984b74371",
	0);
INSERT INTO O_TPARM
	VALUES ("d4cd0b7a-1d17-4973-9cc7-612fee5cd7e0",
	"c36e2b51-4953-48be-bbe5-c8806cc78c9a",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("48d645e8-a667-4226-848e-fda3e90caae2",
	"c36e2b51-4953-48be-bbe5-c8806cc78c9a",
	'function_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d4cd0b7a-1d17-4973-9cc7-612fee5cd7e0",
	'');
INSERT INTO O_TFR
	VALUES ("969557bf-58d3-4ae6-a12b-7e34f8d8db9f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newImportedComponent',
	'',
	"4bf19d7e-1bcd-469a-b056-4523dd59dc1d",
	1,
	'ep_pkg = param.ep_pkg;

create object instance importedComp of CL_IC;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate importedComp to pe across R8001;
relate pe to ep_pkg across R8000;
pe.type = ElementTypeConstants::COMPONENT_REFERENCE;
self.PackageableElement_initialize(pe_pe:pe);

return importedComp;',
	1,
	'',
	"c36e2b51-4953-48be-bbe5-c8806cc78c9a",
	0);
INSERT INTO O_TPARM
	VALUES ("6b89d6b9-4257-489a-988d-43bcfd4cb3c8",
	"969557bf-58d3-4ae6-a12b-7e34f8d8db9f",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("b0aebda7-e4c2-4438-a811-85ebc52d368e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newInterface',
	'',
	"80698720-cc57-44ba-8aa5-600c524db338",
	1,
	'ep_pkg = param.ep_pkg;

create object instance interface of C_I;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate interface to pe across R8001;
relate pe to ep_pkg across R8000;
pe.type = ElementTypeConstants::INTERFACE;
self.PackageableElement_initialize(pe_pe:pe);
interface.Name = param.interface_name;

return interface;',
	1,
	'',
	"969557bf-58d3-4ae6-a12b-7e34f8d8db9f",
	0);
INSERT INTO O_TPARM
	VALUES ("988b454f-2b13-436f-ad6d-333af4b99ea6",
	"b0aebda7-e4c2-4438-a811-85ebc52d368e",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("d06ae8e4-4491-49de-854d-41db0f8b2d20",
	"b0aebda7-e4c2-4438-a811-85ebc52d368e",
	'interface_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"988b454f-2b13-436f-ad6d-333af4b99ea6",
	'');
INSERT INTO O_TFR
	VALUES ("9062fbb9-8de5-4edf-9def-922dca83fea2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newPackage',
	'',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	1,
	'ep_pkg = param.ep_pkg;

// Package::newPackage()
create object instance package of EP_PKG;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate package to pe across R8001;
select one system related by ep_pkg->S_SYS[R1405];
relate package to system across R1405;
relate ep_pkg to pe across R8000;
package.Name = param.package_name;
pe.type = ElementTypeConstants::PACKAGE;
self.PackageableElement_initialize(pe_pe:pe);

return package;',
	1,
	'',
	"b0aebda7-e4c2-4438-a811-85ebc52d368e",
	0);
INSERT INTO O_TPARM
	VALUES ("4d29e75e-02c3-4130-834d-f4fac932b9ec",
	"9062fbb9-8de5-4edf-9def-922dca83fea2",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("c95db0ba-1de7-49f5-af91-fbfa5cd15108",
	"9062fbb9-8de5-4edf-9def-922dca83fea2",
	'package_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4d29e75e-02c3-4130-834d-f4fac932b9ec",
	'');
INSERT INTO O_TFR
	VALUES ("62f2d512-b9dd-4fa2-8910-8e9489fd62f0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Package_newSubsuper',
	'',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	1,
	'ep_pkg = param.ep_pkg;
select any fromOOAPart from instances of ooaparticipation where (selected.isFirst == true );
select many toOOAParts from instances of ooaparticipation where (selected.isFirst == false );

// What follows is a heavily modified version of OOAofOOA''s Package::newAssociation()
// TODO - LPS handle imported classes?
  
select any assoc from instances of R_REL where false;
select any fromClass related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == fromOOAPart.className);
if ( not_empty fromClass )
  create object instance assoc of R_REL;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate assoc to pe across R8001;
  relate pe to ep_pkg across R8000;
  pe.type = ElementTypeConstants::ASSOCIATION;
  self.PackageableElement_initialize(pe_pe:pe);
  self.Association_initialize(r_rel:assoc);
  create object instance subsuper of R_SUBSUP;
  relate subsuper to assoc across R206;
  //
  create object instance fromOIR of R_OIR;
  relate fromClass to assoc across R201 using fromOIR;
  create object instance fromRTO of R_RTO;
  relate fromOIR to fromRTO across R203;
  create object instance fromSUPER of R_SUPER;
  relate fromSUPER to fromRTO across R204;
  relate fromSUPER to subsuper across R212;
  //

  for each toOOAPart in toOOAParts
	select any toClass related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == toOOAPart.className);
	//
	if ( not_empty toClass )
	  create object instance toOIR of R_OIR;
	  relate toClass to assoc across R201 using toOIR;
	  create object instance toRGO of R_RGO;
	  relate toOIR to toRGO across R203;
	  create object instance toSUB of R_SUB;
	  relate toSUB to toRGO across R205;
	  relate toSUB to subsuper across R213;
	end if;

  end for;

end if;

return assoc;
',
	1,
	'',
	"9062fbb9-8de5-4edf-9def-922dca83fea2",
	0);
INSERT INTO O_TPARM
	VALUES ("36e49e22-1864-4670-bf5a-afb7f2d8a1b1",
	"62f2d512-b9dd-4fa2-8910-8e9489fd62f0",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("6028618e-33b7-4998-953c-53141aff5d5e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'PackageableElement_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Copied from OOAofOOA - LPS
// Only kept bits for deleting things we need to deleting possible same named activities

// Packageable Element.dispose()
pe_pe = param.pe_pe;
 
select many ele_vis_links related by pe_pe->PE_VIS[R8002];
for each ele_vis_link in ele_vis_links
  select one pkg related by ele_vis_link->EP_PKG[R8002];
  unrelate pe_pe from pkg across R8002 using ele_vis_link;
  select one searchResultset related by ele_vis_link->PE_SRS[R8006];
  unrelate ele_vis_link from searchResultset across R8006;  
  delete object instance ele_vis_link;
end for;
select many com_vis_links related by pe_pe->PE_CVS[R8004];
for each com_vis_link in com_vis_links
  select one component related by com_vis_link->C_C[R8004];
  unrelate pe_pe from component across R8004 using com_vis_link;
  delete object instance com_vis_link;
end for;
/*
select one modelClass related by pe_pe->O_OBJ[R8001];
if not_empty modelClass
  unrelate modelClass from pe_pe across R8001;
  modelClass.dispose();
end if;
select one dt related by pe_pe->S_DT[R8001];
if not_empty dt
  // note we do not tear down this association
  // as the S_DT.dispose() call requires it to
  // be setup, it will tear it down
  dt.dispose();
end if;
select one intPart related by pe_pe->SQ_P[R8001];
if not_empty intPart
  unrelate intPart from pe_pe across R8001;
  intPart.dispose();
end if;
select one ucAssoc related by pe_pe->UC_UCA[R8001];
if not_empty ucAssoc
  unrelate ucAssoc from pe_pe across R8001;
  ucAssoc.dispose();
end if;
select one actNode related by pe_pe->A_N[R8001];
if not_empty actNode
  unrelate actNode from pe_pe across R8001;
  actNode.dispose();
end if;
select one comp related by pe_pe->C_C[R8001];
if not_empty comp
  unrelate comp from pe_pe across R8001;
  comp.dispose();
end if;
select one ic related by pe_pe->CL_IC[R8001];
if not_empty ic
  unrelate ic from pe_pe across R8001;
  ic.dispose();
end if;
select one interface related by pe_pe->C_I[R8001];
if not_empty interface
  unrelate interface from pe_pe across R8001;
  interface.dispose();
end if;
select one pkg related by pe_pe->EP_PKG[R8001];
if not_empty pkg
  unrelate pkg from pe_pe across R8001;
  pkg.dispose();
end if;
select one csp related by pe_pe->CNST_CSP[R8001];
if not_empty csp
  unrelate csp from pe_pe across R8001;
  csp.dispose();
end if;
select one ap related by pe_pe->A_AP[R8001];
if not_empty ap
  unrelate ap from pe_pe across R8001;
  ap.dispose();
end if;
select one edge related by pe_pe->A_E[R8001];
if not_empty edge
  unrelate edge from pe_pe across R8001;
  edge.dispose();
end if;
select one msg related by pe_pe->MSG_M[R8001];
if not_empty msg
  unrelate msg from pe_pe across R8001;
  msg.dispose();
end if;
select one rel related by pe_pe->R_REL[R8001];
if not_empty rel
  unrelate rel from pe_pe across R8001;
  rel.dispose();
end if;
select one icomp related by pe_pe->O_IOBJ[R8001];
if not_empty icomp
  unrelate icomp from pe_pe across R8001;
  icomp.dispose();
end if;
*/
select one sync related by pe_pe->S_SYNC[R8001];
if not_empty sync
  unrelate sync from pe_pe across R8001;
  self.Function_dispose( s_sync:sync );
end if;
/*
select one ee related by pe_pe->S_EE[R8001];
if not_empty ee
  unrelate ee from pe_pe across R8001;
  ee.dispose();
end if;
select one sat related by pe_pe->C_SF[R8001];
if not_empty sat
  unrelate sat from pe_pe across R8001;
  sat.dispose();
end if;
select one delg related by pe_pe->C_DG[R8001];
if not_empty delg
  unrelate delg from pe_pe across R8001;
  delg.dispose();
end if;
*/
select many bodyInElements related by pe_pe->ACT_BIE[R640];
for each bie in bodyInElements
  select one body related by bie->ACT_ACT[R640];
  unrelate pe_pe from body across R640 using bie;
  delete object instance bie;
end for;

select one package related by pe_pe->EP_PKG[R8000];
if not_empty package
  unrelate pe_pe from package across R8000 ;
end if;

select one component related by pe_pe->C_C[R8003];
if(not_empty component)
  unrelate pe_pe from component across R8003;
end if;

select many elemInSystems related by pe_pe->G_EIS[R9100];
for each elemInSystem in elemInSystems
  select one system related by elemInSystem->S_SYS[R9100];
  unrelate pe_pe from system across R9100 using elemInSystem;
  delete object instance elemInSystem;
end for;

delete object instance pe_pe;',
	1,
	'',
	"62f2d512-b9dd-4fa2-8910-8e9489fd62f0",
	0);
INSERT INTO O_TPARM
	VALUES ("fbac0aa4-f9e2-4284-87b5-62e939e636fa",
	"6028618e-33b7-4998-953c-53141aff5d5e",
	'pe_pe',
	"e988e223-9ca4-4b6f-a675-001eefe3aa24",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e988e223-9ca4-4b6f-a675-001eefe3aa24",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Packageable Element>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Packageable Element/Packageable Element.xtuml');
INSERT INTO O_TFR
	VALUES ("451f3aa2-7a66-433f-ba52-689d7edd71e8",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'PackageableElement_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// TODO - The parameter to this function needs to be changed from integer to inst_ref<PackageableElement>
pe_pe = param.pe_pe;
pe_pe.Visibility = Visibility::Public;',
	1,
	'',
	"6028618e-33b7-4998-953c-53141aff5d5e",
	0);
INSERT INTO O_TPARM
	VALUES ("f1f110bb-8952-4e51-b8ec-b6ac6afd94f1",
	"451f3aa2-7a66-433f-ba52-689d7edd71e8",
	'pe_pe',
	"e988e223-9ca4-4b6f-a675-001eefe3aa24",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("bad9c98f-71ad-46cb-99ba-f53369992345",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Port_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_po = param.c_po;

c_po.DoNotShowPortOnCanvas = false;
c_po.Name = param.name;',
	1,
	'',
	"132437da-61c8-4fe6-a112-744ee0bd386b",
	0);
INSERT INTO O_TPARM
	VALUES ("0619e083-ec6b-42eb-a9b9-b9aeec8ff958",
	"bad9c98f-71ad-46cb-99ba-f53369992345",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO O_TPARM
	VALUES ("02138e82-c833-48c9-805f-4443b23cab90",
	"bad9c98f-71ad-46cb-99ba-f53369992345",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0619e083-ec6b-42eb-a9b9-b9aeec8ff958",
	'');
INSERT INTO O_TFR
	VALUES ("ba2cc878-1f2c-4eaf-9cb1-06d1dfc8a80e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'PropertyParameter_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// copied from the OOAofOOA - LPS
c_pp = param.c_pp;

select one dt related by c_pp->S_DT[R4007];
unrelate c_pp from dt across R4007;
select one ep related by c_pp->C_EP[R4006];
if(not_empty ep)
  unrelate c_pp from ep across R4006;
end if;
select one successor related by c_pp->C_PP[R4021.''precedes''];
select one predecessor related by c_pp->C_PP[R4021.''succeeds''];
if (not empty successor)
  unrelate c_pp from successor across R4021.''precedes'';
end if;
if (not empty predecessor)
  unrelate c_pp from predecessor across R4021.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R4021.''succeeds'';
end if;
/*
select many parmVals related by c_pp->V_PVL[R843];
for each pvl in parmVals
  unrelate c_pp from pvl across R843;
end for;
select many evtParmRefs related by c_pp->V_EPR[R847];
for each evtParmRef in evtParmRefs
  evtParmRef.dispose();
end for;
*/
select many dims related by c_pp->S_DIM[R4017];
for each dim in dims
  unrelate c_pp from dim across R4017;
  delete object instance dim;
end for;
/*
select many evtDis related by c_pp->I_DIV[R2956];
for each evtDi in evtDis
  evtDi.dispose();
end for;
select many local_vals related by c_pp->L_LVL[R3017];
for each local_val in local_vals
  unrelate local_val from c_pp across R3017;
  local_val.dispose();
end for;
select many participationArgs related by c_pp->MSG_EPA[R1023];
for each pa in participationArgs
  unrelate c_pp from pa across R1023;
  pa.dispose();
end for;
*/
delete object instance c_pp;',
	1,
	'',
	"bad9c98f-71ad-46cb-99ba-f53369992345",
	0);
INSERT INTO O_TPARM
	VALUES ("c1e86c06-89a3-4e4d-bc48-0776b93000fb",
	"ba2cc878-1f2c-4eaf-9cb1-06d1dfc8a80e",
	'c_pp',
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("b41bee99-f3be-445d-aad9-310d036d86ec",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferentialAttribute_collapse_ref',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_attr = param.o_attr;
battr = param.battr;

select one o_rattr related by o_attr->O_RATTR[R106];
select one o_battr related by battr->O_BATTR[R106];
select one rattr_base related by o_rattr->O_BATTR[R113];
if ( not_empty o_rattr and not_empty o_battr and not_empty rattr_base and rattr_base.Attr_ID == o_battr.Attr_ID )

  // cache old dt
  select one s_dt related by battr->S_DT[R114];
  
  // migrate the base attribute to referential
  self.Attribute_migrateBaseToReferential(o_attr:battr);
  
  // combine the referentials
  attr = self.ReferentialAttribute_combine_refs( o_attr:battr, other_attr:o_attr );
  select one old_s_dt related by attr->S_DT[R114];
  if ( not_empty old_s_dt )
	unrelate old_s_dt from attr across R114;
  end if;
  if ( not_empty s_dt )
	relate s_dt to attr across R114;
  end if;
end if;',
	1,
	'',
	"ba2cc878-1f2c-4eaf-9cb1-06d1dfc8a80e",
	0);
INSERT INTO O_TPARM
	VALUES ("74b5313a-367f-4373-90b5-075d7346d925",
	"b41bee99-f3be-445d-aad9-310d036d86ec",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("23dec44a-d0a8-4a6a-a0f8-f5bb6bb03c5d",
	"b41bee99-f3be-445d-aad9-310d036d86ec",
	'battr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"74b5313a-367f-4373-90b5-075d7346d925",
	'');
INSERT INTO O_TFR
	VALUES ("628f594b-0e0c-4a22-911d-5c0fd4bbecc0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferentialAttribute_combine_refs',
	'',
	"579b8247-e153-481d-8926-384cdc722464",
	1,
	'o_attr = param.o_attr;
other_attr = param.other_attr;

select one o_rattr related by o_attr->O_RATTR[R106];
select one other_rattr related by other_attr->O_RATTR[R106];
select many other_ref_set related by other_rattr->O_REF[R108];

   // find last O_REF in o_rattr ref list R112
   select any ref related by o_rattr->O_REF[R108];
   select one next_ref related by ref->O_REF[R112.''precedes''];
   while (not_empty next_ref)
     select one next_ref related by ref->O_REF[R112.''precedes''];
     if (not_empty next_ref)
       ref = next_ref;
     end if;
   end while;
   
   for each other_ref in other_ref_set
     unrelate other_ref from other_rattr across R108;
     relate other_ref to o_rattr across R108;  
     // add other_ref to o_rattr ref list R112
     if ( not_empty ref )
       relate other_ref to ref across R112.''succeeds'';
     end if;
     ref = other_ref;    
   end for;

   // Just like the refs, we need to bring over the IDs from the attribute
   // that is about to be disposed.
   select many other_o_oidas related by other_attr->O_OIDA[R105] where ( selected.Oid_ID > 0 );
   for each other_o_oida in other_o_oidas
     self.Attribute_addToIdentifier( o_attr:o_attr, oid:other_o_oida.Oid_ID );
   end for;

   self.Attribute_dispose( o_attr:other_attr );
return o_attr;',
	1,
	'',
	"b41bee99-f3be-445d-aad9-310d036d86ec",
	0);
INSERT INTO O_TPARM
	VALUES ("36b82853-6f2e-45dd-8de4-445fa038b7e0",
	"628f594b-0e0c-4a22-911d-5c0fd4bbecc0",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("a5cd653a-bbd4-4088-8e69-a8af77435fbd",
	"628f594b-0e0c-4a22-911d-5c0fd4bbecc0",
	'other_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"36b82853-6f2e-45dd-8de4-445fa038b7e0",
	'');
INSERT INTO O_TFR
	VALUES ("e30b9eb0-a23c-42cb-9991-8a57501575fc",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferentialAttribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_rattr = param.o_rattr;

select one battr related by o_rattr->O_BATTR[R113];
if (not_empty battr)
  unrelate o_rattr from battr across R113;
end if;
select many refs related by o_rattr->O_REF[R108];
for each ref in refs
  unrelate o_rattr from ref across R108;
  self.AttributeReferenceInClass_dispose(o_ref:ref);
end for;
select one attr related by o_rattr->O_ATTR[R106];
if ( not_empty attr )
  unrelate o_rattr from attr across R106;
end if;
delete object instance o_rattr;',
	1,
	'',
	"628f594b-0e0c-4a22-911d-5c0fd4bbecc0",
	0);
INSERT INTO O_TPARM
	VALUES ("10f99a67-c5fa-49c8-963e-910b27d2b664",
	"e30b9eb0-a23c-42cb-9991-8a57501575fc",
	'o_rattr',
	"9bb4b389-b488-46e0-aeca-fc90df7b856a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("36051a9f-43b3-454b-ad34-40dd639d83d7",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferentialAttribute_migrateToBase',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_rattr = param.o_rattr;

select one attr related by o_rattr->O_ATTR[R106];
unrelate o_rattr from attr across R106;
// Make the new base attribute have the same
// data type as the original
select one battr related by o_rattr->O_BATTR[R113];
if (not_empty battr)
  unrelate o_rattr from battr across R113;
  // Migrate the data type of o_rattr to the type of the old referred to attribute
  select one battrType related by battr->O_ATTR[R106]->S_DT[R114];
  select one attrType related by attr->S_DT[R114];
  unrelate attr from attrType across R114;
  relate attr to battrType across R114;
end if;
create object instance battr of O_BATTR;
relate attr to battr across R106;
create object instance nbattr of O_NBATTR;
relate nbattr to battr across R107;
// Now change the base attribute of all referring
// referentials to this new base.
select many rtoRefs related by attr->O_OIDA[R105]->
                             O_RTIDA[R110]->O_REF[R111]->O_RATTR[R108];
for each ref in rtoRefs
  select one oldBattr related by ref->O_BATTR[R113];
  if ( not_empty oldBattr )
    unrelate ref from oldBattr across R113;
  end if;
  if ( not_empty battr )
    relate ref to battr across R113;
  end if;
end for;
self.ReferentialAttribute_dispose(o_rattr:o_rattr);
',
	1,
	'',
	"e30b9eb0-a23c-42cb-9991-8a57501575fc",
	0);
INSERT INTO O_TPARM
	VALUES ("f500de18-3755-4ced-8612-27a738f22f2a",
	"36051a9f-43b3-454b-ad34-40dd639d83d7",
	'o_rattr',
	"9bb4b389-b488-46e0-aeca-fc90df7b856a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("6e5ef9a9-1aff-495d-9f9a-28fd8a2aae66",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferentialAttribute_setDatatype',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_rattr = param.o_rattr;

// assure that the datatype is the correct one for
// referential attributes
select one attr related by o_rattr->O_ATTR[R106];
select one dt related by attr->S_DT[R114];
if ( not_empty dt )
  if ( dt.Name == "same_as<Base_Attribute>" )
    return;
  else
    unrelate attr from dt across R114;
  end if;
end if;


select one pkg related by attr->O_OBJ[R102]->PE_PE[R8001]->EP_PKG[R8000];


  select one system related by pkg->S_SYS[R1405];
  //dt_id = GD::NULL_UNIQUE_ID();
  //if not_empty system
  // dt_id = system.getCoreTypeId(name:"same_as<Base_Attribute>");
  //end if;
  //select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  //select one ref_attr_dt related by pe->S_DT[R8001]; 
  ref_attr_dt = self.SystemModel_getCoreTypeId(s_sys:system, name:"same_as<Base_Attribute>");
  if (empty ref_attr_dt)
    TRACE::log(flavor:"failure", id:42, message:
                  "Unable to locate expected data type: same_as<Base_Attribute>");
  else
    relate attr to ref_attr_dt across R114;
  end if;

',
	1,
	'',
	"36051a9f-43b3-454b-ad34-40dd639d83d7",
	0);
INSERT INTO O_TPARM
	VALUES ("04281823-d478-4cb7-ae2b-d17deb91504e",
	"6e5ef9a9-1aff-495d-9f9a-28fd8a2aae66",
	'o_rattr',
	"9bb4b389-b488-46e0-aeca-fc90df7b856a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("28a73dfd-3726-40c3-b197-98c3cd171d95",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferredToClassInAssoc_addAttributeToIdentifier',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_rto = param.r_rto;
oida = param.oida;

if ( not_empty oida )
  select many rgo_set related by r_rto->R_OIR[R203]->R_REL[R201]->R_OIR[R201]->R_RGO[R203]
    where ( selected.OIR_ID != r_rto.OIR_ID and selected.Rel_ID == r_rto.Rel_ID );
  for each rgo in rgo_set
    select any ref_attr_id related by rgo->O_REF[R111]->O_RATTR[R108]->O_ATTR[R106]->O_OIDA[R105];
    id_id = -1;
    if ( not_empty ref_attr_id )
      select one assoc related by rgo->R_OIR[R203]->R_REL[R201]->R_ASSOC[R206];
      select one subsup related by rgo->R_OIR[R203]->R_REL[R201]->R_SUBSUP[R206];
      if not_empty assoc or not_empty subsup
        // these associations require the referentials be part of the
        // identifier.
         id_id = ref_attr_id.Oid_ID;
      end if;
    end if;
    select one r_rel related by rgo->R_OIR[R203]->R_REL[R201];
    select one part_obj related by r_rto->R_OIR[R203]->O_OBJ[R201];
    select one form_obj related by rgo->R_OIR[R203]->O_OBJ[R201];
    new_o_rattr = self.ClassIdentifierAttribute_addReference(o_oida:oida, rel:r_rel,
      part_rto:r_rto, part_obj:part_obj,
      form_rgo:rgo, form_obj:form_obj,
      id: id_id);
    if ( id_id != -1 )
      // we''ve updated the id for the rgo
      // check if we need to update any referentials referring
      // to the rgo''s identifier
      select many rto_set related by ref_attr_id->O_ID[R105]->R_RTO[R109];
      for each rto in rto_set
        select any oida related by rto->O_ID[R109]->O_OIDA[R105] where selected.Attr_ID == new_o_rattr.Attr_ID;
        self.ReferredToClassInAssoc_addAttributeToIdentifier(r_rto:rto, oida:oida);
      end for;
    end if;
  end for;
end if;',
	1,
	'',
	"6e5ef9a9-1aff-495d-9f9a-28fd8a2aae66",
	0);
INSERT INTO O_TPARM
	VALUES ("3635ff4d-1c5a-41fc-8444-71b869c746ab",
	"28a73dfd-3726-40c3-b197-98c3cd171d95",
	'oida',
	"08de18fb-cb5f-4d53-9826-375c4dad56f7",
	0,
	'',
	"70a3e859-a5f8-4562-9bcb-db259e7f4462",
	'');
INSERT INTO O_TPARM
	VALUES ("70a3e859-a5f8-4562-9bcb-db259e7f4462",
	"28a73dfd-3726-40c3-b197-98c3cd171d95",
	'r_rto',
	"893ea6d3-466d-498e-b58a-cf5966da5549",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("e07d80b4-1eea-4b5c-8153-ba94fcb3d6ab",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferredToClassInAssoc_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_rto = param.r_rto;

// Association Subsystem
select one zuper related by r_rto->R_SUPER[R204];
select one one related by r_rto->R_AONE[R204];
select one other related by r_rto->R_AOTH[R204];
select one part related by r_rto->R_PART[R204];
if (not_empty zuper)
  self.ClassAsSupertype_dispose(r_super:zuper);
elif (not_empty one)
  self.ClassAsAssociatedOneSide_dispose(r_aone:one);
elif (not_empty other)
  self.ClassAsAssociatedOtherSide_dispose(r_aoth:other);
elif (not_empty part)
  self.ClassAsSimpleParticipant_dispose(r_part:part);
end if;
select one cia related by r_rto->R_OIR[R203];
if ( not_empty cia )
  unrelate r_rto from cia across R203;
end if;
//
// Subsystem Subsystem
select one oid related by r_rto->O_ID[R109];
if (not_empty oid)
  unrelate r_rto from oid across R109;
end if;
select many rtidas related by r_rto->O_RTIDA[R110];
for each rtida in rtidas
  self.ReferredToIdentifierAttribute_dispose(o_rtida:rtida);
end for;
//
// Finally delete r_rto
delete object instance r_rto;
',
	1,
	'',
	"28a73dfd-3726-40c3-b197-98c3cd171d95",
	0);
INSERT INTO O_TPARM
	VALUES ("e1d10619-899b-45f0-86b0-293a7c8c6868",
	"e07d80b4-1eea-4b5c-8153-ba94fcb3d6ab",
	'r_rto',
	"893ea6d3-466d-498e-b58a-cf5966da5549",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("f70b3292-bde0-4144-bbe0-1a4de2aeb42f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferredToClassInAssoc_unformalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_rto = param.r_rto;

select many rtida_set related by r_rto->O_RTIDA[R110];
for each rtida in rtida_set
  select many ref_set related by rtida->O_REF[R111];
  for each ref in ref_set
    self.AttributeReferenceInClass_migrateRefAttrOrDispose(o_ref:ref);  
  end for;
  select one oida related by rtida->O_OIDA[R110];
  unrelate oida from r_rto across R110 using rtida;
  delete object instance rtida;
end for;

select one oid related by r_rto->O_ID[R109];
unrelate oid from r_rto across R109;
',
	1,
	'',
	"e07d80b4-1eea-4b5c-8153-ba94fcb3d6ab",
	0);
INSERT INTO O_TPARM
	VALUES ("67847598-6fe2-4c04-9b9a-90f4ec786ccd",
	"f70b3292-bde0-4144-bbe0-1a4de2aeb42f",
	'r_rto',
	"893ea6d3-466d-498e-b58a-cf5966da5549",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("909f9c6b-d24b-4f31-94ef-e29becbf0600",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferredToIdentifierAttribute_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'o_rtida = param.o_rtida;

select many refs related by o_rtida->O_REF[R111];
for each ref in refs
  self.AttributeReferenceInClass_migrateRefAttrOrDispose(o_ref:ref);
end for;
select one oida related by o_rtida->O_OIDA[R110];
select one rto related by o_rtida->R_RTO[R110];
unrelate oida from rto across R110 using o_rtida;
delete object instance o_rtida;',
	1,
	'',
	"f70b3292-bde0-4144-bbe0-1a4de2aeb42f",
	0);
INSERT INTO O_TPARM
	VALUES ("1e1c11e5-0e29-4157-9c72-933353e7b43d",
	"909f9c6b-d24b-4f31-94ef-e29becbf0600",
	'o_rtida',
	"f026ef24-b484-4ab0-8a8b-5f0709c3d576",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f026ef24-b484-4ab0-8a8b-5f0709c3d576",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Referred To Identifier Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO O_TFR
	VALUES ("13108b58-f32c-4b16-a97f-567cc758c5ee",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferringClassInAssoc_clearReferences',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_rgo = param.r_rgo;

select many refs related by r_rgo->O_REF[R111];
for each ref in refs
  self.AttributeReferenceInClass_migrateRefAttrOrDispose(o_ref:ref);
end for;
',
	1,
	'',
	"909f9c6b-d24b-4f31-94ef-e29becbf0600",
	0);
INSERT INTO O_TPARM
	VALUES ("efd63da7-80f8-4d27-8238-061b325901fd",
	"13108b58-f32c-4b16-a97f-567cc758c5ee",
	'r_rgo',
	"f6b00fbb-5d4e-4e79-bd36-f3289da7ee17",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("8d8114a4-cac1-42ca-bfb5-010e515bbc5c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'ReferringClassInAssoc_dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_rgo = param.r_rgo;

// Association Subsystem
select one link related by r_rgo->R_ASSR[R205];
select one sub related by r_rgo->R_SUB[R205];
select one form related by r_rgo->R_FORM[R205];
if (not_empty link)
 self.ClassAsLink_dispose(r_assr:link);
elif (not_empty sub)
  // TODO - complete this work later - sub.dispose();
elif (not_empty form)
  self.ClassAsSimpleFormalizer_dispose(r_form:form);
end if;
select one cia related by r_rgo->R_OIR[R203];
if ( not_empty cia )
  unrelate r_rgo from cia across R203;
end if;
//
// Subsystem Subsystem
self.ReferringClassInAssoc_clearReferences(r_rgo:r_rgo);
//
// Finally delete self
delete object instance self;',
	1,
	'',
	"13108b58-f32c-4b16-a97f-567cc758c5ee",
	0);
INSERT INTO O_TPARM
	VALUES ("186f3309-e759-4713-be02-3224130e967c",
	"8d8114a4-cac1-42ca-bfb5-010e515bbc5c",
	'r_rgo',
	"f6b00fbb-5d4e-4e79-bd36-f3289da7ee17",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("017203cc-b51e-4efa-b6c6-7acc8a12c42b",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SEMEvent_createDefaultMatrixEntries',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sevt = param.sm_sevt;

/*
Creates a can''t-happen matrix entry for this event for each state in this event''s 
state machine.
*/

// for each state in this event''s state machine
select many states related by sm_sevt->SM_EVT[R525]->SM_SM[R502]->SM_STATE[R501];
for each state in states
    select any entry related by sm_sevt->SM_SEME[R503] where (selected.SMstt_ID == state.SMstt_ID);
    if ( empty entry )
	  // create an event-matrix-entry to relate this state to this event
	  create object instance entry of SM_SEME;
	  relate state to sm_sevt across R503 using entry;
	  
	  // create a can''t-happen entry to classify the event-matrix
	  // entry created above
	  create object instance cantHappen of SM_CH;
	  relate cantHappen to entry across R504;
    end if;
end for;',
	1,
	'',
	"8d8114a4-cac1-42ca-bfb5-010e515bbc5c",
	0);
INSERT INTO O_TPARM
	VALUES ("d2753d33-8001-40bf-b41b-f7ebab6bda69",
	"017203cc-b51e-4efa-b6c6-7acc8a12c42b",
	'sm_sevt',
	"e62eb4e0-7b0c-4f70-877e-0192af434e3a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e62eb4e0-7b0c-4f70-877e-0192af434e3a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<SEM Event>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TFR
	VALUES ("2459e6f3-25a3-44f0-96e6-283d25258fb4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SimpleAssociation_formalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_simp = param.r_simp;
part = param.r_part;

// OOA functionality
if ( self.SimpleAssociation_isFormalized(r_simp:r_simp) )
  self.SimpleAssociation_unformalize(r_simp:r_simp);
end if;

// migrate participant to Class As Simple Formalizer
// select using OIR_ID so that we get a different instance in the reflexive case
select any form_part related by r_simp->R_PART[R207]
  where selected.OIR_ID != part.OIR_ID;
if ( part.Obj_ID == form_part.Obj_ID )
  // reflexive - 
  // Above, we simplistically chose the other participant to be the formalizer.
  // However, in the reflexive case, the participant will have a Txt_Phrs
  // that matches the role phrase in the referential attribute(s).
  if ( param.rolephrase == form_part.Txt_Phrs )
    // swap
    temp = part;
    part = form_part;
    form_part = temp;
  end if;
end if;
self.ClassAsSimpleParticipant_migrateToFormalizer(r_part:form_part);
select one form related by r_simp->R_FORM[R208];

select one part_rto related by part->R_RTO[R204];
select one part_obj related by part_rto->R_OIR[R203]->O_OBJ[R201];
select any oid related by part_obj->O_ID[R104] where selected.Oid_ID == param.id_id; 
relate oid to part_rto across R109;

select many oida_set related by oid->O_OIDA[R105];

select one form_rgo related by form->R_RGO[R205];
select one form_obj related by form_rgo->R_OIR[R203]->O_OBJ[R201];
select one r_rel related by form_rgo->R_OIR[R203]->R_REL[R201];
for each oida in oida_set
  new_o_rattr = self.ClassIdentifierAttribute_addReference(o_oida:oida, rel:r_rel,
    part_rto:part_rto, part_obj:part_obj,
    form_rgo:form_rgo, form_obj:form_obj,
    id: -1);
end for;
',
	1,
	'',
	"7d6ac7ae-dc34-4e4c-aa7e-d9c072d06138",
	0);
INSERT INTO O_TPARM
	VALUES ("ab4be28b-c869-4f3a-9f46-4b25940ebf6e",
	"2459e6f3-25a3-44f0-96e6-283d25258fb4",
	'r_simp',
	"322c65da-132b-421a-a1b1-f757cb0acff7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("322c65da-132b-421a-a1b1-f757cb0acff7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Simple Association>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TPARM
	VALUES ("b557eb0c-7b21-464a-bea8-3fadf2ca17ec",
	"2459e6f3-25a3-44f0-96e6-283d25258fb4",
	'r_part',
	"11f40760-1dd1-4b08-9393-18b2e8520e6c",
	0,
	'',
	"ab4be28b-c869-4f3a-9f46-4b25940ebf6e",
	'');
INSERT INTO O_TPARM
	VALUES ("11da617f-ca0b-449d-9c83-e6f24a53bc28",
	"2459e6f3-25a3-44f0-96e6-283d25258fb4",
	'id_id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"b557eb0c-7b21-464a-bea8-3fadf2ca17ec",
	'');
INSERT INTO O_TPARM
	VALUES ("5bb3dab1-bc9b-4ebe-b43e-e4ea90a00d66",
	"2459e6f3-25a3-44f0-96e6-283d25258fb4",
	'rolephrase',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"11da617f-ca0b-449d-9c83-e6f24a53bc28",
	'');
INSERT INTO O_TFR
	VALUES ("637f67a3-d4bc-437a-b10a-3be1a34ef6a6",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SimpleAssociation_isFormalized',
	'',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'r_simp = param.r_simp;

select one form related by r_simp->R_FORM[R208];
if ( not_empty form )
  select any rto related by r_simp->R_PART[R207]->R_RTO[R204];
  select any rtida related by rto->O_RTIDA[R110];
  if ( empty rtida )
    select one assoc related by r_simp->R_REL[R206];
  end if;
  return true;
end if;
return false;
',
	1,
	'',
	"2459e6f3-25a3-44f0-96e6-283d25258fb4",
	0);
INSERT INTO O_TPARM
	VALUES ("8f1a0785-a074-4978-9407-3bd0243382c9",
	"637f67a3-d4bc-437a-b10a-3be1a34ef6a6",
	'r_simp',
	"322c65da-132b-421a-a1b1-f757cb0acff7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("80312e5a-b61d-48ac-ab71-ce72803ac7a9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SimpleAssociation_migrateToLinked',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_simp = param.r_simp;

// create the class as link
create object instance assr of R_ASSR;

// Unformalize r_simp if it is formalized
if (self.SimpleAssociation_isFormalized(r_simp:r_simp))
  self.SimpleAssociation_unformalize(r_simp:r_simp);
end if;
select one toAssoc related by r_simp->R_REL[R206];
fromClass = param.using;
// migrate the simple association to a linked association
create object instance assoc of R_ASSOC;
unrelate r_simp from toAssoc across R206;
relate assoc to toAssoc across R206;
//
select many parts related by r_simp->R_PART[R207];
if (cardinality parts == 1)
  // this association is formalized 
  // migrate from participant to oneside
  select any part related by r_simp->R_PART[R207];
  select one rto related by part->R_RTO[R204];
  unrelate part from rto across R204;
  unrelate r_simp from part across R207;
  create object instance aone of R_AONE;
  aone.Mult = part.Mult;
  aone.Cond = part.Cond;
  aone.Txt_Phrs = part.Txt_Phrs;
  relate rto to aone across R204;
  delete object instance part;
  // link the one side to the new linked association
  relate aone to assoc across R209;
  // migrate from formalizer to otherside
  select one form related by r_simp->R_FORM[R208];
  select one rgo related by form->R_RGO[R205];
  unrelate form from rgo across R205;
  unrelate r_simp from form across R208;
  select one oir related by rgo->R_OIR[R203];
  unrelate oir from rgo across R203;
  self.ReferringClassInAssoc_dispose(r_rgo:rgo);
  create object instance othRto of R_RTO;
  relate oir to othRto across R203;
  create object instance aoth of R_AOTH;
  aoth.Mult = form.Mult;
  aoth.Cond = form.Cond;
  aoth.Txt_Phrs = form.Txt_Phrs;
  delete object instance form;
  relate othRto to aoth across R204;
  // link the other side to the new linked association
  relate aoth to assoc across R210;
  select one refClass related by oir->O_OBJ[R201];
else
  // this association is unformalized
  doingOneSide = true;
  for each part in parts
    if (doingOneSide)
      // migrate from participant to oneside
      select one rto related by part->R_RTO[R204];
      unrelate part from rto across R204;
      unrelate r_simp from part across R207;
      create object instance aone of R_AONE;
      aone.Mult = part.Mult;
      aone.Cond = part.Cond;
      aone.Txt_Phrs = part.Txt_Phrs;
      delete object instance part;
      relate rto to aone across R204;
      // link the one side to the new linked association
      relate aone to assoc across R209;
      doingOneSide = false;
    else
      // migrate from participant to otherside
      select one rto related by part->R_RTO[R204];
      unrelate part from rto across R204;
      unrelate r_simp from part across R207;
      create object instance aoth of R_AOTH;
      aoth.Mult = part.Mult;
      aoth.Cond = part.Cond;
      aoth.Txt_Phrs = part.Txt_Phrs;
      delete object instance part;
      relate rto to aoth across R204;
      // link the other side to the new linked association
      relate aoth to assoc across R210;
    end if;
  end for;
end if;
// link the fromClass to the association
create object instance oir of R_OIR;
relate fromClass to toAssoc across R201 using oir;
// create the referring class in association
create object instance rgo of R_RGO;
relate rgo to oir across R203;
relate rgo to assr across R205;
// link it with the linked association
relate assr to assoc across R211;
/* TODO - not doing anything about imported link classes at this time.  Circle back to this
if ( param.imported_id != GD::NULL_UNIQUE_ID() )
  // link class is an imported class
  select any imp_class related by fromClass->O_IOBJ[R101] 
        where selected.IObj_ID == param.imported_id;
  relate imp_class to oir across R202;
end if;*/
delete object instance r_simp;
',
	1,
	'',
	"637f67a3-d4bc-437a-b10a-3be1a34ef6a6",
	0);
INSERT INTO O_TPARM
	VALUES ("1e722958-d6c8-46f9-8780-bf2743a5dad9",
	"80312e5a-b61d-48ac-ab71-ce72803ac7a9",
	'using',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"f164887e-f60e-42a0-8a30-8d5c1bbb3981",
	'');
INSERT INTO O_TPARM
	VALUES ("f164887e-f60e-42a0-8a30-8d5c1bbb3981",
	"80312e5a-b61d-48ac-ab71-ce72803ac7a9",
	'r_simp',
	"322c65da-132b-421a-a1b1-f757cb0acff7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("32881ef9-929b-4561-821c-38088e434ce0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SimpleAssociation_unformalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_simp = param.r_simp;

TRACE::log( flavor:"info", id:110, message:"SimpleAssociation_unformalize:  Why are we here?" );

select any part_rto related by r_simp->R_PART[R207]->R_RTO[R204];  // there is only one

self.ReferredToClassInAssoc_unformalize(r_rto:part_rto);

// migrate formalizer back to Class As Simple Participant
select one form related by r_simp->R_FORM[R208];
self.ClassAsSimpleFormalizer_migrateToParticipant(r_form:form);


',
	1,
	'',
	"80312e5a-b61d-48ac-ab71-ce72803ac7a9",
	0);
INSERT INTO O_TPARM
	VALUES ("51e623f5-14e7-4d83-a576-912011899ddd",
	"32881ef9-929b-4561-821c-38088e434ce0",
	'r_simp',
	"322c65da-132b-421a-a1b1-f757cb0acff7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("05fbd4b2-4c6b-4d84-9579-772d17dbc371",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateEventMatrixEntry_disposeChOrEi',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_seme = param.sm_seme;

select one chevt related by sm_seme->SM_CH[R504];
if (not_empty chevt)
  unrelate sm_seme from chevt across R504;
  delete object instance chevt;
end if;
select one igevt related by sm_seme->SM_EIGN[R504];
if (not_empty igevt)
  unrelate sm_seme from igevt across R504;
  delete object instance igevt;
end if;
',
	1,
	'',
	"32881ef9-929b-4561-821c-38088e434ce0",
	0);
INSERT INTO O_TPARM
	VALUES ("43057f96-4657-4117-8dbd-3f6051239e42",
	"05fbd4b2-4c6b-4d84-9579-772d17dbc371",
	'sm_seme',
	"96262711-9aa1-476f-a01e-e61adb9c3647",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("96262711-9aa1-476f-a01e-e61adb9c3647",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Event Matrix Entry>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TFR
	VALUES ("ae3a5b0e-f701-45ab-89cd-f3d3f01053ba",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateEventMatrixEntry_migrateChToEi',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_seme = param.sm_seme;

select one ch related by sm_seme->SM_CH[R504];
if ( not_empty ch )
  create object instance ei of SM_EIGN;
  unrelate sm_seme from ch across R504;
  relate sm_seme to ei across R504;
  delete object instance ch;
end if;
',
	1,
	'',
	"05fbd4b2-4c6b-4d84-9579-772d17dbc371",
	0);
INSERT INTO O_TPARM
	VALUES ("a0163d85-7f4a-42dd-9295-00edf2bf0960",
	"ae3a5b0e-f701-45ab-89cd-f3d3f01053ba",
	'sm_seme',
	"96262711-9aa1-476f-a01e-e61adb9c3647",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("6d51881c-8e7c-4271-84ea-0380e31dcca1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateEventMatrixEntry_migrateEiToCh',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_seme = param.sm_seme;

select one ei related by sm_seme->SM_EIGN[R504];
if ( not_empty ei )
  create object instance ch of SM_CH;
  unrelate sm_seme from ei across R504;
  relate sm_seme to ch across R504;
  delete object instance ei;
end if;
',
	1,
	'',
	"ae3a5b0e-f701-45ab-89cd-f3d3f01053ba",
	0);
INSERT INTO O_TPARM
	VALUES ("1026d105-de2f-41d6-961c-7e0631aec30a",
	"6d51881c-8e7c-4271-84ea-0380e31dcca1",
	'sm_seme',
	"96262711-9aa1-476f-a01e-e61adb9c3647",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("846f57d3-718f-4ad9-99ad-0dc1f70db584",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEventDataItem_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_evtdi = param.sm_evtdi;

select one sm_evt related by sm_evtdi->SM_EVT[R532];
self.StateMachineEvent_addDataItemToOrder( sm_evtdi:sm_evtdi, sm_evt:sm_evt );

// TODO - assign a default type to aid in testing.  Do we want to keep this (to // END)?
globaltypes_pkg = self.globaltypes_pkg;
select any def_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == "string" );
// END

relate sm_evtdi to def_dt across R524;
sm_evtdi.Name = param.parameter_name;',
	1,
	'',
	"6d51881c-8e7c-4271-84ea-0380e31dcca1",
	0);
INSERT INTO O_TPARM
	VALUES ("f1bb0277-4c87-426d-af6f-5ec6435a81d2",
	"846f57d3-718f-4ad9-99ad-0dc1f70db584",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TPARM
	VALUES ("e6fde1e9-14d8-4e01-bcec-765d38b2c9ba",
	"846f57d3-718f-4ad9-99ad-0dc1f70db584",
	'parameter_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f1bb0277-4c87-426d-af6f-5ec6435a81d2",
	'');
INSERT INTO O_TFR
	VALUES ("76f85bce-9730-4bfb-b1e6-2f4ea0515222",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEventDataItem_setType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_evtdi = param.sm_evtdi;
type_name = param.type_name;

// NOTE: This isn''t really a copied operation from the OOAofOOA, but we''re following the same paradigm for it
//   as other functions that are from the OOA

// Get a handle to the DT that is named as a parameter, output error if none found
//   TODO - This is a very broad selection.  Is that OK?  Can we assume that during convert we won''t see data that 
//     has multiple (different) types with the same name?  Keith thinks so.
select any s_dt from instances of S_DT where ( selected.Name == type_name );
if ( empty s_dt )
  // TODO - what should the ID be set to?
  TRACE::log( flavor:"failure", id:0, message:"could not find datatype  " + type_name + " to set for attribute " + sm_evtdi.Name);
end if;

// Get a handle to the DT that is currently associated with the attribute
select one cur_s_dt related by sm_evtdi->S_DT[R524];

// If the new DT does not equal the existing DT, continue
if ( s_dt != cur_s_dt )
  // un-relate the existing DT across R524
  unrelate sm_evtdi from cur_s_dt across R524;
  
  // relate the new attribute across R524
  relate sm_evtdi to s_dt across R524;
end if;',
	1,
	'',
	"846f57d3-718f-4ad9-99ad-0dc1f70db584",
	0);
INSERT INTO O_TPARM
	VALUES ("33381fea-c7c0-476a-8eeb-4633d5be0e9d",
	"76f85bce-9730-4bfb-b1e6-2f4ea0515222",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("3cfc0e46-b9f7-4a6d-aec2-5f38e76b77cf",
	"76f85bce-9730-4bfb-b1e6-2f4ea0515222",
	'type_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"33381fea-c7c0-476a-8eeb-4633d5be0e9d",
	'');
INSERT INTO O_TFR
	VALUES ("54ebd6f3-6f35-4697-b61b-7d327f1bbf61",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_addDataItemToOrder',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'item = param.sm_evtdi;
sm_evt = param.sm_evt;

if(not_empty item)
  select many peers related by sm_evt->SM_EVTDI[R532];
  for each peer in peers
    if (peer != item)
      select one predecessor related by peer->SM_EVTDI[R533.''precedes''];
      if (empty predecessor)
        relate item to peer across R533.''succeeds'';
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	"76f85bce-9730-4bfb-b1e6-2f4ea0515222",
	0);
INSERT INTO O_TPARM
	VALUES ("086e36ad-a090-49ad-bd2e-2058bc9797d3",
	"54ebd6f3-6f35-4697-b61b-7d327f1bbf61",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("817e1012-3824-4e5f-a8ae-b0770960b836",
	"54ebd6f3-6f35-4697-b61b-7d327f1bbf61",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"086e36ad-a090-49ad-bd2e-2058bc9797d3",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("33eebb24-8068-410b-a905-37c4e5cc2fdb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TFR
	VALUES ("1c2e1c38-0c0b-4f89-b68e-e08da29540ea",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_createMessageArgumentsForParameter',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'parameter = param.sm_evtdi;
sm_evt = param.sm_evt;

if(not_empty parameter)
  // for each message associated with this
  // event, create a message argument.
  select many messages related by sm_evt->MSG_E[R1009]->MSG_AM[R1019]
                                                                 ->MSG_M[R1018];
  for each message in messages
    create object instance arg of MSG_A;
    create object instance ea of MSG_EA;
    relate ea to parameter across R1017;
    relate ea to arg across R1013;
    relate message to arg across R1001;
  end for;
end if;
',
	1,
	'',
	"54ebd6f3-6f35-4697-b61b-7d327f1bbf61",
	0);
INSERT INTO O_TPARM
	VALUES ("80484492-d976-40e4-860b-9661a828f75e",
	"1c2e1c38-0c0b-4f89-b68e-e08da29540ea",
	'sm_evtdi',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("f8a8d8c2-1e6a-402e-90a0-547978ab5d93",
	"1c2e1c38-0c0b-4f89-b68e-e08da29540ea",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"80484492-d976-40e4-860b-9661a828f75e",
	'');
INSERT INTO O_TFR
	VALUES ("5329e43f-743a-4151-83c3-5cc30b20d505",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_evt = param.sm_evt;

// This is a fairly heavily modified version of the same function in OOAofOOA
sm_evt.Mning = param.name;

// set this event''s number to a default value
sm_evt.Numb = 1;

// give this event a unique number
self.StateMachineEvent_setUniqueNumber(sm_evt:sm_evt, checkForDuplicate:false);

create object instance semEvt of SM_SEVT;
relate sm_evt to semEvt across R525;
create object instance locEvt of SM_LEVT;
relate semEvt to locEvt across R526;
//
self.SEMEvent_createDefaultMatrixEntries(sm_sevt:semEvt);
',
	1,
	'',
	"a9ad25b0-ca1a-425e-88ba-a16d259a6e9e",
	0);
INSERT INTO O_TPARM
	VALUES ("3554fa99-89d8-4945-bb46-178610950d85",
	"5329e43f-743a-4151-83c3-5cc30b20d505",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("d50b2563-d487-421b-b17f-5da4c9dbd2d5",
	"5329e43f-743a-4151-83c3-5cc30b20d505",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3554fa99-89d8-4945-bb46-178610950d85",
	'');
INSERT INTO O_TFR
	VALUES ("bfddc57e-d3e9-4d60-be7c-49419eadc2ab",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_newParameter',
	'',
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	1,
	'sm_evt = param.sm_evt;

// State Machine Event.newDataItem()
create object instance newEvtdi of SM_EVTDI;
relate sm_evt to newEvtdi across R532;
select one sm related by sm_evt->SM_SM[R502];
relate newEvtdi to sm across R516;
self.StateMachineEventDataItem_initialize( sm_evtdi:newEvtdi, parameter_name:param.parameter_name );
self.StateMachineEvent_createMessageArgumentsForParameter(sm_evtdi:newEvtdi, sm_evt:sm_evt);

return newEvtdi;',
	1,
	'',
	"88689cb1-bdb5-4c16-8ee5-3518ac8b2fa6",
	0);
INSERT INTO O_TPARM
	VALUES ("d927ecb0-f4b0-47ab-bd8e-ef51b30216f6",
	"bfddc57e-d3e9-4d60-be7c-49419eadc2ab",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("b3623846-1ddd-4dc8-a9a2-b8f5c762cec4",
	"bfddc57e-d3e9-4d60-be7c-49419eadc2ab",
	'parameter_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d927ecb0-f4b0-47ab-bd8e-ef51b30216f6",
	'');
INSERT INTO O_TFR
	VALUES ("5989531f-5825-478c-b340-f268d37646ac",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_setUniqueNumber',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_evt = param.sm_evt;
checkForDuplicate = param.checkForDuplicate;

// for each event associated with this event''s state machine
select one sm related by sm_evt->SM_SM[R502];
select many events related by sm->SM_EVT[R502];
foundDuplicate = false;
originalNumb = sm_evt.Numb;
for each event in events
  // if this event is sm_evt, skip it
  if (event.SMevt_ID == sm_evt.SMevt_ID)  continue;  end if;

  if(event.Numb == sm_evt.Numb)
    foundDuplicate = true;
  end if;

  // if this other event''s number is greater than this event''s number
  if (event.Numb >= sm_evt.Numb)
    // have this event''s number be just greater than that of 
    // this other event
    sm_evt.Numb = event.Numb + 1;
  end if;
end for;
if(not foundDuplicate and param.checkForDuplicate)
  sm_evt.Numb = originalNumb;
end if;',
	1,
	'',
	"bfddc57e-d3e9-4d60-be7c-49419eadc2ab",
	0);
INSERT INTO O_TPARM
	VALUES ("506d1c52-bfcf-4548-af45-a2bdb86d50d8",
	"5989531f-5825-478c-b340-f268d37646ac",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("58894655-a0d8-41bf-933f-f160ca6cebfd",
	"5989531f-5825-478c-b340-f268d37646ac",
	'checkForDuplicate',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"506d1c52-bfcf-4548-af45-a2bdb86d50d8",
	'');
INSERT INTO O_TFR
	VALUES ("f32b9cbc-9ad2-4b46-9ab5-a169f953192f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineState_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_state = param.sm_state;

// This is a heavily modified version of the function in the OOAofOOA
sm_state.Name = param.name;

// set this state''s number to a default value
sm_state.Numb = 1;

// for each state associated with this state''s state machine
select many states related by sm_state->SM_SM[R501]->SM_STATE[R501];
// If it is the assigner start state, the number must be 1. In this case, all other state numbers are incremented.
// This approach assumes that number 1 has already been taken. This is a safe assumption because the default
// value for Numb (see line 7 above) is 1. So if there are any states existing, at least one has the number 1.
if ( "assigner start" == param.type )
  for each state in states
	// if this state equals sm_state, skip it
	if (state.SMstt_ID == sm_state.SMstt_ID) continue; end if;
	
	// increment the number
	state.Numb = state.Numb + 1;
  end for;
// If not the assigner start state, iterate to find the next highest state number
else
  for each state in states
	// if this state equals sm_state, skip it
	if (state.SMstt_ID == sm_state.SMstt_ID) continue; end if;

	// if this other state''s number is greater than this state''s number
	if ( state.Numb >= sm_state.Numb )
	  // have this state''s number be just greater than this
	  // other state''s number
	  sm_state.Numb = state.Numb + 1;
	end if;
  end for;
end if;

// if it is a terminal state, set Final to 1. Else set it to 0
if ( "terminal" == param.type )
  sm_state.Final = 1;
else
  sm_state.Final = 0;
end if;

// Maslin NOTE: The order in this block of code is different than in OOAofOOA.  MC-Java does automatic
// maintenance of referential IDs, MC-3020 does not.  Thus, for MC-3020 we have to be careful about the 
// order the relates are done.
select one sm related by sm_state->SM_SM[R501];
create object instance act of SM_ACT;
relate act to sm across R515;
create object instance ah of SM_AH;
create object instance moah of SM_MOAH;
relate act to ah across R514;
relate ah to moah across R513;
select one msm related by sm->SM_MOORE[R510];
relate sm_state to msm across R511 using moah;
//
// create SEM entry instances
//
select many event_set related by sm->SM_EVT[R502]->SM_SEVT[R525];
for each event in event_set
  select any sem related by event->SM_SEME[R503] where (selected.SMstt_ID == sm_state.SMstt_ID);
  if ( empty sem )
	create object instance sem of SM_SEME;
	// TODO: get default subtype from preferences (SKB Note: this TODO is from the OOAofOOA, not MASLIN)
	create object instance ch of SM_CH;
	relate sm_state to event across R503 using sem;
	relate ch to sem across R504;
  end if;
end for;

act.Suc_Pars = ParseStatus::parseInitial;',
	1,
	'',
	"5989531f-5825-478c-b340-f268d37646ac",
	0);
INSERT INTO O_TPARM
	VALUES ("544d9892-6cd9-435a-89fb-e6e73683e6b7",
	"f32b9cbc-9ad2-4b46-9ab5-a169f953192f",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"62eb8f49-c2a0-4920-ada0-17ea3f82d091",
	'');
INSERT INTO O_TPARM
	VALUES ("62eb8f49-c2a0-4920-ada0-17ea3f82d091",
	"f32b9cbc-9ad2-4b46-9ab5-a169f953192f",
	'sm_state',
	"ce86dade-b263-4245-8001-19dd4123f4f9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ce86dade-b263-4245-8001-19dd4123f4f9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine State>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TPARM
	VALUES ("cd3f83c6-62ec-497d-a752-b56a0b8a633c",
	"f32b9cbc-9ad2-4b46-9ab5-a169f953192f",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"544d9892-6cd9-435a-89fb-e6e73683e6b7",
	'');
INSERT INTO O_TFR
	VALUES ("f726dd26-884f-4c3d-864d-0e24146b887c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachine_newCreationTransition',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sm = param.sm_sm;
select one o_obj related by sm_sm->SM_ISM[R517]->O_OBJ[R518];
if ( empty o_obj )
  // this should never happen for a creation transition...
  TRACE::log( id:77, flavor:"warning", message:"Creation transition cannot be defined for class state machine" );
  select one o_obj related by sm_sm->SM_ASM[R517]->O_OBJ[R519];
end if;

if ( "" != param.objectName and o_obj.Name != param.objectName )
  if ( "Cannot_Happen" == param.endState or "cannot_happen" == param.endState )
    // Ignore polymorphic creation transitions. In MASL, they are added for
    // completeness, however they are always required to transition to
    // "Cannot_Happen"
  else
    TRACE::log( id:78, flavor:"failure", message:"Polymorhpic creation transition must be assigned ''Cannot_Happen''" );
  end if;
else
  //IGNORE: ''Ignore'';
  if ( "Ignore" == param.endState )
    // TODO - handle setting the transition type on the event, look at StateMachineEvent ignoreOnState
    //   ...but do we care about this on creation events in xtUML land? 
  //CANNOT_HAPPEN: ''Cannot_Happen'' | ''cannot_happen'';
  elif ( "Cannot_Happen" == param.endState or "cannot_happen" == param.endState )
    // TODO - handle setting the transition type on the event, look at StateMachineEvent sayCantHappenOnState
    //   ...but do we care about this on creation events in xtUML land? 
  else
    select any state related by sm_sm->SM_STATE[R501] where (selected.Name == param.endState);
    if (not_empty state)
      create object instance tr of SM_TXN;
      create object instance ct of SM_CRTXN;
      relate tr to ct across R507;
      relate tr to state across R506;
      relate sm_sm to tr across R505;
      self.Transition_initialize(sm_txn:tr);
    select any sm_evt related by sm_sm->SM_EVT[R502] where ( selected.Mning == param.eventName );
    if ( not_empty sm_evt )
        self.Transition_addEvent(sm_txn:tr, sm_sm:sm_sm, sm_evt:sm_evt);
      end if;
    /*else
        TODO - LOG error message?*/
    end if;
  end if;
end if;',
	1,
	'',
	"f32b9cbc-9ad2-4b46-9ab5-a169f953192f",
	0);
INSERT INTO O_TPARM
	VALUES ("1f55c7fc-58c6-47e7-8b06-d839153a4470",
	"f726dd26-884f-4c3d-864d-0e24146b887c",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("64f2199d-a1c0-4fef-a92e-9108e2903bff",
	"f726dd26-884f-4c3d-864d-0e24146b887c",
	'eventName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"1f55c7fc-58c6-47e7-8b06-d839153a4470",
	'');
INSERT INTO O_TPARM
	VALUES ("757acac7-4610-4ccb-a31f-4a4c366cb6c4",
	"f726dd26-884f-4c3d-864d-0e24146b887c",
	'endState',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"64f2199d-a1c0-4fef-a92e-9108e2903bff",
	'');
INSERT INTO O_TPARM
	VALUES ("72e68136-9ad0-488a-b685-f3817469ebd2",
	"f726dd26-884f-4c3d-864d-0e24146b887c",
	'objectName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"757acac7-4610-4ccb-a31f-4a4c366cb6c4",
	'');
INSERT INTO O_TFR
	VALUES ("c05389a8-9886-4c2a-9288-57262c84ce9c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachine_newEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sm = param.sm_sm;

select any sm_evt related by sm_sm->SM_EVT[R502] where ( selected.Mning == param.name );
select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
if ( empty sm_evt or ( not_empty sm_evt and not_empty sm_nlevt ) ) // allow duplicate named events if one is a poly
  create object instance newEvent of SM_EVT;
  relate sm_sm to newEvent across R502;
  self.StateMachineEvent_initialize(sm_evt:newEvent, name:param.name);
  self.StateMachine_syncPolymorphicEvents( sm_sm:sm_sm );
end if;
',
	1,
	'',
	"f726dd26-884f-4c3d-864d-0e24146b887c",
	0);
INSERT INTO O_TPARM
	VALUES ("be7fb5a2-bc3f-427e-896d-68fe98253754",
	"c05389a8-9886-4c2a-9288-57262c84ce9c",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("4016cd74-b8de-4dfc-877e-7b6ce5577ef1",
	"c05389a8-9886-4c2a-9288-57262c84ce9c",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"be7fb5a2-bc3f-427e-896d-68fe98253754",
	'');
INSERT INTO O_TFR
	VALUES ("045773f0-d88d-4a1a-b0bc-326abc3cc3c9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachine_newState',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sm = param.sm_sm;

create object instance st of SM_STATE;
relate sm_sm to st across R501;
self.StateMachineState_initialize(sm_state:st, name:param.name, type:param.type);',
	1,
	'',
	"c05389a8-9886-4c2a-9288-57262c84ce9c",
	0);
INSERT INTO O_TPARM
	VALUES ("25858f2f-2134-4e53-b51f-9f4bd5e91e4d",
	"045773f0-d88d-4a1a-b0bc-326abc3cc3c9",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("6754f06f-afa5-49ba-9c86-3b5de38ddb1b",
	"045773f0-d88d-4a1a-b0bc-326abc3cc3c9",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"25858f2f-2134-4e53-b51f-9f4bd5e91e4d",
	'');
INSERT INTO O_TPARM
	VALUES ("c4c476d1-abf7-41c6-976f-36c68841e248",
	"045773f0-d88d-4a1a-b0bc-326abc3cc3c9",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6754f06f-afa5-49ba-9c86-3b5de38ddb1b",
	'');
INSERT INTO O_TFR
	VALUES ("9441f59a-81c9-4794-b2f6-7bc381db1928",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachine_newTransition',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sm = param.sm_sm;

// Similar to the same function in OOAofOOA but here we do some extra work to handle case where the endState is 
// not really a state but is "Ignore" or "Cannot_Happen"

select any fromState related by sm_sm->SM_STATE[R501] where (selected.Name == param.startState);
select any sm_evt from instances of SM_EVT where false;

if ( "" == param.object ) // must be a local event
  select any sm_evt related by sm_sm->SM_EVT[R502] where ( selected.Mning == param.eventName );
else  // referring to a poly event
  select any o_obj from instances of O_OBJ where ( selected.Name == param.object );
  select any sm_evt related by o_obj->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502] where ( selected.Mning == param.eventName );
end if;

// if no event was found, return early
if ( empty sm_evt )
  TRACE::log( flavor:"failure", id:157, message:"Event for transition not found for event:  " + param.eventName );
  return;
end if;

// Ignore polymorphic creation transitions. In MASL, they are added for
// completeness, however they are always required to transition to
// "Cannot_Happen"
select one sm_crtxn related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
if ( not_empty sm_crtxn )
  if ( "Cannot_Happen" == param.endState or "cannot_happen" == param.endState )
    // Do nothing. This is a valid case.
  else
    TRACE::log( id:79, flavor:"failure", message:"Polymorhpic creation transition must be assigned ''Cannot_Happen''" );
  end if;
  return; // return early
end if;

// if it is a non-local event, get the corresponding poly
select one polyEvt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525];
if ( not_empty polyEvt )
  sm_evt = polyEvt;
end if;

// resolve the event for the current state machine
evt_id = self.StateMachineEvent_getAssociatedEventForStateMachine( sm_evt:sm_evt, stateMachineId:sm_sm.SM_ID );
select any sm_evt from instances of SM_EVT where ( selected.SMevt_ID == evt_id );

//IGNORE: ''Ignore'';
if ( "Ignore" == param.endState )
  // change the matrix entry for the event found above from a can''t happen to an ignore
  select any seme related by sm_evt->SM_SEVT[R525]->SM_SEME[R503] where (selected.SMstt_ID == fromState.SMstt_ID);
  self.StateEventMatrixEntry_migrateChToEi(sm_seme:seme);
//CANNOT_HAPPEN: ''Cannot_Happen'' | ''cannot_happen'';
elif ( "Cannot_Happen" == param.endState or "cannot_happen" == param.endState )
  // change the matrix entry for the event found above from an ignore to a can''t happen
  select any seme related by sm_evt->SM_SEVT[R525]->SM_SEME[R503] where (selected.SMstt_ID == fromState.SMstt_ID);
  self.StateEventMatrixEntry_migrateEiToCh(sm_seme:seme);
else
  select any toState related by sm_sm->SM_STATE[R501] where (selected.Name == param.endState);
  if (not_empty fromState and not_empty toState)
    create object instance tr of SM_TXN;
    create object instance net of SM_NETXN;
    relate tr to net across R507;
    relate net to fromState across R508;
    relate tr to toState across R506;
    relate sm_sm to tr across R505;
    self.Transition_initialize(sm_txn:tr);
    self.Transition_addEvent(sm_txn:tr, sm_sm:sm_sm, sm_evt:sm_evt);
  /*else
      TODO - LOG error message?*/
  end if;
end if;',
	1,
	'',
	"045773f0-d88d-4a1a-b0bc-326abc3cc3c9",
	0);
INSERT INTO O_TPARM
	VALUES ("3087c5f7-5224-4194-8080-34fdf1d367cd",
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	'eventName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"757f014f-02f4-4b99-897e-0df2d3e9ace9",
	'');
INSERT INTO O_TPARM
	VALUES ("1f90fb1b-9078-4abb-acd1-45e3d9ec4b3e",
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	'startState',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3087c5f7-5224-4194-8080-34fdf1d367cd",
	'');
INSERT INTO O_TPARM
	VALUES ("7209d71b-3f46-411d-ae84-8bdcddfad63f",
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	'endState',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"1f90fb1b-9078-4abb-acd1-45e3d9ec4b3e",
	'');
INSERT INTO O_TPARM
	VALUES ("757f014f-02f4-4b99-897e-0df2d3e9ace9",
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("af57cf53-47c2-4f52-9461-e2d9f8450988",
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"7209d71b-3f46-411d-ae84-8bdcddfad63f",
	'');
INSERT INTO O_TPARM
	VALUES ("a078a089-66c5-444b-b56f-d28157f61d17",
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	'object',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"af57cf53-47c2-4f52-9461-e2d9f8450988",
	'');
INSERT INTO O_TFR
	VALUES ("d3b32af4-b567-4dd3-9fa1-3b553b2b76ad",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SubtypeSupertypeAssociation_formalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_subsup = param.r_subsup;

if ( self.SubtypeSupertypeAssociation_isFormalized(r_subsup:r_subsup) )
  self.SubtypeSupertypeAssociation_unformalize(r_subsup:r_subsup);
end if;

select one sup_rto related by r_subsup->R_SUPER[R212]->R_RTO[R204];
select one sup_obj related by sup_rto->R_OIR[R203]->O_OBJ[R201];
select any oid related by sup_obj->O_ID[R104] where selected.Oid_ID == param.id;
relate oid to sup_rto across R109;

select many oida_set related by oid->O_OIDA[R105];
select many sub_rgo_set related by r_subsup->R_SUB[R213]->R_RGO[R205];
// always create the O_RTIDA instances even if the
// association doesn''t have any subclasses defined at the moment
for each oida in oida_set 
  create object instance rtida of O_RTIDA;
  relate oida to sup_rto across R110 using rtida;
end for;
for each sub_rgo in sub_rgo_set
  select one sub_obj related by sub_rgo->R_OIR[R203]->O_OBJ[R201];
  // unused_oid = sub_obj.findUnusedIdentifier(); LPS - we do not need to automatically ad to an identifier because this
  // will be done later by the rest of the MASL convert
  for each oida in oida_set 
    select one rel related by r_subsup->R_REL[R206];
    select one sub_obj related by sub_rgo->R_OIR[R203]->O_OBJ[R201];
    newAttr = self.ClassIdentifierAttribute_addReference(o_oida:oida, rel: rel,
        part_rto: sup_rto, part_obj: sup_obj, 
        form_rgo: sub_rgo, form_obj: sub_obj,
        id: -1);
        //id: unused_oid);
  end for;
end for;
',
	1,
	'',
	"eaba961e-3074-43c5-84d1-2bc13ddd73f0",
	0);
INSERT INTO O_TPARM
	VALUES ("d49b49e2-281f-41b2-895e-4b8008c484f3",
	"d3b32af4-b567-4dd3-9fa1-3b553b2b76ad",
	'id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"287df930-6df4-46fc-92a9-670519d3d9cc",
	'');
INSERT INTO O_TPARM
	VALUES ("287df930-6df4-46fc-92a9-670519d3d9cc",
	"d3b32af4-b567-4dd3-9fa1-3b553b2b76ad",
	'r_subsup',
	"8f3b0ab8-e566-4e03-9159-7047140c04a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8f3b0ab8-e566-4e03-9159-7047140c04a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Subtype Supertype Association>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO O_TFR
	VALUES ("3ee32abe-e6c9-44ab-a4c9-be87d7b0d2fe",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SubtypeSupertypeAssociation_isFormalized',
	'',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'r_subsup = param.r_subsup;
select one rto related by r_subsup->R_SUPER[R212]->R_RTO[R204];
select any rtida related by rto->O_RTIDA[R110];
return not_empty rtida;
',
	1,
	'',
	"d3b32af4-b567-4dd3-9fa1-3b553b2b76ad",
	0);
INSERT INTO O_TPARM
	VALUES ("c920eff6-83b1-430a-b45d-a8ebfc730c8f",
	"3ee32abe-e6c9-44ab-a4c9-be87d7b0d2fe",
	'r_subsup',
	"8f3b0ab8-e566-4e03-9159-7047140c04a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("7428e33e-ff17-425f-8d48-7512611b19c2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SubtypeSupertypeAssociation_unformalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'r_subsup = param.r_subsup;

select one sup_rto related by r_subsup->R_SUPER[R212]->R_RTO[R204];
select one sup_oir related by sup_rto->R_OIR[R203];

self.ReferredToClassInAssoc_unformalize(r_rto:sup_rto);

// have to relate again due to propagation of previous unrelates
relate sup_oir to sup_rto across R203;

',
	1,
	'',
	"3ee32abe-e6c9-44ab-a4c9-be87d7b0d2fe",
	0);
INSERT INTO O_TPARM
	VALUES ("04dd78f4-684f-4fad-8e8d-5c98335a2529",
	"7428e33e-ff17-425f-8d48-7512611b19c2",
	'r_subsup',
	"8f3b0ab8-e566-4e03-9159-7047140c04a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("05511e88-f6f4-44c8-be37-9da8b177203f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SystemModel_getCoreTypeId',
	'',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	1,
	's_sys = param.s_sys;

// LPS - This is copied from the OOAofOOA, but it is now a misnomer because it is returning an inst_ref and not an ID

select any coreDt from instances of S_DT where false;
// System.getCoreTypeId()
if s_sys.useGlobals
  select any coreDt related by s_sys->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]
                                              where selected.Name == param.name;
end if;

return coreDt;',
	1,
	'',
	"7428e33e-ff17-425f-8d48-7512611b19c2",
	0);
INSERT INTO O_TPARM
	VALUES ("b999947b-7b2e-4124-b4ab-6c7756c98537",
	"05511e88-f6f4-44c8-be37-9da8b177203f",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"8706bb63-2168-418a-90fb-db9a727f0025",
	'');
INSERT INTO O_TPARM
	VALUES ("8706bb63-2168-418a-90fb-db9a727f0025",
	"05511e88-f6f4-44c8-be37-9da8b177203f",
	's_sys',
	"4b886601-55ee-4d42-a1f8-f5c45d459db2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4b886601-55ee-4d42-a1f8-f5c45d459db2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<System Model>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO O_TFR
	VALUES ("7b3f5bcd-9ae8-4296-8f10-cc9eff5a341f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SystemModel_newPackage',
	'',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	1,
	's_sys = param.s_sys;

create object instance package of EP_PKG;
create object instance pe of PE_PE;
relate pe to package across R8001;
relate package to s_sys across R1401;
relate package to s_sys across R1405;
pe.type = ElementTypeConstants::PACKAGE;
self.PackageableElement_initialize(pe_pe:pe);
self.Package_initialize(ep_pkg:package, name:param.pkg_name);

return package; ',
	1,
	'',
	"05511e88-f6f4-44c8-be37-9da8b177203f",
	0);
INSERT INTO O_TPARM
	VALUES ("33ad0997-c727-467f-847b-07427dd4a8f7",
	"7b3f5bcd-9ae8-4296-8f10-cc9eff5a341f",
	's_sys',
	"4b886601-55ee-4d42-a1f8-f5c45d459db2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("8b6c882b-50a3-438d-9d0a-1572cca48548",
	"7b3f5bcd-9ae8-4296-8f10-cc9eff5a341f",
	'pkg_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"33ad0997-c727-467f-847b-07427dd4a8f7",
	'');
INSERT INTO O_TFR
	VALUES ("53cb6e0c-928f-42e0-822c-4c3d97fe1002",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Transition_addEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_txn = param.sm_txn;
sm_sm = param.sm_sm;
sm_evt = param.sm_evt;

// Modified version of the same function from OOAofOOA
select one no_evt_txn related by sm_txn->SM_NETXN[R507];
if ( not_empty no_evt_txn )
  select one orig_state related by no_evt_txn->SM_STATE[R508];
  unrelate no_evt_txn from orig_state across R508;
  unrelate no_evt_txn from sm_txn across R507;
  delete object instance no_evt_txn;
  create object instance ns_txn of SM_NSTXN;
  relate sm_txn to ns_txn across R507;
   
  select any seme related by orig_state->SM_SEME[R503] 
      where selected.SMevt_ID == sm_evt.SMevt_ID;
  self.StateEventMatrixEntry_disposeChOrEi(sm_seme:seme);
  relate ns_txn to seme across R504;
else
  select one ns_txn related by sm_txn->SM_NSTXN[R507];
  if ( not_empty ns_txn )
    select one seme related by ns_txn->SM_SEME[R504];
    select one orig_state related by seme->SM_STATE[R503];

    // change SEME caused by old event to be cant happen
    create object instance ch of SM_CH;
    unrelate ns_txn from seme across R504;
    relate seme to ch across R504;
     
    // find SEME caused by new event
    select any new_seme related by orig_state->SM_SEME[R503] 
        where selected.SMevt_ID == sm_evt.SMevt_ID;
    self.StateEventMatrixEntry_disposeChOrEi(sm_seme:new_seme);
    relate new_seme to ns_txn across R504;
    // state supplemental dataset should be unchanged
  else
    select one cr_txn related by sm_txn->SM_CRTXN[R507];
    select one levt related by cr_txn->SM_LEVT[R509];
    if ( not_empty levt )
      unrelate cr_txn from levt across R509;
    end if;
    select one new_evt related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526];         
    relate cr_txn to new_evt across R509;
  end if;
end if;

',
	1,
	'',
	"7b3f5bcd-9ae8-4296-8f10-cc9eff5a341f",
	0);
INSERT INTO O_TPARM
	VALUES ("ac4b12d8-104a-47a3-9bcf-ef217cfc4f26",
	"53cb6e0c-928f-42e0-822c-4c3d97fe1002",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"4b294dd5-cfb2-45ed-989d-a472e6868ba0",
	'');
INSERT INTO O_TPARM
	VALUES ("9cb5595c-665e-4e00-9816-b817dd9fd8b7",
	"53cb6e0c-928f-42e0-822c-4c3d97fe1002",
	'sm_txn',
	"f1d56d88-4138-4bdf-a9a2-306b73878dab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f1d56d88-4138-4bdf-a9a2-306b73878dab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Transition>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TPARM
	VALUES ("4b294dd5-cfb2-45ed-989d-a472e6868ba0",
	"53cb6e0c-928f-42e0-822c-4c3d97fe1002",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"9cb5595c-665e-4e00-9816-b817dd9fd8b7",
	'');
INSERT INTO O_TFR
	VALUES ("49cfb438-3413-43dc-a4b0-376f19d5ce21",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'Transition_initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_txn = param.sm_txn;

// Transition.initialize()
// Create the action home
select one sm related by sm_txn->SM_SM[R505];  
create object instance act of SM_ACT;
act.Suc_Pars = ParseStatus::parseInitial;
act.Dialect = ActionDialect::none;
relate act to sm across R515;
create object instance ah of SM_AH;
relate act to ah across R514;
create object instance tah of SM_TAH;
relate ah to tah across R513;
relate sm_txn to tah across R530;
',
	1,
	'',
	"53cb6e0c-928f-42e0-822c-4c3d97fe1002",
	0);
INSERT INTO O_TPARM
	VALUES ("a04e602b-647c-4a41-b28c-9663d9835053",
	"49cfb438-3413-43dc-a4b0-376f19d5ce21",
	'sm_txn',
	"f1d56d88-4138-4bdf-a9a2-306b73878dab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("c13ffb46-9525-4e0f-ad45-3cf093b2b249",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'batchFormalize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select many forms from instances of formalization;
num_forms = cardinality forms;
previous_formalization_count = num_forms;
passes = 0;

// Because of possible dependencies, it is required to pass over the list
// of formalizations N times where N is the number of formalizations
// The worst case scenario is if each formalization is dependent on the next
// Loop an extra time to acount for detection of recursive referentials.
while ( passes <= num_forms )

  for each form in forms

	if ( 0 == form.type )
	  select one simpForm related by form->simpleFormalization[R3810];
	  id = simpForm.getID();
	  if ( -1 != id )	// the formalization is complete
		simp = simpForm.rel;
		select any r_part related by simp->R_PART[R207] where ( selected.Obj_ID == simpForm.part_obj_id );
		
		// formalize the relationship
		select any ra related by form->referentialAttribute[R3811];
		self.SimpleAssociation_formalize(r_simp:simp, r_part:r_part, id_id:id, rolephrase:ra.roleOrObj);
		
		// there is some post processing that needs to be done for each referentialAttribute
		// in the formalization
		// * rename the referential attribute properly
		// * if needed, add the referential attribute to an identifier
		// * check for a duplicate that needs to be combined
		select many ras related by form->referentialAttribute[R3811];
		for each ra in ras
		  // select the corresponding new referential attribute
		  select any o_attr related by simp->R_FORM[R208]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106] where ( selected.Root_Nam == ra.attrName );
		  // rename the attribute to the final name of the attribute (not the participant ID name)
		  if ( not_empty o_attr )
		    o_attr.Root_Nam = ra.Name;
		  end if;
		end for;
		for each ra in ras
		  // select the corresponding new referential attribute
		  select any o_attr related by simp->R_FORM[R208]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106] where ( selected.Root_Nam == ra.Name );
          ra.postProcess( o_attr:o_attr, ooapopulation:self );  
		end for;
		
		// post processing for the formalizing object
		// * remove any base attributes that have a referential attribute of the same name
		select one form_obj related by simp->R_FORM[R208]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
		self.ModelClass_removeDuplicateAttrs(o_obj:form_obj);
		
		form.dispose();
	  end if;
	elif ( 1 == form.type )
	  select one subsupForm related by form->subsuperFormalization[R3810];
	  id = subsupForm.getID();
	  //id = 0;
	  if ( -1 != id )	// the formalization is complete
	    subsuper = subsupForm.rel;
	    
	    // formalize the relationship
	    self.SubtypeSupertypeAssociation_formalize( r_subsup:subsuper, id:id );
	    
		// there is some post processing that needs to be done for each referentialAttribute
		// in the formalization
		// * rename the referential attribute properly
		// * if needed, add the referential attribute to an identifier
		// * check for a duplicate that needs to be combined
		select many ras related by form->referentialAttribute[R3811];
		for each ra in ras
		  o_obj = ra.o_obj;
		  select any o_attr related by o_obj->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106] where ( selected.Root_Nam == ra.attrName );
		  // rename the attribute to the final name of the attribute (not the participant ID name)
		  if ( not_empty o_attr )
		    o_attr.Root_Nam = ra.Name;
		  end if;
		end for;
		for each ra in ras
		  o_obj = ra.o_obj;
		  select any o_attr related by o_obj->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106] where ( selected.Root_Nam == ra.Name );
		  ra.postProcess( o_attr:o_attr, ooapopulation:self );
		end for;
		
		// post processing for the formalizing object
		// * remove any base attributes that have a referential attribute of the same name
		select many subs related by subsuper->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
		for each sub in subs;
		  self.ModelClass_removeDuplicateAttrs(o_obj:sub);
		end for;
		
		form.dispose();
	  end if;
	elif ( 2 == form.type )
	  select one assocForm related by form->assocFormalization[R3810];
	  one_id = assocForm.getID( target:0 );
	  other_id = assocForm.getID( target:1 );
	  if ( -1 != one_id and -1 != other_id )	// the formalization is complete
	    linked = assocForm.rel;
	    
	    // formalize the relationship
	    self.LinkedAssociation_formalize( r_assoc:linked, one_id:one_id, oth_id:other_id );
	    
		// there is some post processing that needs to be done for each referentialAttribute
		// in the formalization
		// * rename the referential attribute properly
		// * if needed, add the referential attribute to an identifier
		// * check for a duplicate that needs to be combined
		select one assr_obj related by linked->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
		select many ras related by form->referentialAttribute[R3811];
		for each ra in ras
		  // select the corresponding new referential attribute
		  // At this point, there may be several referentials that would match by name.
		  // This is because the names are still the name found on the identifying attribute.
		  // Be sure that the o_attr is connected to a participant with the correct role phrase.
		  select many o_attrs related by assr_obj->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106] where ( selected.Root_Nam == ra.attrName );
		  for each o_attr in o_attrs
		    select many r_rtos related by o_attr->O_RATTR[R106]->O_REF[R108]->O_RTIDA[R111]->R_RTO[R110];
		    select any r_aone related by r_rtos->R_AONE[R204] where ( selected.Txt_Phrs == ra.roleOrObj );
		    select one o_obj related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
		    if ( empty o_obj )
		      select any r_aoth related by r_rtos->R_AOTH[R204] where ( selected.Txt_Phrs == ra.roleOrObj );
		      select one o_obj related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
		    end if;
		    if ( not_empty o_obj )
		      if ( o_obj.Name == ra.objectName )
		        // rename the attribute to the final name of the attribute (not the participant ID name)
		        o_attr.Root_Nam = ra.Name;
		        break;
		      end if;
		    end if;
		  end for;
		end for;
		for each ra in ras
		  // select the corresponding new referential attribute
		  // At this point, there may be several referentials that would match by name.
		  // This is because the names are still the name found on the identifying attribute.
		  // Be sure that the o_attr is connected to a participant with the correct role phrase.
		  select many o_attrs related by assr_obj->O_ATTR[R102]->O_RATTR[R106]->O_ATTR[R106] where ( selected.Root_Nam == ra.Name );
		  for each o_attr in o_attrs
		    select many r_rtos related by o_attr->O_RATTR[R106]->O_REF[R108]->O_RTIDA[R111]->R_RTO[R110];
		    select any r_aone related by r_rtos->R_AONE[R204] where ( selected.Txt_Phrs == ra.roleOrObj );
		    select any r_aoth related by r_rtos->R_AOTH[R204] where ( selected.Txt_Phrs == ra.roleOrObj );
		    if ( not_empty r_aone or not_empty r_aoth )
		      ra.postProcess( o_attr:o_attr, ooapopulation:self );
		      break;
		    end if;
		  end for;
		end for;
		
		// post processing for the formalizing object
		// * remove any base attributes that have a referential attribute of the same name
		self.ModelClass_removeDuplicateAttrs(o_obj:assr_obj);
		
		form.dispose();
	  end if;
	end if;

  end for;

  // increment counter
  passes = passes + 1;

  // re-select the formalizations
  select many forms from instances of formalization;

  current_formalization_count = cardinality forms;
  if ( current_formalization_count == previous_formalization_count )
    // detect baseless (recursive) referentials
    select many ras from instances of referentialAttribute;
    max_depth = cardinality ras;
    for each ra in ras
      ra.detectRecursive(ra:ra, current_depth:0, max_depth:max_depth);
    end for;
  end if;
  previous_formalization_count = current_formalization_count;

  // Give preference to formalizations that have referentials-as-identifiers.
  // This will formalize associations in baseless loops before the baseless spurs.
  select many identifier_ras from instances of referentialAttribute where ( selected.identifier1 or selected.identifier2 or selected.identifier3 );
  select many forms related by identifier_ras->formalization[R3811];
  if ( empty forms )
    select many forms from instances of formalization;
  end if;

end while;

if ( not_empty forms )
  TRACE::log( flavor:"failure", id:17, message:"Incomplete formalizations still exist" );
end if;',
	1,
	'',
	"49cfb438-3413-43dc-a4b0-376f19d5ce21",
	0);
INSERT INTO O_TFR
	VALUES ("32f13bee-f495-4551-8945-54c6bf7a0be4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'clearRelationshipCache',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'self.current_rel.type = RELATIONSHIP_TYPE::NONE;
self.current_rel.number = "";
self.current_rel.usingObj = "";
self.current_rel.description = "";

select many parts from instances of ooaparticipation;
for each part in parts
  delete object instance part;
end for;',
	1,
	'',
	"c13ffb46-9525-4e0f-ad45-3cf093b2b249",
	0);
INSERT INTO O_TFR
	VALUES ("d575fa93-3488-4bc0-ab38-d6aff10a2894",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'createSystem',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	's_sys = self.current_sys;
if ( empty s_sys )
  // Create the system model and cache it
  create object instance s_sys of S_SYS;

  s_sys.Name = "ConvertedModel";
  self.current_sys = s_sys;

  // Create a system level types package and cache it
  self.systypes_pkg = self.SystemModel_newPackage(s_sys:s_sys, pkg_name:"types");
  
  i = 0;
  s[ 8 ] = "initializing array length";
  s[ i ] = "";
  s[ 0 ] = "character";
  s[ 1 ] = "wcharacter";
  s[ 2 ] = "byte";
  s[ 3 ] = "long_integer";
  s[ 4 ] = "wstring";
  s[ 5 ] = "duration";
  s[ 6 ] = "device";
  s[ 7 ] = "MASLunique";
  s[ 8 ] = "MASLtype";
  i = 8;

  while ( i >= 0 )
    // Create the built-in MASL types.
    self.Package_newDatatype(ep_pkg:self.systypes_pkg, type_name:s[i], definition:"");
    i = i - 1;
  end while;
  
end if;

',
	1,
	'',
	"32f13bee-f495-4551-8945-54c6bf7a0be4",
	0);
INSERT INTO O_TFR
	VALUES ("c01a916d-01b1-40d6-bb2f-932f1a2e6513",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'mergeDuplicateOperations',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// search for all O_TFRs in the scope and compare signatures. If the
// signatures are the same, copy the codeblock from this operation and
// dispose

op = self.current_class_op;

if ( not_empty op )
  select many o_tfrs related by op->O_OBJ[R115]->O_TFR[R115];
  for each o_tfr in o_tfrs 
    if ( o_tfr != op and self.Operation_getSignature( o_tfr:op ) == self.Operation_getSignature( o_tfr:o_tfr ) )
      // copy over the codeblock
      o_tfr.Action_Semantics_internal = op.Action_Semantics_internal;
      o_tfr.Dialect = op.Dialect;
      // dispose the operation
      self.Operation_dispose( o_tfr:op );
      break;
    end if;
  end for;
end if;',
	1,
	'',
	"95a50e75-8e96-4057-9cb6-a2a5cea06b80",
	0);
INSERT INTO O_TFR
	VALUES ("2ca94e70-3338-4ad6-9234-cad3073182f7",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'mergeDuplicateRoutines',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// search for all S_SYNCs or C_EPs in the scope and compare signatures. If the
// signatures are the same, copy the codeblock from this routine and dispose

function = self.current_domain_function;
message = self.current_executable_property;

if ( not_empty function )
  select many s_syncs related by function->PE_PE[R8001]->EP_PKG[R8000]->PE_PE[R8000]->S_SYNC[R8001];
  for each s_sync in s_syncs
    if ( s_sync != function and self.Function_getSignature( s_sync:function ) == self.Function_getSignature( s_sync:s_sync ) )
      // copy over the codeblock
      s_sync.Action_Semantics_internal = function.Action_Semantics_internal;
      s_sync.Dialect = function.Dialect;
      // dispose corresponding interface message
      if ( not_empty message )
        // in the case of "private" domain services, there will not be a corresponding c_ep instance
        // we need to check empty to keep from attempting to dispose an empty message
        self.ExecutableProperty_dispose( c_ep:message );
      end if;
      // dispose the function
      self.Function_dispose( s_sync:function );
      break;
    end if;
  end for;
elif ( not_empty message )
select many c_eps related by message->C_I[R4003]->C_EP[R4003];
  for each c_ep in c_eps
    if ( c_ep != message and self.ExecutableProperty_getSignature( c_ep:message ) == self.ExecutableProperty_getSignature( c_ep:c_ep ) )

      // copy over the codeblock
      string = message.Descrip;
      start_index = STRING::indexof( haystack:string, needle:"<codeblock>" );
      end_index = STRING::indexof( haystack:string, needle:"</codeblock>" );
      message_cb = "";
      if ( -1 != start_index and -1 != end_index )
        temp_cb = STRING::substr( s:string, begin:start_index+11, end:end_index );
        message_cb = STRING::escapetics(s:temp_cb);
      end if;

      if ( self.processingProject )
		select any spr_po related by c_ep->SPR_PEP[R4501]->SPR_PO[R4503];
		if ( not_empty spr_po )
		  spr_po.Action_Semantics_internal = spr_po.Action_Semantics_internal + message_cb;
		  spr_po.Dialect = ActionDialect::masl;
		end if;
      else
		select any spr_ro related by c_ep->SPR_REP[R4500]->SPR_RO[R4502];
		if ( not_empty spr_ro )
		  spr_ro.Action_Semantics_internal = spr_ro.Action_Semantics_internal + message_cb;
		  spr_ro.Dialect = ActionDialect::masl;
		end if;
  	  end if;
      // dispose interface message
      self.ExecutableProperty_dispose( c_ep:message );
      
      // update current 
      self.current_executable_property = c_ep;
      break;
    end if;
  end for;
end if;',
	1,
	'',
	"c01a916d-01b1-40d6-bb2f-932f1a2e6513",
	0);
INSERT INTO O_TFR
	VALUES ("543fd3ba-f9c9-4d89-b860-f49fb91aaff1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'populate',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	0,
	'// Populate OOAofOOA

element = param.element;

select any ooapopulation from instances of ooapopulation;
if ( empty ooapopulation )
  create object instance ooapopulation of ooapopulation;
  ooapopulation.processingIdentifier = 0;
  ooapopulation.processingISM = true;
  ooapopulation.processingProject = false;
end if;

// deal with pragma stack
if ( "" == param.value[0] and "" == param.value[1] and "" == param.value[2] and "" == param.value[3] and	// If all values are empty, it is
	 "" == param.value[4] and "" == param.value[5] and "" == param.value[6] and "" == param.value[7] )		// an end tag
  select one current_element related by ooapopulation->ooaelement[R3801];
  if ( not_empty current_element )
    if ( ooaelement::ismarkable( type: element ) )
	  select one markable related by current_element->ooamarkable[R3806];
	  markable.render_pragmas();
    end if;
    //ooaelement::trace( population: ooapopulation );
    current_element.pop_stack();
  else
    TRACE::log( flavor:"failure", id:55, message:"Element stack is malformed." );
    ooaelement::trace( population: ooapopulation ); 
  end if;
elif ( not ( "typeref" == element or 		// exclude leaf nodes in stack
  	   "referential" == element or
  	   "pragmaitem" == element or 
  	   "transition" == element or
  	   "expression" == element or
  	   "description" == element or
  	   "codeblock" == element ) )
  ooaelement::populate( population: ooapopulation, type: element );
end if;

// divert to project processing if we are processing a project
if ( "project" == element or ooapopulation.processingProject )
  ooapopulation::populate_project( element:param.element, value:param.value, ooapopulation:ooapopulation );
  return;
end if;

if ( "domain" == element )
  if ( "" == param.value[0] )
  	  // formalize the provided interface reference for the domain
  	  c_c = ooapopulation.current_component;
  	  lib_pkg = ooapopulation.lib_pkg;
  	  if ( not_empty c_c and not_empty lib_pkg )
    	select any shared_pkg related by lib_pkg->PE_PE[R8000]->EP_PKG[R8001] where (selected.Name == "Shared");
        comp_if_name = c_c.Name;
        select any comp_if related by shared_pkg->PE_PE[R8000]->C_I[R8001] where (selected.Name == comp_if_name);
  		select any new_ir related by comp_if->C_IR[R4012];
  		ooapopulation.InterfaceReference_formalize(c_i:comp_if, c_ir:new_ir);
  		// set the dialect of all the signals and operations of the provided domain interface to "None"
  		select many spr_pos related by new_ir->C_P[R4009]->SPR_PEP[R4501]->SPR_PO[R4503];
  		for each spr_po in spr_pos
  		  spr_po.Dialect = ActionDialect::none;
  		end for;
  		select many spr_pss related by new_ir->C_P[R4009]->SPR_PEP[R4501]->SPR_PO[R4503];
  		for each spr_ps in spr_pss
  		  spr_ps.Dialect = ActionDialect::none;
  		end for;
  	  end if;

      select any c_c from instances of C_C where (false);
      ooapopulation.current_component = c_c;
    
      // Now that we are done processing the domain, formalize relationships
      // TODO - does not work yet - if ( !processingProject ) ooapopulation.batchFormalize();
  else
    ooapopulation.transformDomain(name:param.value[0]);
  end if;
elif ( "object" == element )
  if ( "" == param.value[0] )
    select any o_obj from instances of O_OBJ where (false);
    ooapopulation.current_class = o_obj;
    ooapopulation.processingIdentifier = 0;
  else
    ooapopulation.transformObject(name:param.value[0]);
  end if;
elif ( "terminator" == element )
  if ( "" == param.value[0] )
  	// formalize the new interface reference to it
  	comp_if = ooapopulation.current_interface;
  	select any new_ir related by comp_if->C_IR[R4012];
  	ooapopulation.InterfaceReference_formalize(c_i:comp_if, c_ir:new_ir);
  	
  	// copy the codeblocks into the right locations
  	select many c_eps related by comp_if->C_EP[R4003];
  	for each c_ep in c_eps
      // copy over the codeblock
      string = c_ep.Descrip;
      start_index = STRING::indexof( haystack:string, needle:"<codeblock>" );
      end_index = STRING::indexof( haystack:string, needle:"</codeblock>" );
      message_cb = "";
      if ( -1 != start_index and -1 != end_index )
        temp_cb = STRING::substr( s:string, begin:start_index+11, end:end_index );
        message_cb = STRING::escapetics( s:temp_cb);
      end if;
      c_ep.Descrip = "";

      select any spr_ro related by c_ep->SPR_REP[R4500]->SPR_RO[R4502];
  	  if ( not_empty spr_ro )
        spr_ro.Action_Semantics_internal = spr_ro.Action_Semantics_internal + message_cb;
        if ( "" != spr_ro.Action_Semantics_internal )
          spr_ro.Dialect = ActionDialect::masl;
        end if;
  	  end if;
  	end for;

    select any c_i from instances of C_I where (false);
    ooapopulation.current_interface = c_i;
  else
    ooapopulation.transformTerminator(name:param.value[0]);
  end if;
elif ( "activity" == element )
  if ( "" != param.value[0] )
    ooapopulation.transformActivity();
  end if;
elif ( "parameter" == element )
  if ( "" == param.value[0] )
    select any s_sparm from instances of S_SPARM where (false);
    ooapopulation.current_function_param = s_sparm;
    select any o_tparm from instances of O_TPARM where (false);
    ooapopulation.current_operation_param = o_tparm;
    select any c_pp from instances of C_PP where (false);
    ooapopulation.current_interface_param = c_pp;
    select any sm_evtdi from instances of SM_EVTDI where (false);
    ooapopulation.current_event_dataitem = sm_evtdi;
    // TODO - null out other parameter cache values as they are implemented
  else
    ooapopulation.transformParameter(name:param.value[0], direction:param.value[1]);
  end if;
elif ( "identifier" == element )
  if ( "" != param.value[0] )
    // Note that this works in concert with object processing, which resets the processingIdentifier attribute to 0 when we
    // see the end of an object.  By setting back to 0, the following increment will mean any identifier specified with
    // "identifier is" will either be in I2 or I3
    ooapopulation.processingIdentifier = ooapopulation.processingIdentifier + 1;
    // Safety check to not exceed xtUML limit of 3 identifiers
    if ( 3 == ooapopulation.processingIdentifier )
      TRACE::log( flavor:"warning", id:59, message:"Maximum number of class identifiers reached.  Adding to I3." );
      ooapopulation.processingIdentifier = 2;
    end if;
  end if;
elif ( "attribute" == element )
  if ( "" == param.value[0] )
    select any o_attr from instances of O_ATTR where (false);
    ooapopulation.current_attribute = o_attr;
  else
    if ( ooapopulation.processingIdentifier >= 1 )
      // Set the named attribute as an identifier on the current_class.  NOTE that we assume here that the attribute
      //   has already been created inside the current class.
      o_obj = ooapopulation.current_class;
      // Check if the identifier specified is a referential attribute.   If it is, put the identifier number into the cache.
      // If it is not a referential, just make the attribute an identifier.
      select any ref_o_attr from instances of referentialAttribute where ( (selected.Name == param.value[0]) and (selected.o_obj == o_obj));
      if ( not_empty ref_o_attr )
        if ( 1 == ooapopulation.processingIdentifier )
          ref_o_attr.identifier2 = true;
        elif ( 2 == ooapopulation.processingIdentifier )
          ref_o_attr.identifier3 = true;
        end if;
      else
        select any o_attr related by o_obj->O_ATTR[R102] where ( selected.Root_Nam == param.value[0] );      
        ooapopulation.Attribute_addToIdentifier(o_attr:o_attr, oid:ooapopulation.processingIdentifier);
      end if;
    else
      ooapopulation.transformAttribute(name:param.value[0], preferred:param.value[1], unique:param.value[2]);
    end if;
  end if;
elif ( "referential" == element )
  ooapopulation.transformReferential(attrName:param.value[4], relationship:param.value[0], roleOrObj:param.value[2], objName:param.value[3]);
elif ( "state" == element )
  if ( "" == param.value[2] )
    select any sm_state from instances of SM_STATE where (false);
    ooapopulation.current_state = sm_state;
  else
    ooapopulation.transformState(name:param.value[2], type:param.value[3], domain:param.value[0], obj:param.value[1]);
  end if;
elif ( "event" == element )
  if ( "" == param.value[0] )
  	select any sm_evt from instances of SM_EVT where (false);
  	ooapopulation.current_event = sm_evt;
  else
    ooapopulation.transformEvent(name:param.value[0], type:param.value[1]);
  end if;
elif ( "exception" == element )
  if ( "" == param.value[0] )
    select any s_exp from instances of S_EXP where ( false );
    ooapopulation.current_exp = s_exp;
  else
    ooapopulation.transformException(name:param.value[0], visibility:param.value[1] );
  end if;
elif ( "type" == element )
  if ( "" == param.value[0] )
  	select any s_dt from instances of S_DT where (false);
  	ooapopulation.current_type = s_dt;
  else
    ooapopulation.transformType(name:param.value[0], visibility:param.value[1], definition:param.value[2]);
  end if;
elif ( "typeref" == element )
  if ( "" != param.value[0] )
    // TODO - note that we''re current making all typerefs public.  Perhaps we''ll need a mechanism to migrate them from public to private (and 
    //   rehome their parent package)?
    ooapopulation.transformType(name:param.value[0], visibility:"public", definition:"");
    
    // TODO - Now that we created a typeref, create a switch statement that sets whatever element we''re currently processing to the type
    //   cases: attribute, s_sync/o_tfr/c_io return type, s_sync/o_tfr/c_io parameter, etc
    o_attr = ooapopulation.current_attribute;
    s_sparm = ooapopulation.current_function_param;
    o_tparm = ooapopulation.current_operation_param;
    c_pp = ooapopulation.current_interface_param;
    sm_evtdi = ooapopulation.current_event_dataitem;
    o_tfr = ooapopulation.current_class_op;
    c_ep = ooapopulation.current_executable_property;
    s_sync = ooapopulation.current_domain_function;
    select one c_io related by c_ep->C_IO[R4004];

    if ( not_empty o_attr )
      ooapopulation.Attribute_setType(o_attr:ooapopulation.current_attribute, type_name:param.value[0]); 
    elif ( not_empty s_sparm )
      ooapopulation.FunctionParameter_setType(s_sparm:ooapopulation.current_function_param, type_name:param.value[0]); 
      // also set type for the corresponding interface message parameter
      if ( not_empty c_pp )
        ooapopulation.InterfaceParameter_setType(c_pp:ooapopulation.current_interface_param, type_name:param.value[0]);
      end if;
    elif ( not_empty o_tparm )
      ooapopulation.OperationParameter_setType(o_tparm:ooapopulation.current_operation_param, type_name:param.value[0]); 
    elif ( not_empty c_pp )
      ooapopulation.InterfaceParameter_setType(c_pp:ooapopulation.current_interface_param, type_name:param.value[0]);
    elif ( not_empty sm_evtdi )
      ooapopulation.StateMachineEventDataItem_setType(sm_evtdi:ooapopulation.current_event_dataitem, type_name:param.value[0]);
    elif ( not_empty o_tfr )
      ooapopulation.Operation_setReturnType(o_tfr:o_tfr, type_name:param.value[0]);
    elif ( not_empty s_sync )
      ooapopulation.Function_setReturnType(s_sync:s_sync, type_name:param.value[0]);
      // also set return type for the corresponding interface message
      if ( not_empty c_io )
        ooapopulation.InterfaceOperation_setReturnType(c_io:c_io, type_name:param.value[0]);
      end if;
    elif ( not_empty c_io )
      ooapopulation.InterfaceOperation_setReturnType(c_io:c_io, type_name:param.value[0]);
    end if;

  end if;
elif ( "associative" == element )
  if ( "" == param.value[0] )
    ooapopulation.transformAssociation();
    ooapopulation.clearRelationshipCache();
  else
    ooapopulation.current_rel.type = RELATIONSHIP_TYPE::ASSOCIATIVE;
    ooapopulation.current_rel.number = param.value[0];
    ooapopulation.current_rel.usingObj = param.value[2];
  end if;
elif ( "regularrel" == element )
  if ( "" == param.value[0] )
    ooapopulation.transformAssociation();
    ooapopulation.clearRelationshipCache();
  else
    ooapopulation.current_rel.type = RELATIONSHIP_TYPE::REGULAR;
    ooapopulation.current_rel.number = param.value[0];
  end if;
elif ( "subsuper" == element )
  if ( "" == param.value[0] )
    ooapopulation.transformAssociation();
    ooapopulation.clearRelationshipCache();
  else
    ooapopulation.current_rel.type = RELATIONSHIP_TYPE::SUBSUPER;
    ooapopulation.current_rel.number = param.value[0];
  end if;
elif ( "participation" == element )
  if ( "" != param.value[1] )
    isFirst = false;
    select any firstPart from instances of ooaparticipation where ( selected.isFirst == true );
    if ( empty firstPart )
      isFirst = true;
    end if;
    create object instance part of ooaparticipation;
    part.fromDomain = param.value[0];
    part.className = param.value[1];
    part.phrase = param.value[2];
    part.conditionality = ooaparticipation::getCond(text:param.value[3]);
    part.multiplicity = ooaparticipation::getMult(text:param.value[4]); 
    part.isFirst = isFirst;
  end if;
elif ( "routine" == element )
  //  See if we''re processing inside a domain or terminator.  Then call the appropriate conversion function.
  if ( "" == param.value[3] )
    // check for duplicate routines
    ooapopulation.mergeDuplicateRoutines();
    select any s_sync from instances of S_SYNC where ( false );
    ooapopulation.current_domain_function = s_sync;
    select any c_ep from instances of C_EP where ( false );
    ooapopulation.current_executable_property = c_ep;
    // Note that we do not clear self.current_interface here because if we are processing inside a terminator definition we
    //   will see multiple routines within the interface and we don''t want to clear out this cached interface after the 
    //   first routine we see.
  else
    c_i = ooapopulation.current_interface;
    if ( (not_empty c_i) or ( "" != param.value[1]) )
      ooapopulation.transformTerminatorService(visibility:param.value[2], name:param.value[3], domain:param.value[0], terminator:param.value[1]);
    else
      ooapopulation.transformDomainFunction(visibility:param.value[2], name:param.value[3], domain:param.value[0], terminator:param.value[1]);
    end if;
  end if;
elif ( "operation" == element )
  if ( "" == param.value[3] )
    // check for duplicate operations
    ooapopulation.mergeDuplicateOperations();
    select any o_tfr from instances of O_TFR where (false);
    ooapopulation.current_class_op = o_tfr;
  else
    ooapopulation.transformObjectFunction(visibility:param.value[2], name:param.value[3], instance:param.value[4], relationship:param.value[5], domain:param.value[0], obj:param.value[1]);
  end if;
elif ( "transitiontable" == element )
  if ( "assigner" == param.value[0] )
    ooapopulation.processingISM = false;
  else
    ooapopulation.processingISM = true;
  end if;
elif ( "transition" == element )
  ooapopulation.transformTransition(eventName:param.value[3], startState:param.value[0], endState:param.value[4], domain:param.value[1], object:param.value[2]);
elif ( "codeblock" == element )
  s_sync = ooapopulation.current_domain_function;
  if ( not_empty s_sync )
    s_sync.Action_Semantics_internal = s_sync.Action_Semantics_internal + STRING::escapetics(s:param.value[0]);
    s_sync.Dialect = ActionDialect::masl;
  end if;

  c_ep = ooapopulation.current_executable_property;
  if ( not_empty c_ep )
    // stash in Descrip field until formalization or merge
    c_ep.Descrip = c_ep.Descrip + "<codeblock>" + param.value[0] + "</codeblock>";
  end if;
  
  o_tfr = ooapopulation.current_class_op;
  if ( not_empty o_tfr )
    o_tfr.Action_Semantics_internal = o_tfr.Action_Semantics_internal + STRING::escapetics(s:param.value[0]);
    o_tfr.Dialect = ActionDialect::masl;
  end if;
  
  sm_state = ooapopulation.current_state;
  if ( not_empty sm_state )
    select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
    if ( not_empty sm_act )
      sm_act.Action_Semantics_internal = sm_act.Action_Semantics_internal + STRING::escapetics(s:param.value[0]);
      sm_act.Dialect = ActionDialect::masl;
    end if;
  end if;
  
  // TODO - handle code blocks for routines that are terminator services
elif ( "pragma" == element )
  if ( "" == param.value[0] )
    select any pragma from instances of ooapragma where (false);
    ooapopulation.current_pragma = pragma;
  else
  	select one parent_element related by ooapopulation->ooaelement[R3801]->ooaelement[R3805.''child of''];
  	if ( not_empty parent_element )
      if ( ooaelement::ismarkable( type: parent_element.type ) )		// ignore pragma if we are not on a markable element
        select one markable related by parent_element->ooamarkable[R3806];
        ooapopulation.current_pragma = ooapragma::populate( name:param.value[0], list:param.value[1], markable:markable );
      end if;
  	else
      TRACE::log( flavor:"failure", id:56, message:"Element stack is malformed." );
      ooaelement::trace( population: ooapopulation );
    end if;
  end if;
elif ( "pragmaitem" == element )
  select one current_element related by ooapopulation->ooaelement[R3801];
  if ( not_empty current_element )
    if ( "pragma" == current_element.type )	// ignore if not child of pragma
      ooapragma_item::populate( value:param.value[0], pragma:ooapopulation.current_pragma );
    end if;
  else
    TRACE::log( flavor:"failure", id:57, message:"Element stack is malformed." );
    ooaelement::trace( population: ooapopulation );
  end if;
elif ( "expression" == element )
  select one current_element related by ooapopulation->ooaelement[R3801];
  ooapopulation.transformExpression( element:current_element, text:param.value[0] );
elif ( "description" == element )
  select one current_element related by ooapopulation->ooaelement[R3801];
  ooapopulation.transformDescription( element:current_element, text:param.value[0], tag:param.value[1] );
else
  TRACE::log( flavor:"failure", id:59, message:"maslin unrecognized element:  " + element );
end if;
',
	1,
	'',
	"2ca94e70-3338-4ad6-9234-cad3073182f7",
	0);
INSERT INTO O_TPARM
	VALUES ("44c99ff0-0e60-4c08-ae69-dc4084e89e61",
	"543fd3ba-f9c9-4d89-b860-f49fb91aaff1",
	'element',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("221f1251-6af7-4f06-918c-3ab8ce08a4fa",
	"543fd3ba-f9c9-4d89-b860-f49fb91aaff1",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'[8]',
	"44c99ff0-0e60-4c08-ae69-dc4084e89e61",
	'');
INSERT INTO S_DIM
	VALUES (8,
	0,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"221f1251-6af7-4f06-918c-3ab8ce08a4fa",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"fd2d75cb-652d-4e8b-b1f0-b71487c55af6",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("5e51dc0b-b8d8-446e-b61c-8a799b2b7b17",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'populate_project',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	0,
	'// Populate OOAofOOA.

ooapopulation = param.ooapopulation;

if ( "project" == param.element )
  if ( "" != param.value[0] )
    ooapopulation.transformProject(name:param.value[0]);
    ooapopulation.processingProject = true;
  end if;
elif ( "domain" == param.element )
  if ( "" == param.value[0] )
    // If we are processing a project, all domains we see are handled as imported components, so clear that cache attribute
    select any cl_ic from instances of CL_IC where (false);
    ooapopulation.current_imported_component = cl_ic;
  else
    ooapopulation.transformDomain(name:param.value[0]);
  end if;
elif ( "terminator" == param.element )
  if ( "" == param.value[0] )
    // formalize the new interface reference to it
  	comp_if = ooapopulation.current_interface;
  	select any new_ir related by comp_if->C_IR[R4012];
  	ooapopulation.InterfaceReference_formalize(c_i:comp_if, c_ir:new_ir);
  	
    // Add "masl_temporary" to the description so the MASL
    // import processor knows to swap this interface
    // with the corresponding interface in the domain
  	comp_if.Descrip = comp_if.Descrip + "masl_temporary";
  	
  	// copy the codeblocks into the right locations
  	select many c_eps related by comp_if->C_EP[R4003];
  	for each c_ep in c_eps
      // copy over the codeblock
      string = c_ep.Descrip;
      start_index = STRING::indexof( haystack:string, needle:"<codeblock>" );
      end_index = STRING::indexof( haystack:string, needle:"</codeblock>" );
      message_cb = "";
      if ( -1 != start_index and -1 != end_index )
        temp_cb = STRING::substr( s:string, begin:start_index+11, end:end_index );
        message_cb = STRING::escapetics( s:temp_cb);
      end if;
      c_ep.Descrip = "";

      select any spr_po related by c_ep->SPR_PEP[R4501]->SPR_PO[R4503];
  	  if ( not_empty spr_po )
        spr_po.Action_Semantics_internal = spr_po.Action_Semantics_internal + message_cb;
        spr_po.Dialect = ActionDialect::masl;
  	  end if;
  	end for;

    select any c_i from instances of C_I where (false);
    ooapopulation.current_interface = c_i;
  else
    ooapopulation.transformTerminator(name:param.value[0]);
  end if;
elif ( "routine" == param.element )
  //  See if we''re processing inside a domain or terminator.  Then call the appropriate conversion function.
  if ( "" == param.value[3] )
    // check for duplicate routines
    ooapopulation.mergeDuplicateRoutines();
    select any c_ep from instances of C_EP where ( false );
    ooapopulation.current_executable_property = c_ep;
  else
    c_i = ooapopulation.current_interface;
    reset_current_interface = false;
    if ( empty c_i )
      comp_if_name = param.value[0] + param.value[1];
      select any c_i from instances of C_I where ( selected.Name == comp_if_name );
      ooapopulation.current_interface = c_i;
      reset_current_interface = true;  // if we have to artificially set the current_interface we have to flag to unset it
    end if;

    ooapopulation.transformTerminatorService(visibility:param.value[2], name:param.value[3], domain:param.value[0], terminator:param.value[1]);

    // if we artificially set the current interface, we have to unset it so we don''t mess
    // up the next routine
    if ( reset_current_interface )
      select any c_i from instances of C_I where false;
      ooapopulation.current_interface = c_i;
    end if;
  end if;
elif ( "parameter" == param.element )
  if ( "" == param.value[0] )
    select any c_pp from instances of C_PP where (false);
    ooapopulation.current_interface_param = c_pp;
  else
    ooapopulation.transformParameter(name:param.value[0], direction:param.value[1]);
  end if;
elif ( "typeref" == param.element )
  if ( "" != param.value[0] )
    ooapopulation.transformType(name:param.value[0], visibility:"public", definition:"");
    
    c_pp = ooapopulation.current_interface_param;
    c_ep = ooapopulation.current_executable_property;
    select one c_io related by c_ep->C_IO[R4004];
    if ( not_empty c_pp )
      ooapopulation.InterfaceParameter_setType(c_pp:ooapopulation.current_interface_param, type_name:param.value[0]);
    elif ( not_empty c_io )
      ooapopulation.InterfaceOperation_setReturnType(c_io:c_io, type_name:param.value[0]);
    end if;

  end if;
elif ( "codeblock" == param.element )
  c_ep = ooapopulation.current_executable_property;
  if ( not_empty c_ep )
    c_ep.Descrip = "<codeblock>" + param.value[0] + "</codeblock>";
  end if;
elif ( "pragma" == param.element )
  if ( "" == param.value[0] )
    select any pragma from instances of ooapragma where (false);
    ooapopulation.current_pragma = pragma;
  else
  	select one parent_element related by ooapopulation->ooaelement[R3801]->ooaelement[R3805.''child of''];
  	if ( not_empty parent_element )
      if ( ooaelement::ismarkable( type: parent_element.type ) )		// ignore pragma if we are not on a markable element
        select one markable related by parent_element->ooamarkable[R3806];
        ooapopulation.current_pragma = ooapragma::populate( name:param.value[0], list:param.value[1], markable:markable );
      end if;
  	else
      TRACE::log( flavor:"failure", id:56, message:"Element stack is malformed." );
      ooaelement::trace( population: ooapopulation );
    end if;
  end if;
elif ( "pragmaitem" == param.element )
  select one current_element related by ooapopulation->ooaelement[R3801];
  if ( not_empty current_element )
    if ( "pragma" == current_element.type )	// ignore if not child of pragma
      ooapragma_item::populate( value:param.value[0], pragma:ooapopulation.current_pragma );
    end if;
  else
    TRACE::log( flavor:"failure", id:57, message:"Element stack is malformed." );
    ooaelement::trace( population: ooapopulation );
  end if;
elif ( "description" == param.element )
  select one current_element related by ooapopulation->ooaelement[R3801];
  ooapopulation.transformDescription( element:current_element, text:param.value[0], tag:param.value[1] );
else
  // TRACE::log( flavor:"failure", id:59, message:"maslin unrecognized element:  " + element );
end if;
',
	1,
	'',
	"543fd3ba-f9c9-4d89-b860-f49fb91aaff1",
	0);
INSERT INTO O_TPARM
	VALUES ("97b4f367-7e18-4041-8918-29058878b711",
	"5e51dc0b-b8d8-446e-b61c-8a799b2b7b17",
	'element',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("9f515f51-f14a-4e24-bccd-7faaa577d8fe",
	"5e51dc0b-b8d8-446e-b61c-8a799b2b7b17",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'[8]',
	"97b4f367-7e18-4041-8918-29058878b711",
	'');
INSERT INTO S_DIM
	VALUES (8,
	0,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"9f515f51-f14a-4e24-bccd-7faaa577d8fe",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	"2f9dcbb0-a214-48a1-b612-b6d9c4708081",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TPARM
	VALUES ("89616648-196e-41b8-a199-0b051ccab6d7",
	"5e51dc0b-b8d8-446e-b61c-8a799b2b7b17",
	'ooapopulation',
	"cd5b4c41-ae8c-4d2b-b839-88084ebffd0e",
	0,
	'',
	"9f515f51-f14a-4e24-bccd-7faaa577d8fe",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cd5b4c41-ae8c-4d2b-b839-88084ebffd0e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ooapopulation>',
	'',
	'',
	'../m2x.xtuml');
INSERT INTO O_TFR
	VALUES ("f042b447-76dc-44d3-89ad-50afd7f4eb80",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformActivity',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	1,
	'',
	"5e51dc0b-b8d8-446e-b61c-8a799b2b7b17",
	0);
INSERT INTO O_TFR
	VALUES ("45e75564-9259-4619-9deb-5135b2da0b32",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformAssociation',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Get the package with the same name as the component, this is where we put the "internal behavior"
current_component = self.current_component;
select any internals_pkg related by current_component->PE_PE[R8003]->EP_PKG[R8001] where (selected.Name == current_component.Name);

select any assoc from instances of R_REL where false;
if (  self.current_rel.type == RELATIONSHIP_TYPE::ASSOCIATIVE )
  // Associative links are simple associations that are then migrated to be associative.  So here we 
  // create the simple association first.
  assoc = self.Package_newAssociation(ep_pkg:internals_pkg);
  self.Package_newAssociative(ep_pkg:internals_pkg);
elif ( self.current_rel.type == RELATIONSHIP_TYPE::REGULAR )
  assoc = self.Package_newAssociation(ep_pkg:internals_pkg); 
elif ( self.current_rel.type == RELATIONSHIP_TYPE::SUBSUPER )
  assoc = self.Package_newSubsuper(ep_pkg:internals_pkg); 
end if;

// store the description
if ( not_empty assoc )
  assoc.Descrip = assoc.Descrip + self.current_rel.description;
end if;
',
	1,
	'',
	"f042b447-76dc-44d3-89ad-50afd7f4eb80",
	0);
INSERT INTO O_TFR
	VALUES ("6f9e05a8-60cc-4e43-8691-4e035da60b18",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformAttribute',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'attr_name = param.name;

self.current_attribute = self.ModelClass_newAttribute(o_obj:self.current_class, attr_name:attr_name);

if ( "preferred" == param.preferred )
  self.Attribute_addToIdentifier(o_attr:self.current_attribute, oid:0);
end if;

if ( "unique" == param.unique )
  self.Attribute_setType(o_attr:self.current_attribute, type_name:"MASLunique");
end if;',
	1,
	'',
	"45e75564-9259-4619-9deb-5135b2da0b32",
	0);
INSERT INTO O_TPARM
	VALUES ("6e292849-4987-492a-a51b-ca2d4f1c0ef0",
	"6f9e05a8-60cc-4e43-8691-4e035da60b18",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("be54f4b6-3153-4b43-87ef-18dac578ab07",
	"6f9e05a8-60cc-4e43-8691-4e035da60b18",
	'preferred',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6e292849-4987-492a-a51b-ca2d4f1c0ef0",
	'');
INSERT INTO O_TPARM
	VALUES ("0bd74c72-d355-42eb-8d73-85fea95bdf3a",
	"6f9e05a8-60cc-4e43-8691-4e035da60b18",
	'unique',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"be54f4b6-3153-4b43-87ef-18dac578ab07",
	'');
INSERT INTO O_TFR
	VALUES ("5a7f2bf8-f192-420a-9e7b-bdec80b58b53",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformDescription',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'element = param.element;
text = STRING::escapetics(s:param.text);
tag = param.tag;

// choose where to put the description based on the element type
if ( "attribute" == element.type ) 
  attr = self.current_attribute;
  if ( not_empty attr )
    attr.Descrip = attr.Descrip + text;
  end if;
elif ( "terminator" == element.type )
  interface = self.current_interface;
  select any term related by interface->C_IR[R4012]->C_R[R4009];
  if ( not_empty term )
    term.Descrip = term.Descrip + text;
  end if;
elif ( "state" == element.type )
  state = self.current_state;
  select one sm_act related by state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  if ( not_empty sm_act )
    sm_act.Descrip = sm_act.Descrip + text;
  end if;
elif ( "routine" == element.type )
  routine1 = self.current_domain_function;
  if ( not_empty routine1 )
	routine1.Descrip = routine1.Descrip + text;
  else
    routine2 = self.current_executable_property;
    select one c_io related by routine2->C_IO[R4004];
	if ( not_empty c_io )
	  c_io.Descrip = c_io.Descrip + text;
	end if;
  end if;
elif ( "operation" == element.type )
  operation = self.current_class_op;
  if ( not_empty operation )
	operation.Descrip = operation.Descrip + text;
  end if;
elif ( "type" == element.type )
  type = self.current_type;
  if ( not_empty type )
	type.Descrip = type.Descrip + text;
  end if;
elif ( "domain" == element.type )
  if ( self.processingProject )
    domain = self.current_imported_component;
    if ( not_empty domain )
      domain.Descrip = domain.Descrip + text;
    end if;
  else
    domain = self.current_component;
    if ( not_empty domain )
      domain.Descrip = domain.Descrip + text;
    end if;
  end if;
elif ( "event" == element.type )
  evt = self.current_event;
  if ( not_empty evt )
	evt.Descrip = evt.Descrip + text;
  end if;
elif ( "object" == element.type )
  obj = self.current_class;
  if ( not_empty obj )
    obj.Descrip = obj.Descrip + text;
  end if;
elif ( "project" == element.type )
  project = self.current_component;
  if ( not_empty project )
    project.Descrip = project.Descrip + text;
  end if;
elif ( "subsuper" == element.type or "regularrel" == element.type or "associative" == element.type )
  self.current_rel.description = self.current_rel.description + text;
else
  TRACE::log( flavor:"warning", id:11, message:"description found for unsupported element" + element.type );
end if;',
	1,
	'',
	"6f9e05a8-60cc-4e43-8691-4e035da60b18",
	0);
INSERT INTO O_TPARM
	VALUES ("d0952a9d-8ed2-4e03-9864-bebba9777dbe",
	"5a7f2bf8-f192-420a-9e7b-bdec80b58b53",
	'element',
	"e5dfdb84-9b56-40db-b9da-9bfde06c573c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e5dfdb84-9b56-40db-b9da-9bfde06c573c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ooaelement>',
	'',
	'',
	'../../marking/marking.xtuml');
INSERT INTO O_TPARM
	VALUES ("77ccac14-0ec6-4ce8-a5f3-50105c3f2740",
	"5a7f2bf8-f192-420a-9e7b-bdec80b58b53",
	'text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d0952a9d-8ed2-4e03-9864-bebba9777dbe",
	'');
INSERT INTO O_TPARM
	VALUES ("ab64b939-59e0-457a-80cc-c507b5f350b6",
	"5a7f2bf8-f192-420a-9e7b-bdec80b58b53",
	'tag',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"77ccac14-0ec6-4ce8-a5f3-50105c3f2740",
	'');
INSERT INTO O_TFR
	VALUES ("0cf355a8-0e1f-4ee0-a895-b8ca2dc201bc",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformDomain',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'self.createSystem();

if ( self.processingProject )
  // Create a component reference in the project wiring package
  lib_pkg = self.lib_pkg;
  if ( not_empty lib_pkg )
    cl_ic = self.Package_newImportedComponent(ep_pkg:lib_pkg);
    cl_ic.Descrip = "name:" + param.name + "\n";
    cl_ic.Name = param.name;
    self.current_imported_component = cl_ic;
  end if;

  // Create an informal required interface off of the system wiring (project) component for the imported domain
  new_ir = self.Component_initializeRequirement(c_c:self.current_component, port_name:param.name, if_name:param.name);
else
  // Create a package named the same as the domain and cache it
  self.lib_pkg = self.SystemModel_newPackage(s_sys:self.current_sys, pkg_name:param.name);
  lib_pkg = self.lib_pkg;

  // Add "masl_domain" to the description so the MASL
  // import processor knows to perform MASL-specific processing.
  lib_pkg.Descrip = "masl_domain";

  // Create a component in the library package if it doesn''t already exist
  select any c_c related by lib_pkg->PE_PE[R8000]->C_C[R8001] where ( param.name == selected.Name );

  if ( empty c_c )
    // Create the component itself and a package inside it to hold the internal behavior
    c_c = self.Package_newComponent(ep_pkg:self.lib_pkg, component_name:param.name);
    internal_bhv_pkg = self.Component_newPackage(c_c:c_c, pkg_name:param.name);

    // Create a package to hold public bits that other components will need visibility to
    shared_pkg = self.Package_newPackage(ep_pkg:self.lib_pkg, package_name:"Shared");
  end if;

  self.current_component = c_c;
end if;
',
	1,
	'',
	"5a7f2bf8-f192-420a-9e7b-bdec80b58b53",
	0);
INSERT INTO O_TPARM
	VALUES ("19e23c6d-dace-4c81-8ae8-0b84bef08240",
	"0cf355a8-0e1f-4ee0-a895-b8ca2dc201bc",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("bd65150a-cc2c-4dda-a059-286310497b0b",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformDomainFunction',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// See if "functions" package exists in the component, create it if it does not.
current_component = self.current_component;
if ( empty current_component )
  select any current_component from instances of C_C where ( selected.Name == param.domain );
  if ( empty current_component )
    TRACE::log( flavor:"failure", id:121, message:"Service is defined with unrecognized domain:  " + param.domain );
  end if;
end if;

select any functions_pkg related by current_component->PE_PE[R8003]->EP_PKG[R8001] where (selected.Name == "functions");
if ( empty functions_pkg )
  functions_pkg = self.Component_newPackage(c_c:current_component, pkg_name:"functions");
end if;

// Create a domain function for the incoming function/service
self.current_domain_function = self.Package_newFunction(ep_pkg:functions_pkg, function_name: param.name);

// If the function/service is public:
//   a) get the "Shared" package under the library package.
//   b) see if there is an interface named "<comp name>", formalized to a port named (port name does not matter I think) 
//        on the component, create if not
//   c) create an interface operation identical to the domain function/service
//   d) modify the action body of the operation on the port to call the domain function/service
if ( "public" == param.visibility )
  // a
  lib_pkg = self.lib_pkg;
  select any shared_pkg related by lib_pkg->PE_PE[R8000]->EP_PKG[R8001] where (selected.Name == "Shared");

  // b
  comp_if_name = current_component.Name;
  select any comp_if related by shared_pkg->PE_PE[R8000]->C_I[R8001] where (selected.Name == comp_if_name);
  if ( empty comp_if )
	// create the interface
	comp_if = self.Package_newInterface(ep_pkg:shared_pkg, interface_name:comp_if_name);
	// create a port & provided interface from the component
	comp_port_name = current_component.Name;
	new_ir = self.Component_initializeProvision(c_c:current_component, port_name:comp_port_name, if_name:"");
	relate comp_if to new_ir across R4012;    // formalize at end tag of domain. for now, just relate it to the C_R
  end if;

  // c - Note that we (currently) always create an interface operation, never a signal
  c_ep = self.Interface_newExecutableProperty(c_i:comp_if, ep_name:param.name, asynchronous:false);
  c_ep.Direction = IFDirectionType::ClientServer;
  self.current_executable_property = c_ep;
end if;',
	1,
	'',
	"0cf355a8-0e1f-4ee0-a895-b8ca2dc201bc",
	0);
INSERT INTO O_TPARM
	VALUES ("5b0b1d1c-2905-4c58-892f-314db54544c3",
	"bd65150a-cc2c-4dda-a059-286310497b0b",
	'visibility',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("ae531f0c-e8eb-4c64-9ea4-7f0520011039",
	"bd65150a-cc2c-4dda-a059-286310497b0b",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5b0b1d1c-2905-4c58-892f-314db54544c3",
	'');
INSERT INTO O_TPARM
	VALUES ("b9f764af-5e62-46f7-851f-953d94c315bc",
	"bd65150a-cc2c-4dda-a059-286310497b0b",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ae531f0c-e8eb-4c64-9ea4-7f0520011039",
	'');
INSERT INTO O_TPARM
	VALUES ("cd082848-b882-45df-8700-71e2f83b8a94",
	"bd65150a-cc2c-4dda-a059-286310497b0b",
	'terminator',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"b9f764af-5e62-46f7-851f-953d94c315bc",
	'');
INSERT INTO O_TFR
	VALUES ("c9b348ee-4c8e-4f61-935d-5c8abd1fe5ea",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'current_class = self.current_class;

//  TODO - This currently doesn''t do anything with values other than assigner in the "type" parameter.  Needs to be
//    enhanced to handle these.

select any sm_sm from instances of SM_SM where ( false );
if ( "assigner" == param.type )
  sm_sm = self.ModelClass_create_sm(o_obj:current_class, sm_type:"ASM");
else
  sm_sm = self.ModelClass_create_sm(o_obj:current_class, sm_type:"ISM");
end if;

//  Create new xtUML state machine state
self.StateMachine_newEvent(sm_sm:sm_sm, name:param.name);

// Cache the current event
select any sm_evt related by sm_sm->SM_EVT[R502] where ( selected.Mning == param.name );
self.current_event = sm_evt;',
	1,
	'',
	"bd65150a-cc2c-4dda-a059-286310497b0b",
	0);
INSERT INTO O_TPARM
	VALUES ("ad266ae5-969c-40d4-ade6-60fe4e23988a",
	"c9b348ee-4c8e-4f61-935d-5c8abd1fe5ea",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("ea733f53-5767-46b9-8aef-364ead263b53",
	"c9b348ee-4c8e-4f61-935d-5c8abd1fe5ea",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"ad266ae5-969c-40d4-ade6-60fe4e23988a",
	'');
INSERT INTO O_TFR
	VALUES ("4d1a8157-4489-4b5b-9f75-6d745600639f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformException',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// If the exception visibility is public, put it in the package of shared public data.  If private, put it inside the component.
lib_pkg = self.lib_pkg;
select any types_pkg related by lib_pkg->PE_PE[R8000]->EP_PKG[R8001] where (selected.Name == "Shared");

if ( "private" == param.visibility )
  // Get the "types" package in this component
  current_component = self.current_component;
  select any types_pkg related by current_component->PE_PE[R8003]->EP_PKG[R8001] where (selected.Name == "types");

  // Create the types package if it doesn''t already exist
  if ( empty types_pkg )
    types_pkg = self.Component_newPackage(c_c:current_component, pkg_name:"types");
  end if;
end if;

// See if exception already exists
select any s_exp related by types_pkg->PE_PE[R8000]->S_EXP[R8001] where (selected.Name == param.name);

if ( empty s_exp )
  // The exception doesn''t already exist, create it
  s_exp = self.Package_newException(ep_pkg:types_pkg, name:param.name);
end if;

// cache the exception
self.current_exp = s_exp;
',
	1,
	'',
	"c9b348ee-4c8e-4f61-935d-5c8abd1fe5ea",
	0);
INSERT INTO O_TPARM
	VALUES ("78833352-794c-4131-83d4-b41ab886a0d6",
	"4d1a8157-4489-4b5b-9f75-6d745600639f",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("3ab67d65-8d07-44b9-a98c-9d30aba45217",
	"4d1a8157-4489-4b5b-9f75-6d745600639f",
	'visibility',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"78833352-794c-4131-83d4-b41ab886a0d6",
	'');
INSERT INTO O_TFR
	VALUES ("dd140de2-a608-4595-9e0d-414c2db97273",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformObject',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Create a Model Class with name if it doesn''t already exist, Put inside component''s "<component name>" pkg

// Get the package with the same name as the component, this is where we put the "internal behavior"
current_component = self.current_component;
select any internals_pkg related by current_component->PE_PE[R8003]->EP_PKG[R8001] where (selected.Name == current_component.Name);

// See if a model class already exists
select any o_obj related by internals_pkg->PE_PE[R8000]->O_OBJ[R8001] where (selected.Name == param.name);
self.current_class = o_obj;

if ( empty o_obj )
  // The object has not been declared already, create it
  self.current_class = self.Package_newClass(ep_pkg:internals_pkg, class_name: param.name); 
end if;

// TODO - this needs to work in concert with Package_newClass and ModelClass_initialize since the first time through 
//   could just be a forward declaration to an object.  Then the next time we see it we''ll be given more parameters
//   to configure the class with.  Thus, we need to do more work here to set the key letters, class number, etc if we
//   are given them as params.  Or, in the case where we saw the class defintion first then see another class declaration
//   later, we basically just do nothing and return.',
	1,
	'',
	"c3d66243-5c19-4457-aff7-0febc9498428",
	0);
INSERT INTO O_TPARM
	VALUES ("a210dbee-805b-46d2-b616-1f5524ddf658",
	"dd140de2-a608-4595-9e0d-414c2db97273",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("640afe09-21d3-4bf8-9e82-84e9b5c82978",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformObjectFunction',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'op_name = param.name;
current_class = self.current_class;


if ( empty current_class )
  // we don''t have a current class, so we have to go find one
  select any c_c from instances of C_C where ( selected.Name == param.domain );
  select any ep_pkg related by c_c->PE_PE[R8003]->EP_PKG[R8001] where ( selected.Name == param.domain );  // Internal behavior package has the same name as the component
  select any current_class related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where ( selected.Name == param.obj );
end if;

// create the new operation
self.current_class_op = self.ModelClass_newOperation(o_obj:current_class, op_name:op_name);
// set instance based or class based appropriately
if ( "instance" != param.instance )
  self.current_class_op.Instance_Based = Scope::Class;
end if;

// if deferred operation, set the dialect to None
if ( "" != param.relationship )
  self.current_class_op.Dialect = ActionDialect::none;
  self.current_class_op.Action_Semantics_internal = "Operation deferred to " + param.relationship;
end if;',
	1,
	'',
	"dd140de2-a608-4595-9e0d-414c2db97273",
	0);
INSERT INTO O_TPARM
	VALUES ("d6481943-e72c-4c31-b3ab-a1181a438fe3",
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	'visibility',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("06aa8ae8-97e5-4ef8-aac2-25709682b516",
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d6481943-e72c-4c31-b3ab-a1181a438fe3",
	'');
INSERT INTO O_TPARM
	VALUES ("f82596f2-b3e9-4d59-a7f8-fc52e2931805",
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	'instance',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"06aa8ae8-97e5-4ef8-aac2-25709682b516",
	'');
INSERT INTO O_TPARM
	VALUES ("4fae37a0-21f9-4d4d-ae45-acc4233c7a96",
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	'relationship',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f82596f2-b3e9-4d59-a7f8-fc52e2931805",
	'');
INSERT INTO O_TPARM
	VALUES ("a4c7a504-06e8-4d0f-b845-e9df2535f6ea",
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4fae37a0-21f9-4d4d-ae45-acc4233c7a96",
	'');
INSERT INTO O_TPARM
	VALUES ("172337d7-7619-44c3-8a09-fa6202a1cf85",
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	'obj',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a4c7a504-06e8-4d0f-b845-e9df2535f6ea",
	'');
INSERT INTO O_TFR
	VALUES ("f6d66828-c470-424c-89fb-2f7620de9b84",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformParameter',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Check to see what type of element this parameter goes to.  Pass control appropriately.
class_op = self.current_class_op;
domain_function = self.current_domain_function;
interface_message = self.current_executable_property;
evt = self.current_event;

if ( not_empty class_op )
  select any o_tparm related by class_op->O_TPARM[R117] where ( selected.Name == param.name );
  if ( empty o_tparm )
    self.current_operation_param = self.Operation_newParameter(o_tfr:class_op, parameter_name:param.name);
    if ( "in" == param.direction )
      self.current_operation_param.By_Ref = 0;	// by value
    elif ( "out" == param.direction )
      self.current_operation_param.By_Ref = 1;	// by ref
    end if;
  else
    self.current_operation_param = o_tparm;
  end if;
elif ( not_empty domain_function )
  select any s_sparm related by domain_function->S_SPARM[R24] where ( selected.Name == param.name );
  if ( empty  s_sparm )
    self.current_function_param = self.Function_newParameter(s_sync:domain_function, parameter_name:param.name);
    if ( "in" == param.direction )
      self.current_function_param.By_Ref = 0;	// by value
    elif ( "out" == param.direction )
      self.current_function_param.By_Ref = 1;	// by ref
    end if;
    // also create a parameter for the corresponding interface message
    if ( not_empty interface_message )
	  self.current_interface_param = self.Interface_newParameter(c_ep:interface_message, parameter_name:param.name);
	  if ( "in" == param.direction )
		self.current_interface_param.By_Ref = 0;	// by value
	  elif ( "out" == param.direction )
		self.current_interface_param.By_Ref = 1;	// by ref
	  end if;
    end if;
  else
    self.current_function_param = s_sparm;
  end if;
elif ( not_empty interface_message )
  select any c_pp related by interface_message->C_PP[R4006] where ( selected.Name == param.name );
  if ( empty c_pp )
    self.current_interface_param = self.Interface_newParameter(c_ep:interface_message, parameter_name:param.name);
    if ( "in" == param.direction )
      self.current_interface_param.By_Ref = 0;	// by value
    elif ( "out" == param.direction )
      self.current_interface_param.By_Ref = 1;	// by ref
    end if;
  else
    self.current_interface_param = c_pp;
  end if;
elif ( not_empty evt )
  select any sm_evtdi related by evt->SM_EVTDI[R532] where ( selected.Name == param.name );
  if ( empty sm_evtdi )
    self.current_event_dataitem = self.StateMachineEvent_newParameter( sm_evt:evt, parameter_name:param.name );
  else
    self.current_event_dataitem = sm_evtdi;
  end if;
end if;',
	1,
	'',
	"640afe09-21d3-4bf8-9e82-84e9b5c82978",
	0);
INSERT INTO O_TPARM
	VALUES ("5005ecee-a7b3-4786-859d-54286219a8c2",
	"f6d66828-c470-424c-89fb-2f7620de9b84",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("33958bc7-7c1b-41d5-88cd-554170d60e61",
	"f6d66828-c470-424c-89fb-2f7620de9b84",
	'direction',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5005ecee-a7b3-4786-859d-54286219a8c2",
	'');
INSERT INTO O_TFR
	VALUES ("7c08ec8a-e61f-4b71-b4b0-05ca78dd9fa5",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformProject',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// A MASL project is not the same as an xtUML project.  A MASL project is a system wiring specification.
// Due to the way the m2m population happens, we don''t know if we''ll see a project or domain definitions
// first.  Thus, we make sure an xtUML system is singlularly created no matter what comes first.
self.createSystem();

// Create a package named the same as the project and cache it
self.transformDomain(name:param.name);

lib_pkg = self.lib_pkg;
if ( not_empty lib_pkg )
  // Add "masl_project" to the description so the MASL
  // import processor knows to resolve the component
  // references and to create satisfactions automatically
  lib_pkg.Descrip = "masl_project";
end if;
',
	1,
	'',
	"f6d66828-c470-424c-89fb-2f7620de9b84",
	0);
INSERT INTO O_TPARM
	VALUES ("cec8c09b-9446-43a4-9289-12ad21094203",
	"7c08ec8a-e61f-4b71-b4b0-05ca78dd9fa5",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("4f731df8-629e-4323-8d8b-340f9adc8860",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformReferential',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select any ooapopulation from instances of ooapopulation;

// Create a new object in the referential cache
create object instance ra of referentialAttribute;
ra.attrName = param.attrName;
ra.relationship = param.relationship;
ra.roleOrObj = param.roleOrObj;
ra.objectName = param.objName;
ra.o_obj = ooapopulation.current_class;
ra.Name = ooapopulation.current_attribute.Root_Nam;
ra.baseless = false;

// Find out if the attribute was specified as being part of an identifier.  Cache
// that info.
ra.identifier1 = false;
ra.identifier2 = false;
ra.identifier3 = false;

o_attr = ooapopulation.current_attribute;
select many o_ids related by o_attr->O_OIDA[R105]->O_ID[R105];
for each o_id in o_ids
  if ( 0 == o_id.Oid_ID )
	ra.identifier1 = true;
  elif ( 1 == o_id.Oid_ID )
	ra.identifier2 = true;
  elif ( 2 == ooapopulation.processingIdentifier )
	ra.identifier3 = true;
  end if;
end for;

// add the referential attribute to a formalization
o_obj = ra.o_obj;
relNum = STRING::substr(s:ra.relationship,begin:1,end:-1);
relNumber = STRING::atoi(s:relNum); 
select any rel related by o_obj->PE_PE[R8001]->EP_PKG[R8000]->PE_PE[R8000]->R_REL[R8001] where (selected.Numb == relNumber);
select one simp related by rel->R_SIMP[R206];
if ( not_empty simp )
  // Get the correct participant
  select any r_part from instances of R_PART where false;
  if ( "" != ra.objectName )  	// get participant by role phrase AND object name
    select any ref_obj related by simp->R_PART[R207]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201] where (selected.Name == ra.objectName);
    select any r_part related by simp->R_PART[R207] where ( selected.Txt_Phrs == ra.roleOrObj and selected.Obj_ID == ref_obj.Obj_ID );
  else
    select any ref_obj related by simp->R_PART[R207]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201] where (selected.Name == ra.roleOrObj);
    if ( not_empty ref_obj ) 	// if we found an object by name, use the object name to get the r_part
      select any r_part related by simp->R_PART[R207] where ( selected.Obj_ID == ref_obj.Obj_ID );
    else						// otherwise, select by phrase only
      select any r_part related by simp->R_PART[R207] where ( selected.Txt_Phrs == ra.roleOrObj );
      if ( empty r_part )
        TRACE::log( flavor:"failure", id:101, message:"did not find formalization participant for " + ra.relationship );
      end if;
    end if;
  end if;
  
  // look for an existing formalization
  select any simpForm from instances of simpleFormalization where ( selected.rel == simp and
  																	selected.form_obj_id == o_obj.Obj_ID and
  																	selected.part_obj_id == r_part.Obj_ID );
  select one form related by simpForm->formalization[R3810];
  if ( empty form ) // create a formalization if it doesn''t exist
    create object instance form of formalization;
    form.type = 0;
    create object instance simpForm of simpleFormalization;
    simpForm.rel = simp;
    simpForm.form_obj_id = o_obj.Obj_ID;
    simpForm.part_obj_id = r_part.Obj_ID;
    relate form to simpForm across R3810;
  end if;
  
  // add this referential attribute to the formalization
  relate ra to form across R3811;

else
  select one subsuper related by rel->R_SUBSUP[R206];
  if ( not_empty subsuper )
    // look for an existing formalization
    select any subsupForm from instances of subsuperFormalization where ( selected.rel == subsuper );
	select one form related by subsupForm->formalization[R3810];
	if ( empty form ) // create a formalization if it doesn''t exist
	  create object instance form of formalization;
	  form.type = 1;
	  create object instance subsupForm of subsuperFormalization;
	  subsupForm.rel = subsuper;
	  relate form to subsupForm across R3810;
	end if;

    // add this referential attribute to the formalization
    relate ra to form across R3811;
  else
    select one linked related by rel->R_ASSOC[R206];
	if ( not_empty linked )
	  // look for an existing formalization
	  select any assocForm from instances of assocFormalization where ( selected.rel == linked );
	  select one form related by assocForm->formalization[R3810];
	  if ( empty form ) // create a formalization if it doesn''t exist
		create object instance form of formalization;
		form.type = 2;
		create object instance assocForm of assocFormalization;
		assocForm.rel = linked;
		relate form to assocForm across R3810;
	  end if;

	  // add this referential attribute to the formalization
	  relate ra to form across R3811;
	else
	  TRACE::log( flavor:"failure", id:102, message:"did not find relationship for " + ra.relationship );
	end if;
  end if;
end if;',
	1,
	'',
	"7c08ec8a-e61f-4b71-b4b0-05ca78dd9fa5",
	0);
INSERT INTO O_TPARM
	VALUES ("abd346a3-b332-4440-a752-a6c0fe7b2c94",
	"4f731df8-629e-4323-8d8b-340f9adc8860",
	'attrName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("afb54cfb-6258-4a7a-97a6-5400999fe0e9",
	"4f731df8-629e-4323-8d8b-340f9adc8860",
	'relationship',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"abd346a3-b332-4440-a752-a6c0fe7b2c94",
	'');
INSERT INTO O_TPARM
	VALUES ("0b2785c5-75a7-480c-ae0a-c08302b69045",
	"4f731df8-629e-4323-8d8b-340f9adc8860",
	'roleOrObj',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"afb54cfb-6258-4a7a-97a6-5400999fe0e9",
	'');
INSERT INTO O_TPARM
	VALUES ("953b9560-0369-4481-8a29-a0d15221940d",
	"4f731df8-629e-4323-8d8b-340f9adc8860",
	'objName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0b2785c5-75a7-480c-ae0a-c08302b69045",
	'');
INSERT INTO O_TFR
	VALUES ("a5e52691-f443-4bf5-a505-55acebd124fd",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformState',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'current_class = self.current_class;

if ( not_empty current_class )
  // We are in the midst of building a state machine inside a class definition.
  select any sm_sm from instances of SM_SM where ( false );
  if ( ("assigner" == param.type) or ("assigner start" == param.type) )
    sm_sm = self.ModelClass_create_sm(o_obj:current_class, sm_type:"ASM");
  else
    sm_sm = self.ModelClass_create_sm(o_obj:current_class, sm_type:"ISM");
  end if;

  //  Create new xtUML state machine state
  self.StateMachine_newState(sm_sm:sm_sm, name:param.name, type:param.type);

  // Cache the current state
  select any sm_state related by sm_sm->SM_STATE[R501] where ( selected.Name == param.name );
  self.current_state = sm_state;
else
  // No current_class.  That means we just need to find the given state and cache it so that the following 
  // SMASL can modify it.
  select any c_c from instances of C_C where ( selected.Name == param.domain );
  select any ep_pkg related by c_c->PE_PE[R8003]->EP_PKG[R8001] where ( selected.Name == param.domain );  // Internal behavior package has the same name as the component
  select any o_obj related by ep_pkg->PE_PE[R8000]->O_OBJ[R8001] where ( selected.Name == param.obj );
  
  // NOTE: We assume the are no state name collisions between the ISM and ASM.  We simply search for the named
  // state in the ISM first, then the ASM.
  select any sm_state related by o_obj->SM_ISM[R518]->SM_SM[R517]->SM_STATE[R501] where ( selected.Name == param.name );
  if ( empty sm_state )
    select any sm_state related by o_obj->SM_ASM[R519]->SM_SM[R517]->SM_STATE[R501] where ( selected.Name == param.name );
  end if;
  self.current_state = sm_state;  
end if;',
	1,
	'',
	"4f731df8-629e-4323-8d8b-340f9adc8860",
	0);
INSERT INTO O_TPARM
	VALUES ("20f99d67-348b-4f8b-8606-515c24294413",
	"a5e52691-f443-4bf5-a505-55acebd124fd",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("114e50bd-1490-4a0d-992e-3c1b0aa5d8c1",
	"a5e52691-f443-4bf5-a505-55acebd124fd",
	'type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"20f99d67-348b-4f8b-8606-515c24294413",
	'');
INSERT INTO O_TPARM
	VALUES ("40dfb1c0-13b7-4391-9211-c982fb3d2044",
	"a5e52691-f443-4bf5-a505-55acebd124fd",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"114e50bd-1490-4a0d-992e-3c1b0aa5d8c1",
	'');
INSERT INTO O_TPARM
	VALUES ("8175c888-2c16-47b3-8a72-e82968a6e01c",
	"a5e52691-f443-4bf5-a505-55acebd124fd",
	'obj',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"40dfb1c0-13b7-4391-9211-c982fb3d2044",
	'');
INSERT INTO O_TFR
	VALUES ("e72b0790-f1d2-43dc-8910-64c922dc45f3",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformTerminator',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'lib_pkg = self.lib_pkg;

if ( self.processingProject )
  // Create provided interface off of the system wiring (project) component for this terminator.
  current_imported = self.current_imported_component;
  if ( not_empty current_imported )
    clic_name = current_imported.Name;
      comp_if_name = clic_name + param.name;

	  select any shared_pkg related by lib_pkg->PE_PE[R8000]->EP_PKG[R8001] where (selected.Name == "Shared");

	  select any comp_if related by shared_pkg->PE_PE[R8000]->C_I[R8001] where (selected.Name == comp_if_name);
	  if ( empty comp_if )
		// create the interface
		comp_if = self.Package_newInterface(ep_pkg:shared_pkg, interface_name:comp_if_name);
	  end if;
		new_ir = self.Component_initializeProvision(c_c:self.current_component, port_name:clic_name + "__" + param.name, if_name:comp_if_name);
		relate comp_if to new_ir across R4012;    // formalize at end tag. for now, just relate it to the C_P

	  self.current_interface = comp_if;
  end if;
else
  comp_if_name = self.current_component.Name + param.name;

  select any shared_pkg related by lib_pkg->PE_PE[R8000]->EP_PKG[R8001] where (selected.Name == "Shared");

  select any comp_if related by shared_pkg->PE_PE[R8000]->C_I[R8001] where (selected.Name == comp_if_name);
  if ( empty comp_if )
    // create the interface
    comp_if = self.Package_newInterface(ep_pkg:shared_pkg, interface_name:comp_if_name);
    // create a port & provided interface from the component
    comp_port_name = param.name;
    new_ir = self.Component_initializeRequirement(c_c:self.current_component, port_name:comp_port_name, if_name:"");
    relate comp_if to new_ir across R4012;    // formalize at end tag. for now, just relate it to the C_R
  end if;

  self.current_interface = comp_if;
end if;
',
	1,
	'',
	"a5e52691-f443-4bf5-a505-55acebd124fd",
	0);
INSERT INTO O_TPARM
	VALUES ("0a63af38-e76d-410f-a81b-9b26323b4240",
	"e72b0790-f1d2-43dc-8910-64c922dc45f3",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("c5c40ced-e08c-451c-b595-be8c3eb3766e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformTerminatorService',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'c_i = self.current_interface;

if ( empty c_i )
  select any c_c from instances of C_C where ( selected.Name == param.domain );
  select any c_po related by c_c->C_PO[R4010] where ( selected.Name == param.terminator );
  select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
end if;
if ( empty c_i )
  TRACE::log( flavor:"warning", id:259, message:"empty interface:  " + param.domain + " " + param.terminator );
end if;

c_ep = self.Interface_newExecutableProperty(c_i:c_i, ep_name:param.name, asynchronous:false);
c_ep.Direction = IFDirectionType::ClientServer;
self.current_executable_property = c_ep;',
	1,
	'',
	"e72b0790-f1d2-43dc-8910-64c922dc45f3",
	0);
INSERT INTO O_TPARM
	VALUES ("c896ed0e-9181-4733-9a5b-483c566477f3",
	"c5c40ced-e08c-451c-b595-be8c3eb3766e",
	'visibility',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("9ca17b41-18dc-4d67-9b8a-941126be6054",
	"c5c40ced-e08c-451c-b595-be8c3eb3766e",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c896ed0e-9181-4733-9a5b-483c566477f3",
	'');
INSERT INTO O_TPARM
	VALUES ("1ebcbb00-ed6b-450c-a52b-4e26681c4dbf",
	"c5c40ced-e08c-451c-b595-be8c3eb3766e",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9ca17b41-18dc-4d67-9b8a-941126be6054",
	'');
INSERT INTO O_TPARM
	VALUES ("e73633fa-f710-439a-a45a-f66a5fdea7e5",
	"c5c40ced-e08c-451c-b595-be8c3eb3766e",
	'terminator',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"1ebcbb00-ed6b-450c-a52b-4e26681c4dbf",
	'');
INSERT INTO O_TFR
	VALUES ("36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformTransition',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'current_class = self.current_class;

select any sm_sm from instances of SM_SM where ( false );

if ( true == self.processingISM )
  select one sm_sm related by current_class->SM_ISM[R518]->SM_SM[R517];
else
  select one sm_sm related by current_class->SM_ASM[R519]->SM_SM[R517];
end if;

// NON_EXISTENT: ''Non_Existent'' | ''Non_Existant'' | ''non_existent'';
if ( ("Non_Existent" == param.startState) or ("Non_Existant" == param.startState) or ("non_existent" == param.startState) )
  self.StateMachine_newCreationTransition(sm_sm: sm_sm, eventName:param.eventName, endState:param.endState, objectName:param.object);
else
  self.StateMachine_newTransition(sm_sm: sm_sm, eventName:param.eventName, startState:param.startState, endState:param.endState, domain:param.domain, object:param.object);
end if;
',
	1,
	'',
	"c5c40ced-e08c-451c-b595-be8c3eb3766e",
	0);
INSERT INTO O_TPARM
	VALUES ("59cd4fe0-e00f-4f47-a3cf-f0a1585c8ed1",
	"36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	'eventName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("0e60c7c6-3d6b-4b45-8d8f-1cca8ab0963e",
	"36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	'startState',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"59cd4fe0-e00f-4f47-a3cf-f0a1585c8ed1",
	'');
INSERT INTO O_TPARM
	VALUES ("a53f2614-67a8-4993-8d58-ec3d02e6b4fc",
	"36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	'endState',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0e60c7c6-3d6b-4b45-8d8f-1cca8ab0963e",
	'');
INSERT INTO O_TPARM
	VALUES ("6d935ac3-9bca-4ce4-8628-ad616c14626b",
	"36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	'domain',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a53f2614-67a8-4993-8d58-ec3d02e6b4fc",
	'');
INSERT INTO O_TPARM
	VALUES ("fde78567-6be0-4ebc-8e1a-76b392cfb029",
	"36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	'object',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6d935ac3-9bca-4ce4-8628-ad616c14626b",
	'');
INSERT INTO O_TFR
	VALUES ("2d5d9e9c-ab6b-473f-93bf-90f3fe4e48e8",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformType',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// If the type visibility is public, put it in the package of shared public data.  If private, put it inside the component.
lib_pkg = self.lib_pkg;
select any types_pkg related by lib_pkg->PE_PE[R8000]->EP_PKG[R8001] where (selected.Name == "Shared");

if ( "private" == param.visibility )
  // Get the "types" package in this component
  current_component = self.current_component;
  select any types_pkg related by current_component->PE_PE[R8003]->EP_PKG[R8001] where (selected.Name == "types");

  // Create the types package if it doesn''t already exist
  if ( empty types_pkg )
    types_pkg = self.Component_newPackage(c_c:current_component, pkg_name:"types");
  end if;
end if;

// See if type already exists
systypes_pkg = self.systypes_pkg;
globaltypes_pkg = self.globaltypes_pkg;
select any sys_s_dt related by systypes_pkg->PE_PE[R8000]->S_DT[R8001] where (selected.Name == param.name);
select any s_dt related by types_pkg->PE_PE[R8000]->S_DT[R8001] where (selected.Name == param.name);
select any global_dt related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001] where ( selected.Name == param.name );
if ( (empty sys_s_dt) and (empty s_dt) and (empty global_dt) )
  // The type doesn''t already exist, create it
  self.Package_newDatatype(ep_pkg:types_pkg, type_name:param.name, definition:param.definition);
  // Cache the new type
  select any s_dt related by types_pkg->PE_PE[R8000]->S_DT[R8001] where (selected.Name == param.name);
  self.current_type = s_dt;
else
  // Cache the existing type
  if ( not_empty sys_s_dt )
    self.current_type = sys_s_dt;
  elif ( not_empty s_dt )
    self.current_type = s_dt;
    // update the type definition
    if ( "" != param.definition )
      select one s_udt related by s_dt->S_UDT[R17];
      if ( not_empty s_udt )
        s_udt.Definition = param.definition;
      end if;
    end if;
  elif ( not_empty global_dt )
    self.current_type = global_dt;
  end if;
end if;
',
	1,
	'',
	"36eeccdf-c8b7-428f-9d44-bb36f2619b92",
	0);
INSERT INTO O_TPARM
	VALUES ("482b3b13-c580-41cc-81bb-67872811d331",
	"2d5d9e9c-ab6b-473f-93bf-90f3fe4e48e8",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("9a44268b-b384-4692-8f79-30b65cf7e927",
	"2d5d9e9c-ab6b-473f-93bf-90f3fe4e48e8",
	'visibility',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"482b3b13-c580-41cc-81bb-67872811d331",
	'');
INSERT INTO O_TPARM
	VALUES ("0a9819c5-294d-4b9b-b438-96b9b3ccd859",
	"2d5d9e9c-ab6b-473f-93bf-90f3fe4e48e8",
	'definition',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9a44268b-b384-4692-8f79-30b65cf7e927",
	'');
INSERT INTO O_TFR
	VALUES ("c3d66243-5c19-4457-aff7-0febc9498428",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'transformExpression',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'element = param.element;
text = STRING::escapetics(s:param.text);

// choose where to put the expression based on the element type
if ( "attribute" == element.type ) 
  attr = self.current_attribute;
  if ( not_empty attr )
    attr.DefaultValue = text;
  end if;
else
  TRACE::log( flavor:"warning", id:111, message:"expression found for unsupported element" + element.type );
end if;
',
	1,
	'',
	"4d1a8157-4489-4b5b-9f75-6d745600639f",
	0);
INSERT INTO O_TPARM
	VALUES ("da42c5db-51eb-476b-b3bd-58a0495a75c9",
	"c3d66243-5c19-4457-aff7-0febc9498428",
	'element',
	"e5dfdb84-9b56-40db-b9da-9bfde06c573c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("eba96f10-3d87-41d9-9a89-2940daa7574b",
	"c3d66243-5c19-4457-aff7-0febc9498428",
	'text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"da42c5db-51eb-476b-b3bd-58a0495a75c9",
	'');
INSERT INTO O_TFR
	VALUES ("95a50e75-8e96-4057-9cb6-a2a5cea06b80",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// dispose global types package
globaltypes_pkg = self.globaltypes_pkg;
select many global_types related by globaltypes_pkg->PE_PE[R8000]->S_DT[R8001];
for each global_type in global_types
  select one s_cdt related by global_type->S_CDT[R17];
  if ( not_empty s_cdt )
    unrelate s_cdt from global_type across R17;
    delete object instance s_cdt;
  else
    select one s_udt related by global_type->S_UDT[R17];
    if ( not_empty s_udt )
      select one core_type related by s_udt->S_DT[R18];
      unrelate core_type from s_udt across R18;
      unrelate s_udt from global_type across R17;
      delete object instance s_udt;
    end if;
  end if;
  select one global_type_pe related by global_type->PE_PE[R8001];
  unrelate global_type from global_type_pe across R8001;
  delete object instance global_type;
  unrelate global_type_pe from globaltypes_pkg across R8000;
  delete object instance global_type_pe;
end for;
delete object instance globaltypes_pkg;

delete object instance self;',
	1,
	'',
	"d575fa93-3488-4bc0-ab38-d6aff10a2894",
	0);
INSERT INTO O_TFR
	VALUES ("88689cb1-bdb5-4c16-8ee5-3518ac8b2fa6",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_migrateToPoly',
	'',
	"a3a5646e-4d65-483e-a54f-449c5e6fe097",
	1,
	'sm_evt = param.sm_evt;
select one sm_sevt related by sm_evt->SM_SEVT[R525];
// Dispose of the event matrix entries.
select many sm_semes related by sm_sevt->SM_SEME[R503];
for each sm_seme in sm_semes
  select one sm_state related by sm_seme->SM_STATE[R503];
  unrelate sm_state from sm_sevt across R503 using sm_seme;
  select one sm_ch related by sm_seme->SM_CH[R504];
  if ( not_empty sm_ch )
    unrelate sm_ch from sm_seme across R504;
    delete object instance sm_ch;
    delete object instance sm_seme;
  else
    TRACE::log( flavor:"failure", id:158, message:"Did not find SM_SEME when we thought we should migrating event:  " + sm_evt.Mning );
  end if;
end for;
select one sm_levt related by sm_sevt->SM_LEVT[R526];
if ( not_empty sm_levt )
  unrelate sm_levt from sm_sevt across R526;
  delete object instance sm_levt;
else
  TRACE::log( flavor:"failure", id:159, message:"Did not find SM_LEVT when we thought we should migrating event:  " + sm_evt.Mning );
end if;
unrelate sm_evt from sm_sevt across R525;
delete object instance sm_sevt;
create object instance sm_pevt of SM_PEVT;
relate sm_evt to sm_pevt across R525;
return sm_pevt;',
	1,
	'',
	"5329e43f-743a-4151-83c3-5cc30b20d505",
	0);
INSERT INTO O_TPARM
	VALUES ("21630e04-b4cf-44bb-97ff-46516ea20a5d",
	"88689cb1-bdb5-4c16-8ee5-3518ac8b2fa6",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a3a5646e-4d65-483e-a54f-449c5e6fe097",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Polymorphic Event>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO O_TFR
	VALUES ("eaba961e-3074-43c5-84d1-2bc13ddd73f0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachine_syncPolymorphicEvents',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sm = param.sm_sm;

// When using concrete polymorphic events, all events are polymorphic and
// should appear in each subtype state event matrix, even if they are not
// assigned to any transition in the state machine
select one modelClass related by sm_sm->SM_ISM[R517]->O_OBJ[R518];
select many supertypes related by modelClass->R_OIR[R201]->R_RGO[R203]->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
while ( not_empty supertypes )
  for each supertype in supertypes
    select one machine related by supertype->SM_ISM[R518]->SM_SM[R517];
    select many local_evts related by machine->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526];
    for each local_evt in local_evts
      select one crtxn related by local_evt->SM_CRTXN[R509];
      if ( empty crtxn ) // exclude creation events
        select one evt related by local_evt->SM_SEVT[R526]->SM_EVT[R525];
        evt_id = self.StateMachineEvent_getAssociatedEventForStateMachine( sm_evt:evt, stateMachineId:sm_sm.SM_ID ); // this call will cause the SM_NLEVT instance to be created
                                                                                     // and the SEM column to be initialized if it is not already
      end if;
    end for;
    select many polymorphic_evts related by machine->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525];
    for each evt in polymorphic_evts
      evt_id = self.StateMachineEvent_getAssociatedEventForStateMachine( sm_evt:evt, stateMachineId:sm_sm.SM_ID ); // this call will cause the SM_NLEVT instance to be created
                                                                                   // and the SEM column to be initialized if it is not already
    end for;
  end for;
  select many supertypes related by supertypes->R_OIR[R201]->R_RGO[R203]->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
end while;
// sync subtype state machines
select many subtypes related by modelClass->R_OIR[R201]->R_RTO[R203]->R_SUPER[R204]->R_SUBSUP[R212]->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
for each subtype in subtypes
  select one machine related by subtype->SM_ISM[R518]->SM_SM[R517];
  self.StateMachine_syncPolymorphicEvents( sm_sm:machine );
end for;',
	1,
	'',
	"9441f59a-81c9-4794-b2f6-7bc381db1928",
	0);
INSERT INTO O_TPARM
	VALUES ("533b6a11-7fdd-4a97-8b5f-4cb6a1eb15c1",
	"eaba961e-3074-43c5-84d1-2bc13ddd73f0",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("a9ad25b0-ca1a-425e-88ba-a16d259a6e9e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'StateMachineEvent_getAssociatedEventForStateMachine',
	'',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'sm_evt = param.sm_evt;

/*
Returns an event related to this one that applies to the given state
machine.  If the given state machine is the one to which this event belongs,
then this event is returned.  Else, if this event is polymorphic,
the alias associated with the given state machine is returned (with one being
created if it doesnt already exist).  Otherwise, this event is made
polymorphic, and an alias for the given state machine is created and
returned.
*/

// if this event is directly associated with the given state machine
if (sm_evt.SM_ID == param.stateMachineId)
  // return this event
  select one poly related by sm_evt->SM_PEVT[R525];
  if ( empty poly )
    return sm_evt.SMevt_ID;
  end if;
end if;

// if this event is polymorphic
select any machine from instances of SM_SM
  where selected.SM_ID == param.stateMachineId;
select one polyEvent related by sm_evt->SM_PEVT[R525];
if (not_empty polyEvent)
  // if there is an aliasing non-local event associated
  // with the given state machine
  select any nonLocalEvent related by polyEvent->SM_NLEVT[R527]
    where selected.SM_ID == machine.SM_ID;
  if (not_empty nonLocalEvent)
    // return that event
    return nonLocalEvent.SMevt_ID;

  // otherwise
  else
    // create an aliasing non-local event, and return it
    return self.PolymorphicEvent_createNonLocalEventForStateMachine(sm_pevt:polyEvent, stateMachineId:machine.SM_ID);
  end if;

// otherwise
else
  // dispose this events associated local and event-matrix event instances
  select one matrixEvent related by sm_evt->SM_SEVT[R525];
  self.SEMEvent_migrateToLocalPoly(sm_sevt:matrixEvent);

  // get the polymorphic event
  select one polyEvent related by matrixEvent->SM_NLEVT[R526]->SM_PEVT[R527];
  
  // create a non-local event to alias the above polymorphic event, and return it
  return self.PolymorphicEvent_createNonLocalEventForStateMachine(sm_pevt:polyEvent, stateMachineId:machine.SM_ID);
end if;',
	1,
	'',
	"1c2e1c38-0c0b-4f89-b68e-e08da29540ea",
	0);
INSERT INTO O_TPARM
	VALUES ("044e3b34-5bd6-481e-8ffe-500a7d1e1619",
	"a9ad25b0-ca1a-425e-88ba-a16d259a6e9e",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("39795ddd-b36d-4f4b-b768-14523d0e3899",
	"a9ad25b0-ca1a-425e-88ba-a16d259a6e9e",
	'stateMachineId',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"044e3b34-5bd6-481e-8ffe-500a7d1e1619",
	'');
INSERT INTO O_TFR
	VALUES ("132437da-61c8-4fe6-a112-744ee0bd386b",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'PolymorphicEvent_createNonLocalEventForStateMachine',
	'',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'sm_pevt = param.sm_pevt;
/*
Creates (and returns the ID of) a non-local event that is an alias of this
polymorphic event for the given state machine.
*/

// create a non-local event to alias this polymorphic event
create object instance nonlocalEvent of SM_NLEVT;

// create the supertype instances of the above non-local event,
// and copy into them the attribute values of the corresponding
// instances of this polymorphic event
create object instance matrixEvent of SM_SEVT;
create object instance newEvent of SM_EVT;
select one event related by sm_pevt->SM_EVT[R525];
newEvent.Numb = event.Numb;
newEvent.Mning = event.Mning;
newEvent.Is_Lbl_U = event.Is_Lbl_U;
newEvent.Unq_Lbl = event.Unq_Lbl;
newEvent.Descrip = event.Descrip;
select any machine from instances of SM_SM
   where selected.SM_ID == param.stateMachineId;
relate newEvent to machine across R502;
relate newEvent to matrixEvent across R525;
relate matrixEvent to nonlocalEvent across R526;
relate nonlocalEvent to sm_pevt across R527;
self.SEMEvent_createDefaultMatrixEntries( sm_sevt:matrixEvent );

return newEvent.SMevt_ID;',
	1,
	'',
	"451f3aa2-7a66-433f-ba52-689d7edd71e8",
	0);
INSERT INTO O_TPARM
	VALUES ("6f4cd6f7-bdac-4c4e-8efe-94d86cdb848b",
	"132437da-61c8-4fe6-a112-744ee0bd386b",
	'sm_pevt',
	"a3a5646e-4d65-483e-a54f-449c5e6fe097",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("5ce85523-52a6-4fc4-b8ea-fb905043f293",
	"132437da-61c8-4fe6-a112-744ee0bd386b",
	'stateMachineId',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"6f4cd6f7-bdac-4c4e-8efe-94d86cdb848b",
	'');
INSERT INTO O_TFR
	VALUES ("7d6ac7ae-dc34-4e4c-aa7e-d9c072d06138",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	'SEMEvent_migrateToLocalPoly',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'sm_sevt = param.sm_sevt;
select one orig_evt related by sm_sevt->SM_EVT[R525];

select one sm_levt related by sm_sevt->SM_LEVT[R526];
if ( empty sm_levt )
  TRACE::log( flavor:"failure", id:158, message:"Cannot migrate non-local event to local poly: " + orig_evt.Mning );
else
  select one sm_crtxn related by sm_levt->SM_CRTXN[R509];
  if ( not_empty sm_crtxn )
    TRACE::log( flavor:"failure", id:157, message:"Cannot migrate event that is assigned to a creation transition: " + orig_evt.Mning );
  else
    // unhook local event and dispose
    unrelate sm_levt from sm_sevt across R526;
    delete object instance sm_levt;
    
    // create polymorphic event
    create object instance sm_evt of SM_EVT;
    create object instance sm_pevt of SM_PEVT;
    sm_evt.Numb = orig_evt.Numb;
    sm_evt.Mning = orig_evt.Mning;
    sm_evt.Is_Lbl_U = orig_evt.Is_Lbl_U;
    sm_evt.Unq_Lbl = orig_evt.Unq_Lbl;
    sm_evt.Descrip = orig_evt.Descrip;
    select one sm related by sm_sevt->SM_EVT[R525]->SM_SM[R502];
    relate sm_evt to sm across R502;
    relate sm_pevt to sm_evt across R525;
    
    // move parameters to the poly
    select many sm_evtdis related by orig_evt->SM_EVTDI[R532];
    for each sm_evtdi in sm_evtdis
      unrelate sm_evtdi from orig_evt across R532;
      relate sm_evtdi to sm_evt across R532;
    end for;
    
    // create new non-local event
    create object instance sm_nlevt of SM_NLEVT;
    relate sm_nlevt to sm_sevt across R526;
    relate sm_nlevt to sm_pevt across R527;
  end if;
end if;',
	1,
	'',
	"017203cc-b51e-4efa-b6c6-7acc8a12c42b",
	0);
INSERT INTO O_TPARM
	VALUES ("5bdf31bb-4dc0-422d-8c48-e892e99d2888",
	"7d6ac7ae-dc34-4e4c-aa7e-d9c072d06138",
	'sm_sevt',
	"e62eb4e0-7b0c-4f70-877e-0192af434e3a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_NBATTR
	VALUES ("65062455-b226-4503-a876-a0cbd652b56e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("65062455-b226-4503-a876-a0cbd652b56e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("65062455-b226-4503-a876-a0cbd652b56e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"00000000-0000-0000-0000-000000000000",
	'current_sys',
	'',
	'',
	'current_sys',
	0,
	"4b886601-55ee-4d42-a1f8-f5c45d459db2",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("28c2af63-945d-458f-ac74-a51dc042d072",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("28c2af63-945d-458f-ac74-a51dc042d072",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("28c2af63-945d-458f-ac74-a51dc042d072",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"65062455-b226-4503-a876-a0cbd652b56e",
	'lib_pkg',
	'',
	'',
	'lib_pkg',
	0,
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("d97ed044-ca29-43b4-984c-07f8fcb4ee9f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("d97ed044-ca29-43b4-984c-07f8fcb4ee9f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("d97ed044-ca29-43b4-984c-07f8fcb4ee9f",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"28c2af63-945d-458f-ac74-a51dc042d072",
	'systypes_pkg',
	'',
	'',
	'systypes_pkg',
	0,
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("aaa6d828-7883-45f8-9fcc-4f34f0d1fe31",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("aaa6d828-7883-45f8-9fcc-4f34f0d1fe31",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("aaa6d828-7883-45f8-9fcc-4f34f0d1fe31",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"91c622fc-46ea-4562-b74f-20f6b932fd41",
	'current_attribute',
	'',
	'',
	'current_attribute',
	0,
	"579b8247-e153-481d-8926-384cdc722464",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("5c90552c-bf69-4f71-803c-c6f9c5ff7f53",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("5c90552c-bf69-4f71-803c-c6f9c5ff7f53",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("5c90552c-bf69-4f71-803c-c6f9c5ff7f53",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"aaa6d828-7883-45f8-9fcc-4f34f0d1fe31",
	'current_class',
	'',
	'',
	'current_class',
	0,
	"63f4ff99-f127-443b-a678-30ace41da702",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("a29ee3ee-25b1-4cde-9a6e-a73282855d83",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("a29ee3ee-25b1-4cde-9a6e-a73282855d83",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("a29ee3ee-25b1-4cde-9a6e-a73282855d83",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"5c90552c-bf69-4f71-803c-c6f9c5ff7f53",
	'current_class_op',
	'',
	'',
	'current_class_op',
	0,
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("d073944f-87eb-41fe-a88f-ba99015e0942",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("d073944f-87eb-41fe-a88f-ba99015e0942",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("d073944f-87eb-41fe-a88f-ba99015e0942",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"a29ee3ee-25b1-4cde-9a6e-a73282855d83",
	'current_component',
	'',
	'',
	'current_component',
	0,
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("9544e119-2a7e-41a3-9186-adede47b3706",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("9544e119-2a7e-41a3-9186-adede47b3706",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("9544e119-2a7e-41a3-9186-adede47b3706",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"d073944f-87eb-41fe-a88f-ba99015e0942",
	'current_domain_function',
	'',
	'',
	'current_domain_function',
	0,
	"60690409-5a69-45db-896b-5a63a9103c18",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("0fe1f04c-efb9-4576-ae62-0e360518a86e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("0fe1f04c-efb9-4576-ae62-0e360518a86e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("0fe1f04c-efb9-4576-ae62-0e360518a86e",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"9544e119-2a7e-41a3-9186-adede47b3706",
	'current_function_param',
	'',
	'',
	'current_function_param',
	0,
	"a01a1995-8ff8-44fe-abb1-b11213d98016",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("d4844833-3d25-4252-8498-0fa502c024b0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("d4844833-3d25-4252-8498-0fa502c024b0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("d4844833-3d25-4252-8498-0fa502c024b0",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"0fe1f04c-efb9-4576-ae62-0e360518a86e",
	'current_imported_component',
	'',
	'',
	'current_imported_component',
	0,
	"4bf19d7e-1bcd-469a-b056-4523dd59dc1d",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("874339c3-eb9d-4ec5-b7fe-2532a669d8cf",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("874339c3-eb9d-4ec5-b7fe-2532a669d8cf",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("874339c3-eb9d-4ec5-b7fe-2532a669d8cf",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"d4844833-3d25-4252-8498-0fa502c024b0",
	'current_interface',
	'',
	'',
	'current_interface',
	0,
	"80698720-cc57-44ba-8aa5-600c524db338",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("d3db8064-bbd2-4bad-b5ba-6cee16c327f2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("d3db8064-bbd2-4bad-b5ba-6cee16c327f2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("d3db8064-bbd2-4bad-b5ba-6cee16c327f2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"874339c3-eb9d-4ec5-b7fe-2532a669d8cf",
	'current_operation_param',
	'',
	'',
	'current_operation_param',
	0,
	"eeb98cba-1a0c-4d36-80f1-c0199a301aaf",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("700c0f08-14df-4396-b3ed-676659b8fc6c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("700c0f08-14df-4396-b3ed-676659b8fc6c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("700c0f08-14df-4396-b3ed-676659b8fc6c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"d3db8064-bbd2-4bad-b5ba-6cee16c327f2",
	'current_pragma',
	'',
	'',
	'current_pragma',
	0,
	"e09ea014-4e29-4685-9e51-04ec59136f92",
	'',
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e09ea014-4e29-4685-9e51-04ec59136f92",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ooapragma>',
	'',
	'',
	'../../marking/marking.xtuml');
INSERT INTO O_NBATTR
	VALUES ("80d1652d-6e68-49f6-8cb0-ec888d5f5a95",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("80d1652d-6e68-49f6-8cb0-ec888d5f5a95",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("80d1652d-6e68-49f6-8cb0-ec888d5f5a95",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"700c0f08-14df-4396-b3ed-676659b8fc6c",
	'current_rel',
	'',
	'',
	'current_rel',
	0,
	"adf5f27c-f258-4227-9506-a77e056789cf",
	'',
	'');
INSERT INTO S_DT_PROXY
	VALUES ("adf5f27c-f258-4227-9506-a77e056789cf",
	"00000000-0000-0000-0000-000000000000",
	'relationship_data',
	'',
	'',
	'../m2x.xtuml');
INSERT INTO O_NBATTR
	VALUES ("9a9d4bea-ee3c-4a9c-b146-7a8d78c608a9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("9a9d4bea-ee3c-4a9c-b146-7a8d78c608a9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("9a9d4bea-ee3c-4a9c-b146-7a8d78c608a9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"80d1652d-6e68-49f6-8cb0-ec888d5f5a95",
	'current_state',
	'',
	'',
	'current_state',
	0,
	"ce86dade-b263-4245-8001-19dd4123f4f9",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("5d2c453e-0c23-4977-ae17-f4efa0f996a2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("5d2c453e-0c23-4977-ae17-f4efa0f996a2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("5d2c453e-0c23-4977-ae17-f4efa0f996a2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"9a9d4bea-ee3c-4a9c-b146-7a8d78c608a9",
	'processingIdentifier',
	'',
	'',
	'processingIdentifier',
	0,
	"ba5eda7a-def5-0000-0000-000000000002",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("a87ae06c-5eae-4954-b098-cf1ad3e82e6d",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("a87ae06c-5eae-4954-b098-cf1ad3e82e6d",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("a87ae06c-5eae-4954-b098-cf1ad3e82e6d",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"5d2c453e-0c23-4977-ae17-f4efa0f996a2",
	'processingISM',
	'',
	'',
	'processingISM',
	0,
	"ba5eda7a-def5-0000-0000-000000000001",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("ff62e971-3250-4eec-8f67-b5dade7ba3d9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("ff62e971-3250-4eec-8f67-b5dade7ba3d9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("ff62e971-3250-4eec-8f67-b5dade7ba3d9",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"a87ae06c-5eae-4954-b098-cf1ad3e82e6d",
	'current_type',
	'',
	'',
	'current_type',
	0,
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("05c73ac0-e6a3-4167-a20f-8ccca99fb3b3",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("05c73ac0-e6a3-4167-a20f-8ccca99fb3b3",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("05c73ac0-e6a3-4167-a20f-8ccca99fb3b3",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"ff62e971-3250-4eec-8f67-b5dade7ba3d9",
	'current_event',
	'',
	'',
	'current_event',
	0,
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("268c47ac-5408-441d-a688-7caa2492d3ef",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("268c47ac-5408-441d-a688-7caa2492d3ef",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("268c47ac-5408-441d-a688-7caa2492d3ef",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"05c73ac0-e6a3-4167-a20f-8ccca99fb3b3",
	'current_executable_property',
	'',
	'',
	'current_executable_property',
	0,
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("79311da9-c35e-4161-bde8-a8cc245fa774",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("79311da9-c35e-4161-bde8-a8cc245fa774",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("79311da9-c35e-4161-bde8-a8cc245fa774",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"268c47ac-5408-441d-a688-7caa2492d3ef",
	'processingProject',
	'',
	'',
	'processingProject',
	0,
	"ba5eda7a-def5-0000-0000-000000000001",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("b4a4041a-4d6a-4f68-bcbd-3cc40e50e51c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("b4a4041a-4d6a-4f68-bcbd-3cc40e50e51c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("b4a4041a-4d6a-4f68-bcbd-3cc40e50e51c",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"79311da9-c35e-4161-bde8-a8cc245fa774",
	'current_routine_info',
	'',
	'',
	'current_routine_info',
	0,
	"97487c7a-2635-4fbd-9f27-1c7dc29cf1a3",
	'',
	'');
INSERT INTO S_DT_PROXY
	VALUES ("97487c7a-2635-4fbd-9f27-1c7dc29cf1a3",
	"00000000-0000-0000-0000-000000000000",
	'routine_info',
	'',
	'',
	'../m2x.xtuml');
INSERT INTO O_NBATTR
	VALUES ("c1793732-f9d7-4012-8b28-d453f9eebad4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("c1793732-f9d7-4012-8b28-d453f9eebad4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("c1793732-f9d7-4012-8b28-d453f9eebad4",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"b4a4041a-4d6a-4f68-bcbd-3cc40e50e51c",
	'current_interface_param',
	'',
	'',
	'current_interface_param',
	0,
	"4d4c0ef2-2520-4dbe-8096-a56393ea3f85",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("cbb496d1-0bdf-4179-b0cf-b768f18425c2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("cbb496d1-0bdf-4179-b0cf-b768f18425c2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("cbb496d1-0bdf-4179-b0cf-b768f18425c2",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"c1793732-f9d7-4012-8b28-d453f9eebad4",
	'current_event_dataitem',
	'',
	'',
	'current_event_dataitem',
	0,
	"9067a5b1-aa5d-499a-b13e-9bde5fc3e2cd",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("a9e16f91-ac24-4273-9b33-4e0bbc364ac1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("a9e16f91-ac24-4273-9b33-4e0bbc364ac1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("a9e16f91-ac24-4273-9b33-4e0bbc364ac1",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"cbb496d1-0bdf-4179-b0cf-b768f18425c2",
	'current_exp',
	'',
	'',
	'current_exp',
	0,
	"47b02a5f-ecfb-49c6-bf1a-6e4a2ff6de02",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("91c622fc-46ea-4562-b74f-20f6b932fd41",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_BATTR
	VALUES ("91c622fc-46ea-4562-b74f-20f6b932fd41",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ATTR
	VALUES ("91c622fc-46ea-4562-b74f-20f6b932fd41",
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	"d97ed044-ca29-43b4-984c-07f8fcb4ee9f",
	'globaltypes_pkg',
	'',
	'',
	'globaltypes_pkg',
	0,
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ID
	VALUES (1,
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO O_ID
	VALUES (2,
	"d83a32f7-3bab-45d1-822a-1b39cbf519e7");
INSERT INTO PE_PE
	VALUES ("d83a32f7-3bab-45d1-822a-1b39cbf519e7",
	1,
	"1800b076-78da-4923-9981-c067ad8e1b87",
	"00000000-0000-0000-0000-000000000000",
	4);
INSERT INTO EP_PKG_PROXY
	VALUES ("1800b076-78da-4923-9981-c067ad8e1b87",
	"c14b4fcc-99ce-417f-85d7-ac22e2d20288",
	"c14b4fcc-99ce-417f-85d7-ac22e2d20288",
	'm2x',
	'',
	0,
	'../m2x.xtuml');
