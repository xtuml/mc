<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\>
<| (C) Copyright Mentor Graphics Corporation (1998-2005)             |>
<| Property of Mentor Graphics Corporation                           |>
<| All Rights Reserved.                                              |>
<\__________________________________________________________________-->
<chapter id="Callout-chapter">
<title id="Callout-chapter-title">Interface Call-outs</title>
<highlights id="Callout-chapter-high"><para>Interface call-outs
allow the user to capture execution control of the generated system
running on a target.</para></highlights>

<para>Especially in
the deeply embedded software development world, it may be
necessary to tightly interface the xtUML system to the 
surrounding/containing system.  &escher; provides callout routines
that enable the user to easily interface code generated by the
model compiler with other system code.  These callout
routines are empty when generated by the model compiler.  It is
up to the user to define additional functionality (if necessary)
to be performed at these callout points.</para>

<section>
  <title>Using Callouts</title>
  <highlights><para>&escher; tries to provide callout functions at
  as many key points of control as possible.  It is the goal of the
  model compiler to make it easy for the user to interface to the
  generated code.</para></highlights>
  
  <para>The user callout file <filename>sys_user_co.c</filename>
  will initially be generated into the source directory
  (<filename>/src</filename>).
  After being generated once, it is common to copy the file to the
  <filename>/gen</filename> folder to be edited.  (Note that hand
  edited/modified .c and .h
  files in the <filename>/gen</filename> folder get copied on top of
  files in the <filename>/src</filename> folder at build time.)
  The user
  should add invocations from this file into appropriate system
  specific functionality.</para>

  <para>&escher; generates hooks into the generated at key points
  where these callouts are needed.  In early versions of &escher;,
  these hooks represented real C instructions
  even if the callouts where not being used actively.  In
  recent versions, the <filename>sys_user_co.h</filename>
  defines the hooks as macros.  Until they are activated,
  they take no time or space inline with the generated code.
  They are effectively invisible.
  The comments in the sys_user_co files explain how to
  activate and modify the callouts.</para>

  <section>
    <title>Callout Routines Provided</title>
    <para>Edit <filename>sys_user_co.h </filename> to activate
    particular callout functions.  Edit
    <filename>sys_user_co.c</filename> to add code to the defined
    callout routines.  It is important that both files be edited to
    enable the callout capability.</para>

    <section>
      <title>User Initialization</title>
      <para>This function is invoked at the immediate beginning of
      application initialization.  It is the very first function to be
      executed at system startup.  User supplied implementation of
      this function should be restricted to things like memory
      initialization, early hardware duties, etc.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserInitializationCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Bring-up Initialization</title>
        <programlisting>
        void UserInitializationCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Pre-xtUML Initialization</title>
      <para>This function is invoked immediately prior to executing
      any xtUML application initialization function.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserPreOoaInitializationCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Pre-xtUML Initialization</title>
        <programlisting>
        void UserPreOoaInitializationCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Post-xtUML Initialization</title>
      <para>This function is invoked immediately after executing any/all
      xtUML application initialization function(s).  When this
      callout function returns, the system dispatcher will allow the
      xtUML state models to start consuming events.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserPostOoaInitializationCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Post-xtUML Initialization</title>
        <programlisting>
        void UserPostOoaInitializationCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Background Processing</title>
      <para>This function is invoked once during each loop execution
      of the system dispatcher.  (This may be an excellent place to
      hang an invocation to a timer (TIM) tick routine.)</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserBackgroundProcessingCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Background Processing</title>
        <programlisting>
        void UserBackgroundProcessingCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Pre-Shutdown Processing</title>
      <para>This function is invoked at termination of the system
      dispatcher, but prior to performing any xtUML application
      shutdown sequencing.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserPreShutdownCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Pre-Shutdown</title>
        <programlisting>
        void UserPreShutdownCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Post-Shutdown Processing</title>
      <para>This function is invoked immediately before application
      exit.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserPostShutdownCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Post-Shutdown Callout</title>
        <programlisting>
        void UserPostShutdownCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Event ``Can't Happen'' Processing</title>
      <para>This function is invoked any time that an event is
      received that results in a ``can't happen'' transition.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserEventCantHappenCallout</function></funcdef>
      <paramdef>const Escher_StateNumber_t <parameter>current_state</parameter></paramdef>
      <paramdef>const Escher_StateNumber_t <parameter>next_state</parameter></paramdef>
      <paramdef>const Escher_EventNumber_t <parameter>event_number</parameter></paramdef>
      </funcprototype>
      </funcsynopsis>

      <para>Where the input parameters are:</para>

      <variablelist>
        <varlistentry><term>current_state</term><listitem><para>is
        the number of the state before the
        transition.</para></listitem></varlistentry>
        <varlistentry><term>next_state</term><listitem><para>is
        the number of the calculated next
        state.</para></listitem></varlistentry>
        <varlistentry><term>event_number</term><listitem><para>is
        the number of the event that is stimulating this
        transition.</para></listitem></varlistentry>
      </variablelist>

      <example>
        <title>Event Can't Happen</title>
        <programlisting>
        void UserEventCantHappenCallout( const Escher_StateNumber_t current_state,
                                         const Escher_StateNumber_t next_state,
                                         const Escher_EventNumber_t event_number
        )
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Event with No Instance Processing</title>
      <para>This function is invoked any time that an event is
      received and there is no target instance to receive it.  This
      often means that the instance was deleted while the event was
      in flight.  Usually this indicates a modeling error.  The
      default behavior without supplying a body to this function is
      simply to consume the event and go on.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserEventNoInstanceCallout</function></funcdef>
      <paramdef>const Escher_EventNumber_t <parameter>event_number</parameter></paramdef>
      </funcprototype>
      </funcsynopsis>

      <para>Where the input parameters are:</para>

      <variablelist>
        <varlistentry><term>current_state</term><listitem><para>is
        the number of the state when event is
        dispatched.</para></listitem></varlistentry>
        <varlistentry><term>next_state</term><listitem><para>is
        the number of the calculated next
        state.</para></listitem></varlistentry>
        <varlistentry><term>event_number</term><listitem><para>is
        the number of the event that is landing on the missing
        object instance.</para></listitem></varlistentry>
      </variablelist>

      <example>
        <title>Event with No Instance</title>
        <programlisting>
        void UserEventNoInstanceCallout( const Escher_EventNumber_t event_number
        )
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Event Free List Empty</title>
      <para>This function is invoked when an attempt is made to
      allocate an event, but there are no more left.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserEventFreeListEmptyCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>

      <example>
        <title>Event Free List Empty Handler</title>
        <programlisting>
        void UserEventFreeListEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>

    <section>
      <title>User Empty Handle Detection</title>
      <para>When marked active, this function is invoked
      when an attempt is made to
      use an instance reference variable (handle) that is null
      (empty).</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserEmptyHandleDetectedCallout</function></funcdef>
      <paramdef>c_t * <parameter>object_keyletters</parameter></paramdef>
      <paramdef>c_t * <parameter>string</parameter></paramdef>
      </funcprototype>
      </funcsynopsis>
      <example>
        <title>User Empty Handle Detection</title>
        <programlisting>
        void UserEmptyHandleDetectedCallout( const char * object_keyletters,
                                             const char * s )
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>User Object Pool Empty Handling</title>
      <para>This function is called from instance creation
      methods when an attempt is made to create an instance
      of an object and no allocation units are available.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserObjectPoolEmptyCallout</function></funcdef>
      <paramdef>c_t * <parameter>domain</parameter></paramdef>
      <paramdef>c_t * <parameter>object_name</parameter></paramdef>
      </funcprototype>
      </funcsynopsis>
      <example>
        <title>Object Pool Empty</title>
        <programlisting>
        void UserObjectPoolEmptyCallout( const char * domain,
                                         const char * object_name )
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>Empty Node List Handling</title>
      <para>&escher; uses a collection of set ``containoids'' to
      link data items together in lists.  These utility list
      nodes are used collecting extents, events and relationships.
      In the situation that an attempt is made to allocate a node,
      but none are available, this function will be called.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserNodeListEmptyCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>
      <example>
        <title>Node List Empty</title>
        <programlisting>
        void UserNodeListEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
    <section>
      <title>Overflow of Interleaved Bridge Invocations</title>
      <para>&escher; uses an array as a queue to manage invocations
      of interleaved bridges (bridge operations marked safe for
      interrupt invocation).  UserInterleavedBridgeOverflowCallout
      is invoked when an attempt is made to post too many
      interleaved bridges.  The depth of this list is defined by
      SYS_MAX_INTERLEAVED_BRIDGES (unless changed in the rule file).</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserInterleavedBridgeOverflowCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>
      <example>
        <title>Overflow of Interleaved Bridge</title>
        <programlisting>
        void UserInterleavedBridgeOverflowCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>

    <section>
      <title>Empty Event Queue Callouts</title>
      <para>If the user wishes to gain control of processing when
      either of the two event queues are empty (no events to
      be processed at the current time), two callouts are provided.
      <function>UserSelfEventQueueEmptyCallout</function> and
      <function>UserNonSelfEventQueueEmptyCallout</function> are
      invoked (assuming they are enabled) each time the corresponding
      event queue is interrogated and found to be empty.</para>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserSelfEventQueueEmptyCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
      <funcprototype>
      <funcdef><function>UserNonSelfEventQueueEmptyCallout</function></funcdef>
      <void/>
      </funcprototype>
      </funcsynopsis>
      <example>
        <title>Event Queue Empty Notification</title>
        <programlisting>
        void UserSelfEventQueueEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        void UserNonSelfEventQueueEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </programlisting>
      </example>
    </section>
            
  </section>

</section>


    
</chapter>
