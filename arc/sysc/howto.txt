       HOW to use and test special features of the SystemC MC 


The C++ template feature.
-------------------------
The markings are exactly as specified in the issue and proposal.
Note that SetTemplateParameter takes package, instance, variable
and value.  For a component instance, the instance parameter is
the ClassifierName for the desired component reference.  When
setting a template parameter on an interface, the instance is
the port in the named package.

Warning!  Because the port names and component reference names
can (and often are) the same, SetTemplateParameter will assume
it is operating on the template most recently created.  In other
words, the user must Mark the template, Mark the addition
of the parameters and then set those parameters in sequence.

For example:
.//
.invoke MarkInterfaceWithTemplate("", "wait_out")
.invoke AddTemplateParameter("", "wait_out", "class", "T", "rgb_t")
.invoke SetTemplateParameter("simtop", "dout", "T", "rgb_t")
.invoke SetTemplateParameter("simtop", "Port1", "T", "rgb_t")
.invoke SetTemplateParameter("simtop", "tbdin", "T", "rgb_t")
.invoke SetTemplateParameter("filt_top", "dout", "T", "rgb_t")
.invoke SetTemplateParameter("filt_hfilt1", "dout", "T", "ycbcr_t")
.invoke SetTemplateParameter("filt_hfilt2", "dout", "T", "rgb_t")
.//
.invoke MarkInterfaceWithTemplate("", "wait_in")
.invoke AddTemplateParameter("", "wait_in", "class", "T", "ycbcr_t")
.invoke SetTemplateParameter("simtop", "din", "T", "ycbcr_t")
.invoke SetTemplateParameter("simtop", "Port2", "T", "ycbcr_t")
.invoke SetTemplateParameter("simtop", "tbdout", "T", "ycbcr_t")
.invoke SetTemplateParameter("filt_top", "din", "T", "ycbcr_t")
.invoke SetTemplateParameter("filt_hfilt1", "din", "T", "ycbcr_t")
.invoke SetTemplateParameter("filt_hfilt2", "din", "T", "ycbcr_t")
.//
.invoke MarkComponentWithTemplate("", "wait_hs")
.invoke AddTemplateParameter("", "wait_hs", "class", "T", "")
.invoke AddTemplateParameter("", "wait_hs", "class", "U", "")
.invoke SetTemplateParameter("filt_top", "sig", "U", "u1_t")
.invoke SetTemplateParameter("simtop", "din", "U", "u2_t")
.invoke SetTemplateParameter("simtop", "dout", "U", "u4_t")
.invoke SetTemplateParameter("filt_top", "sig", "T", "s1_t")
.invoke SetTemplateParameter("simtop", "din", "T", "s2_t")
.invoke SetTemplateParameter("simtop", "dout", "T", "s4_t")

The above is a legal ordering.  Do not mix the adding or the setting
of template parameters between templates.  Complete the population
of one template before defining the next one.

Be sure to name ports in a way that they can all be marked.  Do
not reuse the same port name when connecting to different interfaces.

Interfaces template parameters must be supplied with a default
value which is used in the channel signal declarations.

Interfaces that are marked for templates must be structured interfaces.
This means that wait_in needs to have another message added to it (put).

For testing, proprietary types must be "typedef'd away".  This is
because these types are not defined in our testing environment.
An easy way to do this is to:
1.  Copy sys_trace.h from the /src folder to the /gen folder.
2.  Edit it and add typedefs that give native C types to the
    types named in the marks.
    For example:
typedef int ycbcr_t;

Run with the 3.2.2 version of the model compiler.
Upgrade the xtumlmc_build.exe to work with new SystemC licensing.
Remember to place the updated xtumlmc_schema.sql in the proper
location .../plugins/..../mc3020/schema/sql/xtumlmc_schema.sql.


The Pre-defined Channel feature.
--------------------------------
The model compiler now supports marking individual components as pre-defined 
channels using the marking:

   .invoke MarkAsChannel( <package name>, <component name>, <include file name>)

For example:

   .invoke MarkAsChannel( "*", "wait_hs", "my_channel.h")

Components that are marked as pre-defined channels have no internal behavior
generated for them by the model compiler.  Instead, the implementation is
expected to be provided by the referenced include file.

In components that make use of pre-defined channels, the channel declaration is
bypassed.  In addition, the binding of ports inside the pre-defined channel is 
bypassed and components that use the pre-defined channel are bound to the 
pre-defined channel's name instead of the channel generated by the model 
compiler. 



g++ -I. -I/systemc-2.2.0/include/ -L. -c *.cpp; g++ *.o -L/systemc-2.2.0/lib-cygwin/ -lsystemc
